#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut,
    unsafe_op_in_unsafe_fn
)]
#![feature(c_variadic, extern_types)]

mod ldo;
mod mem;
mod object;
mod opcodes;
mod zio;

use libc::{
    __errno_location, FILE, abort, abs, clearerr, close, difftime, dlclose, dlerror, dlopen, dlsym,
    exit, fclose, feof, ferror, fflush, fgets, fopen, fprintf, fread, free, freopen, fseeko,
    ftello, fwrite, getenv, gmtime_r, localeconv, localtime_r, memchr, memcmp, memcpy, mkstemp,
    mktime, pclose, popen, realloc, remove, rename, setlocale, setvbuf, snprintf, strchr, strcmp,
    strcoll, strcpy, strerror, strftime, strlen, strncmp, strpbrk, strspn, strstr, strtod, system,
    time, tm, tmpfile, tolower, toupper, ungetc,
};
use std::{ffi::c_void, ptr};

use ldo::*;
use mem::*;
use object::*;
use opcodes::*;
use zio::*;

unsafe extern "C-unwind" {
    static mut stdin: *mut FILE;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn getc(__stream: *mut FILE) -> i32;
    fn getc_unlocked(__stream: *mut FILE) -> i32;
    fn flockfile(__stream: *mut FILE);
    fn funlockfile(__stream: *mut FILE);
    fn clock() -> clock_t;
    fn frexp(_: std::ffi::c_double, _: *mut i32) -> std::ffi::c_double;
    fn ldexp(_: std::ffi::c_double, _: i32) -> std::ffi::c_double;
    fn fmod(_: std::ffi::c_double, _: std::ffi::c_double) -> std::ffi::c_double;
    fn __ctype_b_loc() -> *mut *const u16;
}
pub type ptrdiff_t = isize;
pub type size_t = usize;
pub type __off_t = std::ffi::c_long;
pub type __off64_t = std::ffi::c_long;
pub type __clock_t = std::ffi::c_long;
pub type __time_t = std::ffi::c_long;
pub type __sig_atomic_t = i32;
pub type intptr_t = isize;
pub type uintptr_t = usize;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lua_State {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub status: lu_byte,
    pub allowhook: lu_byte,
    pub nci: u16,
    pub top: StkIdRel,
    pub l_G: *mut global_State,
    pub ci: *mut CallInfo,
    pub stack_last: StkIdRel,
    pub stack: StkIdRel,
    pub openupval: *mut UpVal,
    pub tbclist: StkIdRel,
    pub gclist: *mut GCObject,
    pub twups: *mut lua_State,
    pub errorJmp: *mut lua_longjmp,
    pub base_ci: CallInfo,
    pub hook: lua_Hook,
    pub errfunc: ptrdiff_t,
    pub nCcalls: l_uint32,
    pub oldpc: i32,
    pub basehookcount: i32,
    pub hookcount: i32,
    pub hookmask: sig_atomic_t,
}

pub const LUA_TNONE: i8 = -1;
pub const LUA_TNIL: i8 = 0;
pub const LUA_TBOOLEAN: i8 = 1;
pub const LUA_TLIGHTUSERDATA: i8 = 2;
pub const LUA_TNUMBER: i8 = 3;
pub const LUA_TSTRING: i8 = 4;
pub const LUA_TTABLE: i8 = 5;
pub const LUA_TFUNCTION: i8 = 6;
pub const LUA_TUSERDATA: i8 = 7;
pub const LUA_TTHREAD: i8 = 8;
pub const LUA_NUMTYPES: i8 = 9;

pub type sig_atomic_t = __sig_atomic_t;
pub type l_uint32 = u32;
pub type lua_Hook = Option<unsafe extern "C-unwind" fn(*mut lua_State, *mut lua_Debug) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lua_Debug {
    pub event: i32,
    pub name: *const std::ffi::c_char,
    pub namewhat: *const std::ffi::c_char,
    pub what: *const std::ffi::c_char,
    pub source: *const std::ffi::c_char,
    pub srclen: size_t,
    pub currentline: i32,
    pub linedefined: i32,
    pub lastlinedefined: i32,
    pub nups: u8,
    pub nparams: u8,
    pub isvararg: std::ffi::c_char,
    pub istailcall: std::ffi::c_char,
    pub ftransfer: u16,
    pub ntransfer: u16,
    pub short_src: [std::ffi::c_char; 60],
    pub i_ci: *mut CallInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CallInfo {
    pub func: StkIdRel,
    pub top: StkIdRel,
    pub previous: *mut CallInfo,
    pub next: *mut CallInfo,
    pub u: CallInfoState,
    pub u2: CallInfoUnion2,
    pub nresults: std::ffi::c_short,
    pub callstatus: u16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union CallInfoUnion2 {
    pub funcidx: i32,
    pub nyield: i32,
    pub nres: i32,
    pub transferinfo: CallInfoTransferredValues,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CallInfoTransferredValues {
    pub ftransfer: u16,
    pub ntransfer: u16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union CallInfoState {
    pub l: CallInfoLuaState,
    pub c: CallInfoCState,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CallInfoCState {
    pub k: lua_KFunction,
    pub old_errfunc: ptrdiff_t,
    pub ctx: lua_KContext,
}
pub type lua_KContext = intptr_t;
pub type lua_KFunction =
    Option<unsafe extern "C-unwind" fn(*mut lua_State, i32, lua_KContext) -> i32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CallInfoLuaState {
    pub savedpc: *const Instruction,
    pub trap: sig_atomic_t,
    pub nextraargs: i32,
}
pub type Instruction = u32;
#[derive(Copy, Clone)]
#[repr(C)]
pub union StkIdRel {
    pub p: StkId,
    pub offset: ptrdiff_t,
}
pub type StkId = *mut StackValue;
#[derive(Copy, Clone)]
#[repr(C)]
pub union StackValue {
    pub val: TValue,
    pub tbclist: ToBeClosedList,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ToBeClosedList {
    pub value_: Value,
    pub tt_: lu_byte,
    pub delta: u16,
}
pub type lu_byte = u8;
#[derive(Copy, Clone)]
#[repr(C)]
pub union Value {
    pub gc: *mut GCObject,
    pub p: *mut c_void,
    pub f: lua_CFunction,
    pub i: lua_Integer,
    pub n: lua_Number,
    pub ub: lu_byte,
}
pub type lua_Number = f64;
pub type lua_Integer = i64;
pub type lua_CFunction = Option<unsafe extern "C-unwind" fn(*mut lua_State) -> i32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GCObject {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TValue {
    pub value_: Value,
    pub tt_: lu_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lua_longjmp {
    pub previous: *mut lua_longjmp,
    pub status: i32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UpVal {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub v: UpValValuePtr,
    pub u: UpValLinksOrValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union UpValLinksOrValue {
    pub open: UpValLinks,
    pub value: TValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UpValLinks {
    pub next: *mut UpVal,
    pub previous: *mut *mut UpVal,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union UpValValuePtr {
    pub p: *mut TValue,
    pub offset: ptrdiff_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct global_State {
    pub frealloc: lua_Alloc,
    pub ud: *mut c_void,
    pub totalbytes: l_mem,
    pub GCdebt: l_mem,
    pub GCestimate: lu_mem,
    pub lastatomic: lu_mem,
    pub strt: stringtable,
    pub l_registry: TValue,
    pub nilvalue: TValue,
    pub seed: u32,
    pub currentwhite: lu_byte,
    pub gcstate: lu_byte,
    pub gckind: lu_byte,
    pub gcstopem: lu_byte,
    pub genminormul: lu_byte,
    pub genmajormul: lu_byte,
    pub gcstp: lu_byte,
    pub gcemergency: lu_byte,
    pub gcpause: lu_byte,
    pub gcstepmul: lu_byte,
    pub gcstepsize: lu_byte,
    pub allgc: *mut GCObject,
    pub sweepgc: *mut *mut GCObject,
    pub finobj: *mut GCObject,
    pub gray: *mut GCObject,
    pub grayagain: *mut GCObject,
    pub weak: *mut GCObject,
    pub ephemeron: *mut GCObject,
    pub allweak: *mut GCObject,
    pub tobefnz: *mut GCObject,
    pub fixedgc: *mut GCObject,
    pub survival: *mut GCObject,
    pub old1: *mut GCObject,
    pub reallyold: *mut GCObject,
    pub firstold1: *mut GCObject,
    pub finobjsur: *mut GCObject,
    pub finobjold1: *mut GCObject,
    pub finobjrold: *mut GCObject,
    pub twups: *mut lua_State,
    pub panic: lua_CFunction,
    pub mainthread: *mut lua_State,
    pub memerrmsg: *mut TString,
    pub tmname: [*mut TString; 25],
    pub mt: [*mut Table; 9],
    pub strcache: [[*mut TString; 2]; 53],
    pub warnf: lua_WarnFunction,
    pub ud_warn: *mut c_void,
}
pub type lua_WarnFunction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *const std::ffi::c_char, i32) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TString {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub extra: lu_byte,
    pub shrlen: lu_byte,
    pub hash: u32,
    pub u: C2RustUnnamed_8,
    pub contents: [std::ffi::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub lnglen: size_t,
    pub hnext: *mut TString,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Table {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub flags: lu_byte,
    pub lsizenode: lu_byte,
    pub alimit: u32,
    pub array: *mut TValue,
    pub node: *mut Node,
    pub lastfree: *mut Node,
    pub metatable: *mut Table,
    pub gclist: *mut GCObject,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Node {
    pub u: NodeKey,
    pub i_val: TValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct NodeKey {
    pub value_: Value,
    pub tt_: lu_byte,
    pub key_tt: lu_byte,
    pub next: i32,
    pub key_val: Value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stringtable {
    pub hash: *mut *mut TString,
    pub nuse: i32,
    pub size: i32,
}
pub type lu_mem = size_t;
pub type l_mem = isize;
pub type lua_Alloc =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void, size_t, size_t) -> *mut c_void>;
pub type lua_Unsigned = u64;
pub type lua_Reader = Option<
    unsafe extern "C-unwind" fn(
        *mut lua_State,
        *mut c_void,
        *mut size_t,
    ) -> *const std::ffi::c_char,
>;
pub type lua_Writer =
    Option<unsafe extern "C-unwind" fn(*mut lua_State, *const c_void, size_t, *mut c_void) -> i32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LG {
    pub l: LX,
    pub g: global_State,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LX {
    pub extra_: [lu_byte; 8],
    pub l: lua_State,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union GCUnion {
    pub gc: GCObject,
    pub ts: TString,
    pub u: Udata,
    pub cl: Closure,
    pub h: Table,
    pub p: Proto,
    pub th: lua_State,
    pub upv: UpVal,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Proto {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub numparams: lu_byte,
    pub is_vararg: lu_byte,
    pub maxstacksize: lu_byte,
    pub sizeupvalues: i32,
    pub sizek: i32,
    pub sizecode: i32,
    pub sizelineinfo: i32,
    pub sizep: i32,
    pub sizelocvars: i32,
    pub sizeabslineinfo: i32,
    pub linedefined: i32,
    pub lastlinedefined: i32,
    pub k: *mut TValue,
    pub code: *mut Instruction,
    pub p: *mut *mut Proto,
    pub upvalues: *mut Upvaldesc,
    pub lineinfo: *mut ls_byte,
    pub abslineinfo: *mut AbsLineInfo,
    pub locvars: *mut LocVar,
    pub source: *mut TString,
    pub gclist: *mut GCObject,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LocVar {
    pub varname: *mut TString,
    pub startpc: i32,
    pub endpc: i32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AbsLineInfo {
    pub pc: i32,
    pub line: i32,
}
pub type ls_byte = std::ffi::c_schar;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Upvaldesc {
    pub name: *mut TString,
    pub instack: lu_byte,
    pub idx: lu_byte,
    pub kind: lu_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Closure {
    pub c: CClosure,
    pub l: LClosure,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LClosure {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub nupvalues: lu_byte,
    pub gclist: *mut GCObject,
    pub p: *mut Proto,
    pub upvals: [*mut UpVal; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CClosure {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub nupvalues: lu_byte,
    pub gclist: *mut GCObject,
    pub f: lua_CFunction,
    pub upvalue: [TValue; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Udata {
    pub next: *mut GCObject,
    pub tt: lu_byte,
    pub marked: lu_byte,
    pub nuvalue: u16,
    pub len: size_t,
    pub metatable: *mut Table,
    pub gclist: *mut GCObject,
    pub uv: [UValue; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union UValue {
    pub uv: TValue,
    pub n: lua_Number,
    pub u: std::ffi::c_double,
    pub s: *mut c_void,
    pub i: lua_Integer,
    pub l: std::ffi::c_long,
}
pub const OP_EXTRAARG: OpCode = 82;
pub const TM_MODE: TMS = 3;
pub type TMS = u32;
pub const TM_N: TMS = 25;
pub const TM_CLOSE: TMS = 24;
pub const TM_CALL: TMS = 23;
pub const TM_CONCAT: TMS = 22;
pub const TM_LE: TMS = 21;
pub const TM_LT: TMS = 20;
pub const TM_BNOT: TMS = 19;
pub const TM_UNM: TMS = 18;
pub const TM_SHR: TMS = 17;
pub const TM_SHL: TMS = 16;
pub const TM_BXOR: TMS = 15;
pub const TM_BOR: TMS = 14;
pub const TM_BAND: TMS = 13;
pub const TM_IDIV: TMS = 12;
pub const TM_DIV: TMS = 11;
pub const TM_POW: TMS = 10;
pub const TM_MOD: TMS = 9;
pub const TM_MUL: TMS = 8;
pub const TM_SUB: TMS = 7;
pub const TM_ADD: TMS = 6;
pub const TM_EQ: TMS = 5;
pub const TM_LEN: TMS = 4;
pub const TM_GC: TMS = 2;
pub const TM_NEWINDEX: TMS = 1;
pub const TM_INDEX: TMS = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CloseP {
    pub level: StkId,
    pub status: i32,
}
pub type Pfunc = Option<unsafe extern "C-unwind" fn(*mut lua_State, *mut c_void) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BuffFS {
    pub L: *mut lua_State,
    pub pushed: i32,
    pub blen: i32,
    pub space: [std::ffi::c_char; 199],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lconv {
    pub decimal_point: *mut std::ffi::c_char,
    pub thousands_sep: *mut std::ffi::c_char,
    pub grouping: *mut std::ffi::c_char,
    pub int_curr_symbol: *mut std::ffi::c_char,
    pub currency_symbol: *mut std::ffi::c_char,
    pub mon_decimal_point: *mut std::ffi::c_char,
    pub mon_thousands_sep: *mut std::ffi::c_char,
    pub mon_grouping: *mut std::ffi::c_char,
    pub positive_sign: *mut std::ffi::c_char,
    pub negative_sign: *mut std::ffi::c_char,
    pub int_frac_digits: std::ffi::c_char,
    pub frac_digits: std::ffi::c_char,
    pub p_cs_precedes: std::ffi::c_char,
    pub p_sep_by_space: std::ffi::c_char,
    pub n_cs_precedes: std::ffi::c_char,
    pub n_sep_by_space: std::ffi::c_char,
    pub p_sign_posn: std::ffi::c_char,
    pub n_sign_posn: std::ffi::c_char,
    pub int_p_cs_precedes: std::ffi::c_char,
    pub int_p_sep_by_space: std::ffi::c_char,
    pub int_n_cs_precedes: std::ffi::c_char,
    pub int_n_sep_by_space: std::ffi::c_char,
    pub int_p_sign_posn: std::ffi::c_char,
    pub int_n_sign_posn: std::ffi::c_char,
}
pub const OP_LOADKX: OpCode = 4;
pub const OP_LOADK: OpCode = 3;
pub const OP_GETUPVAL: OpCode = 9;
pub const OP_MOVE: OpCode = 0;
pub type OpCode = u32;
pub const OP_VARARGPREP: OpCode = 81;
pub const OP_VARARG: OpCode = 80;
pub const OP_CLOSURE: OpCode = 79;
pub const OP_SETLIST: OpCode = 78;
pub const OP_TFORLOOP: OpCode = 77;
pub const OP_TFORCALL: OpCode = 76;
pub const OP_TFORPREP: OpCode = 75;
pub const OP_FORPREP: OpCode = 74;
pub const OP_FORLOOP: OpCode = 73;
pub const OP_RETURN1: OpCode = 72;
pub const OP_RETURN0: OpCode = 71;
pub const OP_RETURN: OpCode = 70;
pub const OP_TAILCALL: OpCode = 69;
pub const OP_CALL: OpCode = 68;
pub const OP_TESTSET: OpCode = 67;
pub const OP_TEST: OpCode = 66;
pub const OP_GEI: OpCode = 65;
pub const OP_GTI: OpCode = 64;
pub const OP_LEI: OpCode = 63;
pub const OP_LTI: OpCode = 62;
pub const OP_EQI: OpCode = 61;
pub const OP_EQK: OpCode = 60;
pub const OP_LE: OpCode = 59;
pub const OP_LT: OpCode = 58;
pub const OP_EQ: OpCode = 57;
pub const OP_JMP: OpCode = 56;
pub const OP_TBC: OpCode = 55;
pub const OP_CLOSE: OpCode = 54;
pub const OP_CONCAT: OpCode = 53;
pub const OP_LEN: OpCode = 52;
pub const OP_NOT: OpCode = 51;
pub const OP_BNOT: OpCode = 50;
pub const OP_UNM: OpCode = 49;
pub const OP_MMBINK: OpCode = 48;
pub const OP_MMBINI: OpCode = 47;
pub const OP_MMBIN: OpCode = 46;
pub const OP_SHR: OpCode = 45;
pub const OP_SHL: OpCode = 44;
pub const OP_BXOR: OpCode = 43;
pub const OP_BOR: OpCode = 42;
pub const OP_BAND: OpCode = 41;
pub const OP_IDIV: OpCode = 40;
pub const OP_DIV: OpCode = 39;
pub const OP_POW: OpCode = 38;
pub const OP_MOD: OpCode = 37;
pub const OP_MUL: OpCode = 36;
pub const OP_SUB: OpCode = 35;
pub const OP_ADD: OpCode = 34;
pub const OP_SHLI: OpCode = 33;
pub const OP_SHRI: OpCode = 32;
pub const OP_BXORK: OpCode = 31;
pub const OP_BORK: OpCode = 30;
pub const OP_BANDK: OpCode = 29;
pub const OP_IDIVK: OpCode = 28;
pub const OP_DIVK: OpCode = 27;
pub const OP_POWK: OpCode = 26;
pub const OP_MODK: OpCode = 25;
pub const OP_MULK: OpCode = 24;
pub const OP_SUBK: OpCode = 23;
pub const OP_ADDK: OpCode = 22;
pub const OP_ADDI: OpCode = 21;
pub const OP_SELF: OpCode = 20;
pub const OP_NEWTABLE: OpCode = 19;
pub const OP_SETFIELD: OpCode = 18;
pub const OP_SETI: OpCode = 17;
pub const OP_SETTABLE: OpCode = 16;
pub const OP_SETTABUP: OpCode = 15;
pub const OP_GETFIELD: OpCode = 14;
pub const OP_GETI: OpCode = 13;
pub const OP_GETTABLE: OpCode = 12;
pub const OP_GETTABUP: OpCode = 11;
pub const OP_SETUPVAL: OpCode = 10;
pub const OP_LOADNIL: OpCode = 8;
pub const OP_LOADTRUE: OpCode = 7;
pub const OP_LFALSESKIP: OpCode = 6;
pub const OP_LOADFALSE: OpCode = 5;
pub const OP_LOADF: OpCode = 2;
pub const OP_LOADI: OpCode = 1;
pub const iAx: OpMode = 3;
pub const iABC: OpMode = 0;
pub const iABx: OpMode = 1;
pub const isJ: OpMode = 4;
pub const iAsBx: OpMode = 2;
pub type l_uacNumber = std::ffi::c_double;
pub type l_uacInt = std::ffi::c_longlong;
pub type F2Imod = u32;
pub const F2Iceil: F2Imod = 2;
pub const F2Ifloor: F2Imod = 1;
pub const F2Ieq: F2Imod = 0;
pub const TK_WHILE: RESERVED = 277;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CallS {
    pub func: StkId,
    pub nresults: i32,
}
pub type ZIO = Zio;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Zio {
    pub n: size_t,
    pub p: *const std::ffi::c_char,
    pub reader: lua_Reader,
    pub data: *mut c_void,
    pub L: *mut lua_State,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Labeldesc {
    pub name: *mut TString,
    pub pc: i32,
    pub line: i32,
    pub nactvar: lu_byte,
    pub close: lu_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Labellist {
    pub arr: *mut Labeldesc,
    pub n: i32,
    pub size: i32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Dyndata {
    pub actvar: C2RustUnnamed_9,
    pub gt: Labellist,
    pub label: Labellist,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub arr: *mut Vardesc,
    pub n: i32,
    pub size: i32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Vardesc {
    pub vd: C2RustUnnamed_10,
    pub k: TValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub value_: Value,
    pub tt_: lu_byte,
    pub kind: lu_byte,
    pub ridx: lu_byte,
    pub pidx: std::ffi::c_short,
    pub name: *mut TString,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SParser {
    pub z: *mut ZIO,
    pub buff: Mbuffer,
    pub dyd: Dyndata,
    pub mode: *const std::ffi::c_char,
    pub name: *const std::ffi::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Mbuffer {
    pub buffer: *mut std::ffi::c_char,
    pub n: size_t,
    pub buffsize: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FuncState {
    pub f: *mut Proto,
    pub prev: *mut FuncState,
    pub ls: *mut LexState,
    pub bl: *mut BlockCnt,
    pub pc: i32,
    pub lasttarget: i32,
    pub previousline: i32,
    pub nk: i32,
    pub np: i32,
    pub nabslineinfo: i32,
    pub firstlocal: i32,
    pub firstlabel: i32,
    pub ndebugvars: std::ffi::c_short,
    pub nactvar: lu_byte,
    pub nups: lu_byte,
    pub freereg: lu_byte,
    pub iwthabs: lu_byte,
    pub needclose: lu_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BlockCnt {
    pub previous: *mut BlockCnt,
    pub firstlabel: i32,
    pub firstgoto: i32,
    pub nactvar: lu_byte,
    pub upval: lu_byte,
    pub isloop: lu_byte,
    pub insidetbc: lu_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LexState {
    pub current: i32,
    pub linenumber: i32,
    pub lastline: i32,
    pub t: Token,
    pub lookahead: Token,
    pub fs: *mut FuncState,
    pub L: *mut lua_State,
    pub z: *mut ZIO,
    pub buff: *mut Mbuffer,
    pub h: *mut Table,
    pub dyd: *mut Dyndata,
    pub source: *mut TString,
    pub envn: *mut TString,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Token {
    pub token: i32,
    pub seminfo: SemInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union SemInfo {
    pub r: lua_Number,
    pub i: lua_Integer,
    pub ts: *mut TString,
}
pub const TK_EOS: RESERVED = 288;
pub const TK_INT: RESERVED = 290;
pub const TK_FLT: RESERVED = 289;
pub const TK_STRING: RESERVED = 292;
pub const TK_NAME: RESERVED = 291;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub ival: lua_Integer,
    pub nval: lua_Number,
    pub strval: *mut TString,
    pub info: i32,
    pub ind: C2RustUnnamed_13,
    pub var: C2RustUnnamed_12,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub ridx: lu_byte,
    pub vidx: u16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub idx: std::ffi::c_short,
    pub t: lu_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct expdesc {
    pub k: expkind,
    pub u: C2RustUnnamed_11,
    pub t: i32,
    pub f: i32,
}
pub type expkind = u32;
pub const VVARARG: expkind = 19;
pub const VCALL: expkind = 18;
pub const VRELOC: expkind = 17;
pub const VJMP: expkind = 16;
pub const VINDEXSTR: expkind = 15;
pub const VINDEXI: expkind = 14;
pub const VINDEXUP: expkind = 13;
pub const VINDEXED: expkind = 12;
pub const VCONST: expkind = 11;
pub const VUPVAL: expkind = 10;
pub const VLOCAL: expkind = 9;
pub const VNONRELOC: expkind = 8;
pub const VKSTR: expkind = 7;
pub const VKINT: expkind = 6;
pub const VKFLT: expkind = 5;
pub const VK: expkind = 4;
pub const VFALSE: expkind = 3;
pub const VTRUE: expkind = 2;
pub const VNIL: expkind = 1;
pub const VVOID: expkind = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LHS_assign {
    pub prev: *mut LHS_assign,
    pub v: expdesc,
}
pub type BinOpr = u32;
pub const OPR_NOBINOPR: BinOpr = 21;
pub const OPR_OR: BinOpr = 20;
pub const OPR_AND: BinOpr = 19;
pub const OPR_GE: BinOpr = 18;
pub const OPR_GT: BinOpr = 17;
pub const OPR_NE: BinOpr = 16;
pub const OPR_LE: BinOpr = 15;
pub const OPR_LT: BinOpr = 14;
pub const OPR_EQ: BinOpr = 13;
pub const OPR_CONCAT: BinOpr = 12;
pub const OPR_SHR: BinOpr = 11;
pub const OPR_SHL: BinOpr = 10;
pub const OPR_BXOR: BinOpr = 9;
pub const OPR_BOR: BinOpr = 8;
pub const OPR_BAND: BinOpr = 7;
pub const OPR_IDIV: BinOpr = 6;
pub const OPR_DIV: BinOpr = 5;
pub const OPR_POW: BinOpr = 4;
pub const OPR_MOD: BinOpr = 3;
pub const OPR_MUL: BinOpr = 2;
pub const OPR_SUB: BinOpr = 1;
pub const OPR_ADD: BinOpr = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub left: lu_byte,
    pub right: lu_byte,
}
pub const TK_CONCAT: RESERVED = 279;
pub const TK_DOTS: RESERVED = 280;
pub const TK_DBCOLON: RESERVED = 287;
pub const TK_NE: RESERVED = 284;
pub const TK_IDIV: RESERVED = 278;
pub const TK_SHR: RESERVED = 286;
pub const TK_GE: RESERVED = 282;
pub const TK_SHL: RESERVED = 285;
pub const TK_LE: RESERVED = 283;
pub const TK_EQ: RESERVED = 281;
pub const TK_OR: RESERVED = 271;
pub const TK_AND: RESERVED = 256;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConsControl {
    pub v: expdesc,
    pub t: *mut expdesc,
    pub nh: i32,
    pub na: i32,
    pub tostore: i32,
}
pub const TK_FUNCTION: RESERVED = 264;
pub const TK_END: RESERVED = 261;
pub const TK_FALSE: RESERVED = 262;
pub const TK_TRUE: RESERVED = 275;
pub const TK_NIL: RESERVED = 269;
pub type UnOpr = u32;
pub const OPR_NOUNOPR: UnOpr = 4;
pub const OPR_LEN: UnOpr = 3;
pub const OPR_NOT: UnOpr = 2;
pub const OPR_BNOT: UnOpr = 1;
pub const OPR_MINUS: UnOpr = 0;
pub const TK_NOT: RESERVED = 270;
pub const TK_GOTO: RESERVED = 265;
pub const TK_BREAK: RESERVED = 257;
pub const TK_UNTIL: RESERVED = 276;
pub const TK_ELSEIF: RESERVED = 260;
pub const TK_ELSE: RESERVED = 259;
pub const TK_RETURN: RESERVED = 273;
pub const TK_LOCAL: RESERVED = 268;
pub const TK_REPEAT: RESERVED = 272;
pub const TK_FOR: RESERVED = 263;
pub const TK_DO: RESERVED = 258;
pub const TK_IN: RESERVED = 267;
pub const TK_IF: RESERVED = 266;
pub const TK_THEN: RESERVED = 274;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LoadState {
    pub L: *mut lua_State,
    pub Z: *mut ZIO,
    pub name: *const std::ffi::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DumpState {
    pub L: *mut lua_State,
    pub writer: lua_Writer,
    pub data: *mut c_void,
    pub strip: i32,
    pub status: i32,
}
pub type off_t = __off64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct luaL_Buffer {
    pub b: *mut std::ffi::c_char,
    pub size: size_t,
    pub n: size_t,
    pub L: *mut lua_State,
    pub init: C2RustUnnamed_15,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub n: lua_Number,
    pub u: std::ffi::c_double,
    pub s: *mut c_void,
    pub i: lua_Integer,
    pub l: std::ffi::c_long,
    pub b: [std::ffi::c_char; 1024],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct luaL_Reg {
    pub name: *const std::ffi::c_char,
    pub func: lua_CFunction,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LoadF {
    pub n: i32,
    pub f: *mut FILE,
    pub buff: [std::ffi::c_char; 8192],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LoadS {
    pub s: *const std::ffi::c_char,
    pub size: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UBox {
    pub box_0: *mut c_void,
    pub bsize: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct luaL_Stream {
    pub f: *mut FILE,
    pub closef: lua_CFunction,
}
pub const _ISalnum: C2RustUnnamed_19 = 8;
pub const _ISdigit: C2RustUnnamed_19 = 2048;
pub type IdxT = u32;
pub type clock_t = __clock_t;
pub type LStream = luaL_Stream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RN {
    pub f: *mut FILE,
    pub c: i32,
    pub n: i32,
    pub buff: [std::ffi::c_char; 201],
}
pub const _ISxdigit: C2RustUnnamed_19 = 4096;
pub const _ISspace: C2RustUnnamed_19 = 8192;
pub const Knop: KOption = 10;
pub const Kpadding: KOption = 8;
pub const Kpaddalign: KOption = 9;
pub const Kzstr: KOption = 7;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Header {
    pub L: *mut lua_State,
    pub islittle: i32,
    pub maxalign: i32,
}
pub const Kstring: KOption = 6;
pub const Kchar: KOption = 5;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_16 {
    pub dummy: i32,
    pub little: std::ffi::c_char,
}
pub const Kdouble: KOption = 4;
pub const Knumber: KOption = 3;
pub const Kfloat: KOption = 2;
pub const Kint: KOption = 0;
pub type KOption = u32;
pub const Kuint: KOption = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cD {
    pub c: std::ffi::c_char,
    pub u: C2RustUnnamed_17,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_17 {
    pub n: lua_Number,
    pub u: std::ffi::c_double,
    pub s: *mut c_void,
    pub i: lua_Integer,
    pub l: std::ffi::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MatchState {
    pub src_init: *const std::ffi::c_char,
    pub src_end: *const std::ffi::c_char,
    pub p_end: *const std::ffi::c_char,
    pub L: *mut lua_State,
    pub matchdepth: i32,
    pub level: u8,
    pub capture: [C2RustUnnamed_18; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub init: *const std::ffi::c_char,
    pub len: ptrdiff_t,
}
pub const _ISlower: C2RustUnnamed_19 = 512;
pub const _ISupper: C2RustUnnamed_19 = 256;
pub const _ISpunct: C2RustUnnamed_19 = 4;
pub const _ISgraph: C2RustUnnamed_19 = 32768;
pub const _IScntrl: C2RustUnnamed_19 = 2;
pub const _ISalpha: C2RustUnnamed_19 = 1024;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GMatchState {
    pub src: *const std::ffi::c_char,
    pub p: *const std::ffi::c_char,
    pub lastmatch: *const std::ffi::c_char,
    pub ms: MatchState,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct str_Writer {
    pub init: i32,
    pub B: luaL_Buffer,
}
pub type utfint = u32;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RanState {
    pub s: [usize; 4],
}
pub type OpMode = u8;
pub type RESERVED = u32;
pub type C2RustUnnamed_19 = u32;
pub const _ISblank: C2RustUnnamed_19 = 1;
pub const _ISprint: C2RustUnnamed_19 = 16384;

#[unsafe(no_mangle)]
pub static mut luai_ctype_: [lu_byte; 257] = [
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0x8 as i32 as lu_byte,
    0x8 as i32 as lu_byte,
    0x8 as i32 as lu_byte,
    0x8 as i32 as lu_byte,
    0x8 as i32 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0xc as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x16 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x15 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x5 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0x4 as i32 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
    0 as lu_byte,
];

unsafe extern "C-unwind" fn error(mut S: *mut LoadState, mut why: *const std::ffi::c_char) -> ! {
    luaO_pushfstring(
        (*S).L,
        c"%s: bad binary format (%s)".as_ptr(),
        (*S).name,
        why,
    );
    luaD_throw((*S).L, 3 as i32);
}
unsafe extern "C-unwind" fn loadBlock(mut S: *mut LoadState, mut b: *mut c_void, mut size: size_t) {
    if luaZ_read((*S).Z, b, size) != 0 as size_t {
        error(S, c"truncated chunk".as_ptr());
    }
}
unsafe extern "C-unwind" fn loadByte(mut S: *mut LoadState) -> lu_byte {
    let fresh1 = (*(*S).Z).n;
    (*(*S).Z).n = ((*(*S).Z).n).wrapping_sub(1);
    let mut b: i32 = if fresh1 > 0 as size_t {
        let fresh2 = (*(*S).Z).p;
        (*(*S).Z).p = ((*(*S).Z).p).offset(1);
        *fresh2 as u8 as i32
    } else {
        luaZ_fill((*S).Z)
    };
    if b == -(1 as i32) {
        error(S, c"truncated chunk".as_ptr());
    }
    return b as lu_byte;
}
unsafe extern "C-unwind" fn loadUnsigned(mut S: *mut LoadState, mut limit: size_t) -> size_t {
    let mut x: size_t = 0 as size_t;
    let mut b: i32 = 0;
    limit >>= 7 as i32;
    loop {
        b = loadByte(S) as i32;
        if x >= limit {
            error(S, c"integer overflow".as_ptr());
        }
        x = x << 7 as i32 | (b & 0x7f as i32) as size_t;
        if !(b & 0x80 == 0) {
            break;
        }
    }
    return x;
}
unsafe extern "C-unwind" fn loadSize(mut S: *mut LoadState) -> size_t {
    return loadUnsigned(S, !(0 as size_t));
}
unsafe extern "C-unwind" fn loadInt(mut S: *mut LoadState) -> i32 {
    return loadUnsigned(S, 2147483647 as i32 as size_t) as i32;
}
unsafe extern "C-unwind" fn loadNumber(mut S: *mut LoadState) -> lua_Number {
    let mut x: lua_Number = 0.;
    loadBlock(
        S,
        &mut x as *mut lua_Number as *mut c_void,
        (1usize).wrapping_mul(::core::mem::size_of::<lua_Number>() as usize),
    );
    return x;
}
unsafe extern "C-unwind" fn loadInteger(mut S: *mut LoadState) -> lua_Integer {
    let mut x: lua_Integer = 0;
    loadBlock(
        S,
        &mut x as *mut lua_Integer as *mut c_void,
        (1usize).wrapping_mul(::core::mem::size_of::<lua_Integer>() as usize),
    );
    return x;
}
unsafe extern "C-unwind" fn loadStringN(mut S: *mut LoadState, mut p: *mut Proto) -> *mut TString {
    let mut L: *mut lua_State = (*S).L;
    let mut ts: *mut TString = 0 as *mut TString;
    let mut size: size_t = loadSize(S);
    if size == 0 as size_t {
        return 0 as *mut TString;
    } else {
        size = size.wrapping_sub(1);
        if size <= 40 as size_t {
            let mut buff: [std::ffi::c_char; 40] = [0; 40];
            loadBlock(
                S,
                buff.as_mut_ptr() as *mut c_void,
                size.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
            );
            ts = luaS_newlstr(L, buff.as_mut_ptr(), size);
        } else {
            ts = luaS_createlngstrobj(L, size);
            let mut io: *mut TValue = &mut (*(*L).top.p).val;
            let mut x_: *mut TString = ts;
            (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
            (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
            if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            luaD_inctop(L);
            loadBlock(
                S,
                ((*ts).contents).as_mut_ptr() as *mut c_void,
                size.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
            );
            (*L).top.p = ((*L).top.p).offset(-1);
            (*L).top.p;
        }
    }
    if (*p).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*ts).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            L,
            &mut (*(p as *mut GCUnion)).gc,
            &mut (*(ts as *mut GCUnion)).gc,
        );
    } else {
    };
    return ts;
}
unsafe extern "C-unwind" fn loadString(mut S: *mut LoadState, mut p: *mut Proto) -> *mut TString {
    let mut st: *mut TString = loadStringN(S, p);
    if st.is_null() {
        error(S, c"bad format for constant string".as_ptr());
    }
    return st;
}
unsafe extern "C-unwind" fn loadCode(mut S: *mut LoadState, mut f: *mut Proto) {
    let mut n: i32 = loadInt(S);
    if ::core::mem::size_of::<i32>() as usize >= ::core::mem::size_of::<size_t>() as usize
        && (n as size_t).wrapping_add(1 as i32 as size_t)
            > (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Instruction>() as usize)
    {
        luaM_toobig((*S).L);
    } else {
    };
    (*f).code = luaM_malloc_(
        (*S).L,
        (n as usize).wrapping_mul(::core::mem::size_of::<Instruction>() as usize),
        0,
    ) as *mut Instruction;
    (*f).sizecode = n;
    loadBlock(
        S,
        (*f).code as *mut c_void,
        (n as usize).wrapping_mul(::core::mem::size_of::<Instruction>() as usize),
    );
}
unsafe extern "C-unwind" fn loadConstants(mut S: *mut LoadState, mut f: *mut Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = loadInt(S);
    if ::core::mem::size_of::<i32>() as usize >= ::core::mem::size_of::<size_t>() as usize
        && (n as size_t).wrapping_add(1 as i32 as size_t)
            > (!(0 as size_t)).wrapping_div(::core::mem::size_of::<TValue>() as usize)
    {
        luaM_toobig((*S).L);
    } else {
    };
    (*f).k = luaM_malloc_(
        (*S).L,
        (n as usize).wrapping_mul(::core::mem::size_of::<TValue>() as usize),
        0,
    ) as *mut TValue;
    (*f).sizek = n;
    i = 0;
    while i < n {
        (*((*f).k).offset(i as isize)).tt_ = (0 | (0) << 4 as i32) as lu_byte;
        i += 1;
        i;
    }
    i = 0;
    while i < n {
        let mut o: *mut TValue = &mut *((*f).k).offset(i as isize) as *mut TValue;
        let mut t: i32 = loadByte(S) as i32;
        match t {
            0 => {
                (*o).tt_ = (0 | (0) << 4 as i32) as lu_byte;
            }
            1 => {
                (*o).tt_ = (1 as i32 | (0) << 4 as i32) as lu_byte;
            }
            17 => {
                (*o).tt_ = (1 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            }
            19 => {
                let mut io: *mut TValue = o;
                (*io).value_.n = loadNumber(S);
                (*io).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            }
            3 => {
                let mut io_0: *mut TValue = o;
                (*io_0).value_.i = loadInteger(S);
                (*io_0).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
            }
            4 | 20 => {
                let mut io_1: *mut TValue = o;
                let mut x_: *mut TString = loadString(S, f);
                (*io_1).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
                (*io_1).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
                if (*io_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                    || (*io_1).tt_ as i32 & 0x3f as i32 == (*(*io_1).value_.gc).tt as i32
                        && (((*S).L).is_null()
                            || (*(*io_1).value_.gc).marked as i32
                                & ((*(*(*S).L).l_G).currentwhite as i32
                                    ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                == 0)
                {
                } else {
                };
            }
            _ => {}
        }
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn loadProtos(mut S: *mut LoadState, mut f: *mut Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = loadInt(S);
    if ::core::mem::size_of::<i32>() as usize >= ::core::mem::size_of::<size_t>() as usize
        && (n as size_t).wrapping_add(1 as i32 as size_t)
            > (!(0 as size_t)).wrapping_div(::core::mem::size_of::<*mut Proto>() as usize)
    {
        luaM_toobig((*S).L);
    } else {
    };
    (*f).p = luaM_malloc_(
        (*S).L,
        (n as usize).wrapping_mul(::core::mem::size_of::<*mut Proto>() as usize),
        0,
    ) as *mut *mut Proto;
    (*f).sizep = n;
    i = 0;
    while i < n {
        let ref mut fresh3 = *((*f).p).offset(i as isize);
        *fresh3 = 0 as *mut Proto;
        i += 1;
        i;
    }
    i = 0;
    while i < n {
        let ref mut fresh4 = *((*f).p).offset(i as isize);
        *fresh4 = luaF_newproto((*S).L);
        if (*f).marked as i32 & (1 as i32) << 5 as i32 != 0
            && (**((*f).p).offset(i as isize)).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            luaC_barrier_(
                (*S).L,
                &mut (*(f as *mut GCUnion)).gc,
                &mut (*(*((*f).p).offset(i as isize) as *mut GCUnion)).gc,
            );
        } else {
        };
        loadFunction(S, *((*f).p).offset(i as isize), (*f).source);
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn loadUpvalues(mut S: *mut LoadState, mut f: *mut Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = 0;
    n = loadInt(S);
    if ::core::mem::size_of::<i32>() as usize >= ::core::mem::size_of::<size_t>() as usize
        && (n as size_t).wrapping_add(1 as i32 as size_t)
            > (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Upvaldesc>() as usize)
    {
        luaM_toobig((*S).L);
    } else {
    };
    (*f).upvalues = luaM_malloc_(
        (*S).L,
        (n as usize).wrapping_mul(::core::mem::size_of::<Upvaldesc>() as usize),
        0,
    ) as *mut Upvaldesc;
    (*f).sizeupvalues = n;
    i = 0;
    while i < n {
        let ref mut fresh5 = (*((*f).upvalues).offset(i as isize)).name;
        *fresh5 = 0 as *mut TString;
        i += 1;
        i;
    }
    i = 0;
    while i < n {
        (*((*f).upvalues).offset(i as isize)).instack = loadByte(S);
        (*((*f).upvalues).offset(i as isize)).idx = loadByte(S);
        (*((*f).upvalues).offset(i as isize)).kind = loadByte(S);
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn loadDebug(mut S: *mut LoadState, mut f: *mut Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = 0;
    n = loadInt(S);
    if ::core::mem::size_of::<i32>() as usize >= ::core::mem::size_of::<size_t>() as usize
        && (n as size_t).wrapping_add(1 as i32 as size_t)
            > (!(0 as size_t)).wrapping_div(::core::mem::size_of::<ls_byte>() as usize)
    {
        luaM_toobig((*S).L);
    } else {
    };
    (*f).lineinfo = luaM_malloc_(
        (*S).L,
        (n as usize).wrapping_mul(::core::mem::size_of::<ls_byte>() as usize),
        0,
    ) as *mut ls_byte;
    (*f).sizelineinfo = n;
    loadBlock(
        S,
        (*f).lineinfo as *mut c_void,
        (n as usize).wrapping_mul(::core::mem::size_of::<ls_byte>() as usize),
    );
    n = loadInt(S);
    if ::core::mem::size_of::<i32>() as usize >= ::core::mem::size_of::<size_t>() as usize
        && (n as size_t).wrapping_add(1 as i32 as size_t)
            > (!(0 as size_t)).wrapping_div(::core::mem::size_of::<AbsLineInfo>() as usize)
    {
        luaM_toobig((*S).L);
    } else {
    };
    (*f).abslineinfo = luaM_malloc_(
        (*S).L,
        (n as usize).wrapping_mul(::core::mem::size_of::<AbsLineInfo>() as usize),
        0,
    ) as *mut AbsLineInfo;
    (*f).sizeabslineinfo = n;
    i = 0;
    while i < n {
        (*((*f).abslineinfo).offset(i as isize)).pc = loadInt(S);
        (*((*f).abslineinfo).offset(i as isize)).line = loadInt(S);
        i += 1;
        i;
    }
    n = loadInt(S);
    if ::core::mem::size_of::<i32>() as usize >= ::core::mem::size_of::<size_t>() as usize
        && (n as size_t).wrapping_add(1 as i32 as size_t)
            > (!(0 as size_t)).wrapping_div(::core::mem::size_of::<LocVar>() as usize)
    {
        luaM_toobig((*S).L);
    } else {
    };
    (*f).locvars = luaM_malloc_(
        (*S).L,
        (n as usize).wrapping_mul(::core::mem::size_of::<LocVar>() as usize),
        0,
    ) as *mut LocVar;
    (*f).sizelocvars = n;
    i = 0;
    while i < n {
        let ref mut fresh6 = (*((*f).locvars).offset(i as isize)).varname;
        *fresh6 = 0 as *mut TString;
        i += 1;
        i;
    }
    i = 0;
    while i < n {
        let ref mut fresh7 = (*((*f).locvars).offset(i as isize)).varname;
        *fresh7 = loadStringN(S, f);
        (*((*f).locvars).offset(i as isize)).startpc = loadInt(S);
        (*((*f).locvars).offset(i as isize)).endpc = loadInt(S);
        i += 1;
        i;
    }
    n = loadInt(S);
    if n != 0 {
        n = (*f).sizeupvalues;
    }
    i = 0;
    while i < n {
        let ref mut fresh8 = (*((*f).upvalues).offset(i as isize)).name;
        *fresh8 = loadStringN(S, f);
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn loadFunction(
    mut S: *mut LoadState,
    mut f: *mut Proto,
    mut psource: *mut TString,
) {
    (*f).source = loadStringN(S, f);
    if ((*f).source).is_null() {
        (*f).source = psource;
    }
    (*f).linedefined = loadInt(S);
    (*f).lastlinedefined = loadInt(S);
    (*f).numparams = loadByte(S);
    (*f).is_vararg = loadByte(S);
    (*f).maxstacksize = loadByte(S);
    loadCode(S, f);
    loadConstants(S, f);
    loadUpvalues(S, f);
    loadProtos(S, f);
    loadDebug(S, f);
}
unsafe extern "C-unwind" fn checkliteral(
    mut S: *mut LoadState,
    mut s: *const std::ffi::c_char,
    mut msg: *const std::ffi::c_char,
) {
    let mut buff: [std::ffi::c_char; 12] = [0; 12];
    let mut len: size_t = strlen(s);
    loadBlock(
        S,
        buff.as_mut_ptr() as *mut c_void,
        len.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
    );
    if memcmp(s as *const c_void, buff.as_mut_ptr() as *const c_void, len) != 0 {
        error(S, msg);
    }
}
unsafe extern "C-unwind" fn fchecksize(
    mut S: *mut LoadState,
    mut size: size_t,
    mut tname: *const std::ffi::c_char,
) {
    if loadByte(S) as size_t != size {
        error(
            S,
            luaO_pushfstring((*S).L, c"%s size mismatch".as_ptr(), tname),
        );
    }
}
unsafe extern "C-unwind" fn checkHeader(mut S: *mut LoadState) {
    checkliteral(
        S,
        &*(c"\x1BLua".as_ptr()).offset(1),
        c"not a binary chunk".as_ptr(),
    );
    if loadByte(S) as i32 != 504 as i32 / 100 * 16 as i32 + 504 as i32 % 100 {
        error(S, c"version mismatch".as_ptr());
    }
    if loadByte(S) as i32 != 0 {
        error(S, c"format mismatch".as_ptr());
    }
    checkliteral(
        S,
        c"\x19\x93\r\n\x1A\n".as_ptr(),
        c"corrupted chunk".as_ptr(),
    );
    fchecksize(
        S,
        ::core::mem::size_of::<Instruction>() as usize,
        c"Instruction".as_ptr(),
    );
    fchecksize(
        S,
        ::core::mem::size_of::<lua_Integer>() as usize,
        c"lua_Integer".as_ptr(),
    );
    fchecksize(
        S,
        ::core::mem::size_of::<lua_Number>() as usize,
        c"lua_Number".as_ptr(),
    );
    if loadInteger(S) != 0x5678 as i32 as lua_Integer {
        error(S, c"integer format mismatch".as_ptr());
    }
    if loadNumber(S) != 370.5f64 {
        error(S, c"float format mismatch".as_ptr());
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaU_undump(
    mut L: *mut lua_State,
    mut Z: *mut ZIO,
    mut name: *const std::ffi::c_char,
) -> *mut LClosure {
    let mut S: LoadState = LoadState {
        L: 0 as *mut lua_State,
        Z: 0 as *mut ZIO,
        name: 0 as *const std::ffi::c_char,
    };
    let mut cl: *mut LClosure = 0 as *mut LClosure;
    if *name as i32 == '@' as i32 || *name as i32 == '=' as i32 {
        S.name = name.offset(1);
    } else if *name as i32
        == (*::core::mem::transmute::<&[u8; 5], &[std::ffi::c_char; 5]>(b"\x1BLua\0"))[0 as usize]
            as i32
    {
        S.name = c"binary string".as_ptr();
    } else {
        S.name = name;
    }
    S.L = L;
    S.Z = Z;
    checkHeader(&mut S);
    cl = luaF_newLclosure(L, loadByte(&mut S) as i32);
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    let mut x_: *mut LClosure = cl;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (6 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    luaD_inctop(L);
    (*cl).p = luaF_newproto(L);
    if (*cl).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*(*cl).p).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            L,
            &mut (*(cl as *mut GCUnion)).gc,
            &mut (*((*cl).p as *mut GCUnion)).gc,
        );
    } else {
    };
    loadFunction(&mut S, (*cl).p, 0 as *mut TString);
    return cl;
}
unsafe extern "C-unwind" fn dumpBlock(
    mut D: *mut DumpState,
    mut b: *const c_void,
    mut size: size_t,
) {
    if (*D).status == 0 && size > 0 as size_t {
        (*D).status = (Some(((*D).writer).expect("non-null function pointer")))
            .expect("non-null function pointer")((*D).L, b, size, (*D).data);
    }
}
unsafe extern "C-unwind" fn dumpByte(mut D: *mut DumpState, mut y: i32) {
    let mut x: lu_byte = y as lu_byte;
    dumpBlock(
        D,
        &mut x as *mut lu_byte as *const c_void,
        (1usize).wrapping_mul(::core::mem::size_of::<lu_byte>() as usize),
    );
}
unsafe extern "C-unwind" fn dumpSize(mut D: *mut DumpState, mut x: size_t) {
    let mut buff: [lu_byte; 10] = [0; 10];
    let mut n: i32 = 0;
    loop {
        n += 1;
        buff[(::core::mem::size_of::<size_t>() as usize)
            .wrapping_mul(8)
            .wrapping_add(6)
            .wrapping_div(7)
            .wrapping_sub(n as usize) as usize] = (x & 0x7f as i32 as size_t) as lu_byte;
        x >>= 7 as i32;
        if !(x != 0 as size_t) {
            break;
        }
    }
    buff[(::core::mem::size_of::<size_t>() as usize)
        .wrapping_mul(8)
        .wrapping_add(6)
        .wrapping_div(7)
        .wrapping_sub(1) as usize] = (buff[(::core::mem::size_of::<size_t>() as usize)
        .wrapping_mul(8)
        .wrapping_add(6)
        .wrapping_div(7)
        .wrapping_sub(1) as usize] as i32
        | 0x80) as lu_byte;
    dumpBlock(
        D,
        buff.as_mut_ptr()
            .offset(
                (::core::mem::size_of::<size_t>() as usize)
                    .wrapping_mul(8)
                    .wrapping_add(6)
                    .wrapping_div(7) as isize,
            )
            .offset(-(n as isize)) as *const c_void,
        (n as usize).wrapping_mul(::core::mem::size_of::<lu_byte>() as usize),
    );
}
unsafe extern "C-unwind" fn dumpInt(mut D: *mut DumpState, mut x: i32) {
    dumpSize(D, x as size_t);
}
unsafe extern "C-unwind" fn dumpNumber(mut D: *mut DumpState, mut x: lua_Number) {
    dumpBlock(
        D,
        &mut x as *mut lua_Number as *const c_void,
        (1usize).wrapping_mul(::core::mem::size_of::<lua_Number>() as usize),
    );
}
unsafe extern "C-unwind" fn dumpInteger(mut D: *mut DumpState, mut x: lua_Integer) {
    dumpBlock(
        D,
        &mut x as *mut lua_Integer as *const c_void,
        (1usize).wrapping_mul(::core::mem::size_of::<lua_Integer>() as usize),
    );
}
unsafe extern "C-unwind" fn dumpString(mut D: *mut DumpState, mut s: *const TString) {
    if s.is_null() {
        dumpSize(D, 0 as size_t);
    } else {
        let mut size: size_t = if (*s).shrlen as i32 != 0xff as i32 {
            (*s).shrlen as size_t
        } else {
            (*s).u.lnglen
        };
        let mut str: *const std::ffi::c_char = ((*s).contents).as_ptr();
        dumpSize(D, size.wrapping_add(1 as i32 as size_t));
        dumpBlock(
            D,
            str as *const c_void,
            size.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
        );
    };
}
unsafe extern "C-unwind" fn dumpCode(mut D: *mut DumpState, mut f: *const Proto) {
    dumpInt(D, (*f).sizecode);
    dumpBlock(
        D,
        (*f).code as *const c_void,
        ((*f).sizecode as usize).wrapping_mul(::core::mem::size_of::<Instruction>() as usize),
    );
}
unsafe extern "C-unwind" fn dumpConstants(mut D: *mut DumpState, mut f: *const Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = (*f).sizek;
    dumpInt(D, n);
    i = 0;
    while i < n {
        let mut o: *const TValue = &mut *((*f).k).offset(i as isize) as *mut TValue;
        let mut tt: i32 = (*o).tt_ as i32 & 0x3f as i32;
        dumpByte(D, tt);
        match tt {
            19 => {
                dumpNumber(D, (*o).value_.n);
            }
            3 => {
                dumpInteger(D, (*o).value_.i);
            }
            4 | 20 => {
                dumpString(D, &mut (*((*o).value_.gc as *mut GCUnion)).ts);
            }
            _ => {}
        }
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn dumpProtos(mut D: *mut DumpState, mut f: *const Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = (*f).sizep;
    dumpInt(D, n);
    i = 0;
    while i < n {
        dumpFunction(D, *((*f).p).offset(i as isize), (*f).source);
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn dumpUpvalues(mut D: *mut DumpState, mut f: *const Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = (*f).sizeupvalues;
    dumpInt(D, n);
    i = 0;
    while i < n {
        dumpByte(D, (*((*f).upvalues).offset(i as isize)).instack as i32);
        dumpByte(D, (*((*f).upvalues).offset(i as isize)).idx as i32);
        dumpByte(D, (*((*f).upvalues).offset(i as isize)).kind as i32);
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn dumpDebug(mut D: *mut DumpState, mut f: *const Proto) {
    let mut i: i32 = 0;
    let mut n: i32 = 0;
    n = if (*D).strip != 0 {
        0
    } else {
        (*f).sizelineinfo
    };
    dumpInt(D, n);
    dumpBlock(
        D,
        (*f).lineinfo as *const c_void,
        (n as usize).wrapping_mul(::core::mem::size_of::<ls_byte>() as usize),
    );
    n = if (*D).strip != 0 {
        0
    } else {
        (*f).sizeabslineinfo
    };
    dumpInt(D, n);
    i = 0;
    while i < n {
        dumpInt(D, (*((*f).abslineinfo).offset(i as isize)).pc);
        dumpInt(D, (*((*f).abslineinfo).offset(i as isize)).line);
        i += 1;
        i;
    }
    n = if (*D).strip != 0 { 0 } else { (*f).sizelocvars };
    dumpInt(D, n);
    i = 0;
    while i < n {
        dumpString(D, (*((*f).locvars).offset(i as isize)).varname);
        dumpInt(D, (*((*f).locvars).offset(i as isize)).startpc);
        dumpInt(D, (*((*f).locvars).offset(i as isize)).endpc);
        i += 1;
        i;
    }
    n = if (*D).strip != 0 {
        0
    } else {
        (*f).sizeupvalues
    };
    dumpInt(D, n);
    i = 0;
    while i < n {
        dumpString(D, (*((*f).upvalues).offset(i as isize)).name);
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn dumpFunction(
    mut D: *mut DumpState,
    mut f: *const Proto,
    mut psource: *mut TString,
) {
    if (*D).strip != 0 || (*f).source == psource {
        dumpString(D, 0 as *const TString);
    } else {
        dumpString(D, (*f).source);
    }
    dumpInt(D, (*f).linedefined);
    dumpInt(D, (*f).lastlinedefined);
    dumpByte(D, (*f).numparams as i32);
    dumpByte(D, (*f).is_vararg as i32);
    dumpByte(D, (*f).maxstacksize as i32);
    dumpCode(D, f);
    dumpConstants(D, f);
    dumpUpvalues(D, f);
    dumpProtos(D, f);
    dumpDebug(D, f);
}
unsafe extern "C-unwind" fn dumpHeader(mut D: *mut DumpState) {
    dumpBlock(
        D,
        c"\x1BLua".as_ptr() as *const c_void,
        (::core::mem::size_of::<[std::ffi::c_char; 5]>() as usize)
            .wrapping_sub(::core::mem::size_of::<std::ffi::c_char>() as usize),
    );
    dumpByte(D, 504 as i32 / 100 * 16 as i32 + 504 as i32 % 100);
    dumpByte(D, 0);
    dumpBlock(
        D,
        c"\x19\x93\r\n\x1A\n".as_ptr() as *const c_void,
        (::core::mem::size_of::<[std::ffi::c_char; 7]>() as usize)
            .wrapping_sub(::core::mem::size_of::<std::ffi::c_char>() as usize),
    );
    dumpByte(D, ::core::mem::size_of::<Instruction>() as usize as i32);
    dumpByte(D, ::core::mem::size_of::<lua_Integer>() as usize as i32);
    dumpByte(D, ::core::mem::size_of::<lua_Number>() as usize as i32);
    dumpInteger(D, 0x5678 as i32 as lua_Integer);
    dumpNumber(D, 370.5f64);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaU_dump(
    mut L: *mut lua_State,
    mut f: *const Proto,
    mut w: lua_Writer,
    mut data: *mut c_void,
    mut strip: i32,
) -> i32 {
    let mut D: DumpState = DumpState {
        L: 0 as *mut lua_State,
        writer: None,
        data: 0 as *mut c_void,
        strip: 0,
        status: 0,
    };
    D.L = L;
    D.writer = w;
    D.data = data;
    D.strip = strip;
    D.status = 0;
    dumpHeader(&mut D);
    dumpByte(&mut D, (*f).sizeupvalues);
    dumpFunction(&mut D, f, 0 as *mut TString);
    return D.status;
}
unsafe extern "C-unwind" fn luai_makeseed(mut L: *mut lua_State) -> u32 {
    let mut buff: [std::ffi::c_char; 24] = [0; 24];
    let mut h: u32 = time(0 as *mut time_t) as u32;
    let mut p: i32 = 0;
    let mut t: size_t = L as size_t;
    memcpy(
        buff.as_mut_ptr().offset(p as isize) as *mut c_void,
        &mut t as *mut size_t as *const c_void,
        ::core::mem::size_of::<size_t>() as usize,
    );
    p = (p as usize).wrapping_add(::core::mem::size_of::<size_t>() as usize) as i32 as i32;
    let mut t_0: size_t = &mut h as *mut u32 as size_t;
    memcpy(
        buff.as_mut_ptr().offset(p as isize) as *mut c_void,
        &mut t_0 as *mut size_t as *const c_void,
        ::core::mem::size_of::<size_t>() as usize,
    );
    p = (p as usize).wrapping_add(::core::mem::size_of::<size_t>() as usize) as i32 as i32;
    let mut t_1: size_t = ::core::mem::transmute::<
        Option<unsafe extern "C-unwind" fn(lua_Alloc, *mut c_void) -> *mut lua_State>,
        size_t,
    >(Some(
        lua_newstate as unsafe extern "C-unwind" fn(lua_Alloc, *mut c_void) -> *mut lua_State,
    ));
    memcpy(
        buff.as_mut_ptr().offset(p as isize) as *mut c_void,
        &mut t_1 as *mut size_t as *const c_void,
        ::core::mem::size_of::<size_t>() as usize,
    );
    p = (p as usize).wrapping_add(::core::mem::size_of::<size_t>() as usize) as i32 as i32;
    return luaS_hash(buff.as_mut_ptr(), p as size_t, h);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_setdebt(mut g: *mut global_State, mut debt: l_mem) {
    let mut tb: l_mem = ((*g).totalbytes + (*g).GCdebt) as lu_mem as l_mem;
    if debt < tb - (!(0 as lu_mem) >> 1 as i32) as l_mem {
        debt = tb - (!(0 as lu_mem) >> 1 as i32) as l_mem;
    }
    (*g).totalbytes = tb - debt;
    (*g).GCdebt = debt;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setcstacklimit(mut L: *mut lua_State, mut limit: u32) -> i32 {
    return 200;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_extendCI(mut L: *mut lua_State) -> *mut CallInfo {
    let mut ci: *mut CallInfo = 0 as *mut CallInfo;
    ci = luaM_malloc_(L, ::core::mem::size_of::<CallInfo>() as usize, 0) as *mut CallInfo;
    (*(*L).ci).next = ci;
    (*ci).previous = (*L).ci;
    (*ci).next = 0 as *mut CallInfo;
    ::core::ptr::write_volatile(&mut (*ci).u.l.trap as *mut sig_atomic_t, 0);
    (*L).nci = ((*L).nci).wrapping_add(1);
    (*L).nci;
    return ci;
}
unsafe extern "C-unwind" fn freeCI(mut L: *mut lua_State) {
    let mut ci: *mut CallInfo = (*L).ci;
    let mut next: *mut CallInfo = (*ci).next;
    (*ci).next = 0 as *mut CallInfo;
    loop {
        ci = next;
        if ci.is_null() {
            break;
        }
        next = (*ci).next;
        luaM_free_(
            L,
            ci as *mut c_void,
            ::core::mem::size_of::<CallInfo>() as usize,
        );
        (*L).nci = ((*L).nci).wrapping_sub(1);
        (*L).nci;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_shrinkCI(mut L: *mut lua_State) {
    let mut ci: *mut CallInfo = (*(*L).ci).next;
    let mut next: *mut CallInfo = 0 as *mut CallInfo;
    if ci.is_null() {
        return;
    }
    loop {
        next = (*ci).next;
        if next.is_null() {
            break;
        }
        let mut next2: *mut CallInfo = (*next).next;
        (*ci).next = next2;
        (*L).nci = ((*L).nci).wrapping_sub(1);
        (*L).nci;
        luaM_free_(
            L,
            next as *mut c_void,
            ::core::mem::size_of::<CallInfo>() as usize,
        );
        if next2.is_null() {
            break;
        }
        (*next2).previous = ci;
        ci = next2;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_checkcstack(mut L: *mut lua_State) {
    if (*L).nCcalls & 0xffff as i32 as l_uint32 == 200 as l_uint32 {
        luaG_runerror(L, c"C stack overflow".as_ptr());
    } else if (*L).nCcalls & 0xffff as i32 as l_uint32 >= (200 / 10 * 11 as i32) as l_uint32 {
        luaD_throw(L, 5 as i32);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_incCstack(mut L: *mut lua_State) {
    (*L).nCcalls = ((*L).nCcalls).wrapping_add(1);
    (*L).nCcalls;
    if (((*L).nCcalls & 0xffff as i32 as l_uint32 >= 200 as l_uint32) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
    {
        luaE_checkcstack(L);
    }
}
unsafe extern "C-unwind" fn stack_init(mut L1: *mut lua_State, mut L: *mut lua_State) {
    let mut i: i32 = 0;
    let mut ci: *mut CallInfo = 0 as *mut CallInfo;
    (*L1).stack.p = luaM_malloc_(
        L,
        ((2 as i32 * 20 + 5 as i32) as usize)
            .wrapping_mul(::core::mem::size_of::<StackValue>() as usize),
        0,
    ) as *mut StackValue;
    (*L1).tbclist.p = (*L1).stack.p;
    i = 0;
    while i < 2 as i32 * 20 + 5 as i32 {
        (*((*L1).stack.p).offset(i as isize)).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
        i += 1;
        i;
    }
    (*L1).top.p = (*L1).stack.p;
    (*L1).stack_last.p = ((*L1).stack.p).offset((2 as i32 * 20) as isize);
    ci = &mut (*L1).base_ci;
    (*ci).previous = 0 as *mut CallInfo;
    (*ci).next = (*ci).previous;
    (*ci).callstatus = ((1 as i32) << 1 as i32) as u16;
    (*ci).func.p = (*L1).top.p;
    (*ci).u.c.k = None;
    (*ci).nresults = 0 as std::ffi::c_short;
    (*(*L1).top.p).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
    (*L1).top.p = ((*L1).top.p).offset(1);
    (*L1).top.p;
    (*ci).top.p = ((*L1).top.p).offset(20 as isize);
    (*L1).ci = ci;
}
unsafe extern "C-unwind" fn freestack(mut L: *mut lua_State) {
    if ((*L).stack.p).is_null() {
        return;
    }
    (*L).ci = &mut (*L).base_ci;
    freeCI(L);
    luaM_free_(
        L,
        (*L).stack.p as *mut c_void,
        ((((*L).stack_last.p).offset_from((*L).stack.p) as std::ffi::c_long as i32 + 5 as i32)
            as usize)
            .wrapping_mul(::core::mem::size_of::<StackValue>() as usize),
    );
}
unsafe extern "C-unwind" fn init_registry(mut L: *mut lua_State, mut g: *mut global_State) {
    let mut registry: *mut Table = luaH_new(L);
    let mut io: *mut TValue = &mut (*g).l_registry;
    let mut x_: *mut Table = registry;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    luaH_resize(L, registry, 2, 0 as u32);
    let mut io_0: *mut TValue =
        &mut *((*registry).array).offset((1 as i32 - 1 as i32) as isize) as *mut TValue;
    let mut x__0: *mut lua_State = L;
    (*io_0).value_.gc = &mut (*(x__0 as *mut GCUnion)).gc;
    (*io_0).tt_ = (8 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io_0).tt_ as i32 & 0x3f as i32 == (*(*io_0).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io_0).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io_1: *mut TValue =
        &mut *((*registry).array).offset((2 as i32 - 1 as i32) as isize) as *mut TValue;
    let mut x__1: *mut Table = luaH_new(L);
    (*io_1).value_.gc = &mut (*(x__1 as *mut GCUnion)).gc;
    (*io_1).tt_ = (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io_1).tt_ as i32 & 0x3f as i32 == (*(*io_1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io_1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
}
unsafe extern "C-unwind" fn f_luaopen(mut L: *mut lua_State, mut ud: *mut c_void) {
    let mut g: *mut global_State = (*L).l_G;
    stack_init(L, L);
    init_registry(L, g);
    luaS_init(L);
    luaT_init(L);
    luaX_init(L);
    (*g).gcstp = 0 as lu_byte;
    (*g).nilvalue.tt_ = (0 | (0) << 4 as i32) as lu_byte;
}
unsafe extern "C-unwind" fn preinit_thread(mut L: *mut lua_State, mut g: *mut global_State) {
    (*L).l_G = g;
    (*L).stack.p = 0 as StkId;
    (*L).ci = 0 as *mut CallInfo;
    (*L).nci = 0 as u16;
    (*L).twups = L;
    (*L).nCcalls = 0 as l_uint32;
    (*L).errorJmp = 0 as *mut lua_longjmp;
    ::core::ptr::write_volatile(&mut (*L).hook as *mut lua_Hook, None);
    ::core::ptr::write_volatile(&mut (*L).hookmask as *mut sig_atomic_t, 0);
    (*L).basehookcount = 0;
    (*L).allowhook = 1 as i32 as lu_byte;
    (*L).hookcount = (*L).basehookcount;
    (*L).openupval = 0 as *mut UpVal;
    (*L).status = 0 as lu_byte;
    (*L).errfunc = 0 as ptrdiff_t;
    (*L).oldpc = 0;
}
unsafe extern "C-unwind" fn close_state(mut L: *mut lua_State) {
    let mut g: *mut global_State = (*L).l_G;
    if !((*g).nilvalue.tt_ as i32 & 0xf as i32 == 0) {
        luaC_freeallobjects(L);
    } else {
        (*L).ci = &mut (*L).base_ci;
        luaD_closeprotected(L, 1 as i32 as ptrdiff_t, 0);
        luaC_freeallobjects(L);
    }
    luaM_free_(
        L,
        (*(*L).l_G).strt.hash as *mut c_void,
        ((*(*L).l_G).strt.size as usize)
            .wrapping_mul(::core::mem::size_of::<*mut TString>() as usize),
    );
    freestack(L);
    (Some(((*g).frealloc).expect("non-null function pointer"))).expect("non-null function pointer")(
        (*g).ud,
        (L as *mut lu_byte).offset(-(8 as usize as isize)) as *mut LX as *mut c_void,
        ::core::mem::size_of::<LG>() as usize,
        0 as size_t,
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_newthread(mut L: *mut lua_State) -> *mut lua_State {
    let mut g: *mut global_State = (*L).l_G;
    let mut o: *mut GCObject = 0 as *mut GCObject;
    let mut L1: *mut lua_State = 0 as *mut lua_State;
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
    o = luaC_newobjdt(
        L,
        8 as i32,
        ::core::mem::size_of::<LX>() as usize,
        8 as usize,
    );
    L1 = &mut (*(o as *mut GCUnion)).th;
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    let mut x_: *mut lua_State = L1;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (8 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    preinit_thread(L1, g);
    ::core::ptr::write_volatile(&mut (*L1).hookmask as *mut sig_atomic_t, (*L).hookmask);
    (*L1).basehookcount = (*L).basehookcount;
    ::core::ptr::write_volatile(&mut (*L1).hook as *mut lua_Hook, (*L).hook);
    (*L1).hookcount = (*L1).basehookcount;
    memcpy(
        (L1 as *mut std::ffi::c_char)
            .offset(-(::core::mem::size_of::<*mut c_void>() as usize as isize))
            as *mut c_void,
        ((*g).mainthread as *mut std::ffi::c_char)
            .offset(-(::core::mem::size_of::<*mut c_void>() as usize as isize))
            as *mut c_void,
        ::core::mem::size_of::<*mut c_void>() as usize,
    );
    stack_init(L1, L);
    return L1;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_freethread(mut L: *mut lua_State, mut L1: *mut lua_State) {
    let mut l: *mut LX = (L1 as *mut lu_byte).offset(-(8 as usize as isize)) as *mut LX;
    luaF_closeupval(L1, (*L1).stack.p);
    freestack(L1);
    luaM_free_(L, l as *mut c_void, ::core::mem::size_of::<LX>() as usize);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_resetthread(mut L: *mut lua_State, mut status: i32) -> i32 {
    (*L).ci = &mut (*L).base_ci;
    let mut ci: *mut CallInfo = (*L).ci;
    (*(*L).stack.p).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
    (*ci).func.p = (*L).stack.p;
    (*ci).callstatus = ((1 as i32) << 1 as i32) as u16;
    if status == 1 as i32 {
        status = 0;
    }
    (*L).status = 0 as lu_byte;
    status = luaD_closeprotected(L, 1 as i32 as ptrdiff_t, status);
    if status != 0 {
        luaD_seterrorobj(L, status, ((*L).stack.p).offset(1));
    } else {
        (*L).top.p = ((*L).stack.p).offset(1);
    }
    (*ci).top.p = ((*L).top.p).offset(20 as isize);
    luaD_reallocstack(
        L,
        ((*ci).top.p).offset_from((*L).stack.p) as std::ffi::c_long as i32,
        0,
    );
    return status;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_closethread(
    mut L: *mut lua_State,
    mut from: *mut lua_State,
) -> i32 {
    let mut status: i32 = 0;
    (*L).nCcalls = if !from.is_null() {
        (*from).nCcalls & 0xffff as i32 as l_uint32
    } else {
        0 as l_uint32
    };
    status = luaE_resetthread(L, (*L).status as i32);
    return status;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_resetthread(mut L: *mut lua_State) -> i32 {
    return lua_closethread(L, 0 as *mut lua_State);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_newstate(
    mut f: lua_Alloc,
    mut ud: *mut c_void,
) -> *mut lua_State {
    let mut i: i32 = 0;
    let mut L: *mut lua_State = 0 as *mut lua_State;
    let mut g: *mut global_State = 0 as *mut global_State;
    let mut l: *mut LG = (Some(f.expect("non-null function pointer")))
        .expect("non-null function pointer")(
        ud,
        0 as *mut c_void,
        8 as i32 as size_t,
        ::core::mem::size_of::<LG>() as usize,
    ) as *mut LG;
    if l.is_null() {
        return 0 as *mut lua_State;
    }
    L = &mut (*l).l.l;
    g = &mut (*l).g;
    (*L).tt = (8 as i32 | (0) << 4 as i32) as lu_byte;
    (*g).currentwhite = ((1 as i32) << 3 as i32) as lu_byte;
    (*L).marked =
        ((*g).currentwhite as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte;
    preinit_thread(L, g);
    (*g).allgc = &mut (*(L as *mut GCUnion)).gc;
    (*L).next = 0 as *mut GCObject;
    (*L).nCcalls = ((*L).nCcalls).wrapping_add(0x10000 as l_uint32);
    (*g).frealloc = f;
    (*g).ud = ud;
    (*g).warnf = None;
    (*g).ud_warn = 0 as *mut c_void;
    (*g).mainthread = L;
    (*g).seed = luai_makeseed(L);
    (*g).gcstp = 2 as i32 as lu_byte;
    (*g).strt.nuse = 0;
    (*g).strt.size = (*g).strt.nuse;
    (*g).strt.hash = 0 as *mut *mut TString;
    (*g).l_registry.tt_ = (0 | (0) << 4 as i32) as lu_byte;
    (*g).panic = None;
    (*g).gcstate = 8 as i32 as lu_byte;
    (*g).gckind = 0 as lu_byte;
    (*g).gcstopem = 0 as lu_byte;
    (*g).gcemergency = 0 as lu_byte;
    (*g).fixedgc = 0 as *mut GCObject;
    (*g).tobefnz = (*g).fixedgc;
    (*g).finobj = (*g).tobefnz;
    (*g).reallyold = 0 as *mut GCObject;
    (*g).old1 = (*g).reallyold;
    (*g).survival = (*g).old1;
    (*g).firstold1 = (*g).survival;
    (*g).finobjrold = 0 as *mut GCObject;
    (*g).finobjold1 = (*g).finobjrold;
    (*g).finobjsur = (*g).finobjold1;
    (*g).sweepgc = 0 as *mut *mut GCObject;
    (*g).grayagain = 0 as *mut GCObject;
    (*g).gray = (*g).grayagain;
    (*g).allweak = 0 as *mut GCObject;
    (*g).ephemeron = (*g).allweak;
    (*g).weak = (*g).ephemeron;
    (*g).twups = 0 as *mut lua_State;
    (*g).totalbytes = ::core::mem::size_of::<LG>() as usize as l_mem;
    (*g).GCdebt = 0 as l_mem;
    (*g).lastatomic = 0 as lu_mem;
    let mut io: *mut TValue = &mut (*g).nilvalue;
    (*io).value_.i = 0 as lua_Integer;
    (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
    (*g).gcpause = (200 / 4 as i32) as lu_byte;
    (*g).gcstepmul = (100 / 4 as i32) as lu_byte;
    (*g).gcstepsize = 13 as i32 as lu_byte;
    (*g).genmajormul = (100 / 4 as i32) as lu_byte;
    (*g).genminormul = 20 as lu_byte;
    i = 0;
    while i < 9 as i32 {
        (*g).mt[i as usize] = 0 as *mut Table;
        i += 1;
        i;
    }
    if luaD_rawrunprotected(
        L,
        Some(f_luaopen as unsafe extern "C-unwind" fn(*mut lua_State, *mut c_void) -> ()),
        0 as *mut c_void,
    ) != 0
    {
        close_state(L);
        L = 0 as *mut lua_State;
    }
    return L;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_close(mut L: *mut lua_State) {
    L = (*(*L).l_G).mainthread;
    close_state(L);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_warning(
    mut L: *mut lua_State,
    mut msg: *const std::ffi::c_char,
    mut tocont: i32,
) {
    let mut wf: lua_WarnFunction = (*(*L).l_G).warnf;
    if wf.is_some() {
        wf.expect("non-null function pointer")((*(*L).l_G).ud_warn, msg, tocont);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaE_warnerror(
    mut L: *mut lua_State,
    mut where_0: *const std::ffi::c_char,
) {
    let mut errobj: *mut TValue = &mut (*((*L).top.p).offset(-(1))).val;
    let mut msg: *const std::ffi::c_char = if (*errobj).tt_ as i32 & 0xf as i32 == 4 as i32 {
        ((*(&mut (*((*errobj).value_.gc as *mut GCUnion)).ts as *mut TString)).contents)
            .as_mut_ptr() as *const std::ffi::c_char
    } else {
        c"error object is not a string".as_ptr()
    };
    luaE_warning(L, c"error in ".as_ptr(), 1 as i32);
    luaE_warning(L, where_0, 1 as i32);
    luaE_warning(L, c" (".as_ptr(), 1 as i32);
    luaE_warning(L, msg, 1 as i32);
    luaE_warning(L, c")".as_ptr(), 0);
}
unsafe extern "C-unwind" fn getgclist(mut o: *mut GCObject) -> *mut *mut GCObject {
    match (*o).tt {
        LUA_VTABLE => return &mut (*&mut (*(o as *mut GCUnion)).h).gclist,
        LUA_VLCL => return &mut (*&mut (*(o as *mut GCUnion)).cl.l).gclist,
        LUA_VCCL => return &mut (*&mut (*(o as *mut GCUnion)).cl.c).gclist,
        LUA_VTHREAD => return &mut (*&mut (*(o as *mut GCUnion)).th).gclist,
        LUA_VPROTO => return &mut (*&mut (*(o as *mut GCUnion)).p).gclist,
        LUA_VUSERDATA => {
            let mut u: *mut Udata = &mut (*(o as *mut GCUnion)).u;
            return &mut (*u).gclist;
        }
        _ => return ptr::null_mut(),
    };
}
unsafe extern "C-unwind" fn linkgclist_(
    mut o: *mut GCObject,
    mut pnext: *mut *mut GCObject,
    mut list: *mut *mut GCObject,
) {
    *pnext = *list;
    *list = o;
    (*o).marked = ((*o).marked as i32
        & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte
            as i32) as lu_byte;
}
unsafe extern "C-unwind" fn clearkey(mut n: *mut Node) {
    if (*n).u.key_tt as i32 & (1 as i32) << 6 as i32 != 0 {
        (*n).u.key_tt = (9 as i32 + 2 as i32) as lu_byte;
    }
}
unsafe extern "C-unwind" fn iscleared(mut g: *mut global_State, mut o: *const GCObject) -> i32 {
    if o.is_null() {
        return 0;
    } else if (*o).tt as i32 & 0xf as i32 == 4 as i32 {
        if (*o).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
            reallymarkobject(g, &mut (*(o as *mut GCUnion)).gc);
        }
        return 0;
    } else {
        return (*o).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_barrier_(
    mut L: *mut lua_State,
    mut o: *mut GCObject,
    mut v: *mut GCObject,
) {
    let mut g: *mut global_State = (*L).l_G;
    if (*g).gcstate as i32 <= 2 as i32 {
        reallymarkobject(g, v);
        if (*o).marked as i32 & 7 as i32 > 1 as i32 {
            (*v).marked = ((*v).marked as i32 & !(7 as i32) | 2 as i32) as lu_byte;
        }
    } else if (*g).gckind as i32 == 0 {
        (*o).marked = ((*o).marked as i32
            & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
            | ((*g).currentwhite as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                as lu_byte as i32) as lu_byte;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_barrierback_(mut L: *mut lua_State, mut o: *mut GCObject) {
    let mut g: *mut global_State = (*L).l_G;
    if (*o).marked as i32 & 7 as i32 == 6 as i32 {
        (*o).marked = ((*o).marked as i32
            & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                as lu_byte as i32) as lu_byte;
    } else {
        linkgclist_(
            &mut (*(o as *mut GCUnion)).gc,
            getgclist(o),
            &mut (*g).grayagain,
        );
    }
    if (*o).marked as i32 & 7 as i32 > 1 as i32 {
        (*o).marked = ((*o).marked as i32 & !(7 as i32) | 5 as i32) as lu_byte;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_fix(mut L: *mut lua_State, mut o: *mut GCObject) {
    let mut g: *mut global_State = (*L).l_G;
    (*o).marked = ((*o).marked as i32
        & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte
            as i32) as lu_byte;
    (*o).marked = ((*o).marked as i32 & !(7 as i32) | 4 as i32) as lu_byte;
    (*g).allgc = (*o).next;
    (*o).next = (*g).fixedgc;
    (*g).fixedgc = o;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_newobjdt(
    mut L: *mut lua_State,
    mut tt: i32,
    mut sz: size_t,
    mut offset: size_t,
) -> *mut GCObject {
    let mut g: *mut global_State = (*L).l_G;
    let mut p: *mut std::ffi::c_char =
        luaM_malloc_(L, sz, tt & 0xf as i32) as *mut std::ffi::c_char;
    let mut o: *mut GCObject = p.offset(offset as isize) as *mut GCObject;
    (*o).marked =
        ((*g).currentwhite as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte;
    (*o).tt = tt as lu_byte;
    (*o).next = (*g).allgc;
    (*g).allgc = o;
    return o;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_newobj(
    mut L: *mut lua_State,
    mut tt: i32,
    mut sz: size_t,
) -> *mut GCObject {
    return luaC_newobjdt(L, tt, sz, 0 as size_t);
}
unsafe extern "C-unwind" fn reallymarkobject(mut g: *mut global_State, mut o: *mut GCObject) {
    let mut current_block_18: u64;
    match (*o).tt {
        LUA_VSHRSTR | LUA_VLNGSTR => {
            (*o).marked = ((*o).marked as i32 & !((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                | (1 as i32) << 5 as i32) as lu_byte;
            current_block_18 = 18317007320854588510;
        }
        LUA_VUPVAL => {
            let mut uv: *mut UpVal = &mut (*(o as *mut GCUnion)).upv;
            if (*uv).v.p != &mut (*uv).u.value as *mut TValue {
                (*uv).marked = ((*uv).marked as i32
                    & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        as lu_byte as i32) as lu_byte;
            } else {
                (*uv).marked = ((*uv).marked as i32
                    & !((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    | (1 as i32) << 5 as i32) as lu_byte;
            }
            if (*(*uv).v.p).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*(*uv).v.p).tt_ as i32 & 0x3f as i32 == (*(*(*uv).v.p).value_.gc).tt as i32
                    && (((*g).mainthread).is_null()
                        || (*(*(*uv).v.p).value_.gc).marked as i32
                            & ((*(*(*g).mainthread).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            if (*(*uv).v.p).tt_ as i32 & (1 as i32) << 6 as i32 != 0
                && (*(*(*uv).v.p).value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                reallymarkobject(g, (*(*uv).v.p).value_.gc);
            }
            current_block_18 = 18317007320854588510;
        }
        LUA_VUSERDATA => {
            let mut u: *mut Udata = &mut (*(o as *mut GCUnion)).u;
            if (*u).nuvalue as i32 == 0 {
                if !((*u).metatable).is_null() {
                    if (*(*u).metatable).marked as i32
                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                        != 0
                    {
                        reallymarkobject(g, &mut (*((*u).metatable as *mut GCUnion)).gc);
                    }
                }
                (*u).marked = ((*u).marked as i32
                    & !((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    | (1 as i32) << 5 as i32) as lu_byte;
                current_block_18 = 18317007320854588510;
            } else {
                current_block_18 = 15904375183555213903;
            }
        }
        LUA_VLCL | LUA_VCCL | LUA_VTABLE | LUA_VTHREAD | LUA_VPROTO => {
            current_block_18 = 15904375183555213903;
        }
        _ => {
            current_block_18 = 18317007320854588510;
        }
    }
    match current_block_18 {
        15904375183555213903 => {
            linkgclist_(&mut (*(o as *mut GCUnion)).gc, getgclist(o), &mut (*g).gray);
        }
        _ => {}
    };
}
unsafe extern "C-unwind" fn markmt(mut g: *mut global_State) {
    let mut i: i32 = 0;
    i = 0;
    while i < 9 as i32 {
        if !((*g).mt[i as usize]).is_null() {
            if (*(*g).mt[i as usize]).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
            {
                reallymarkobject(
                    g,
                    &mut (*(*((*g).mt).as_mut_ptr().offset(i as isize) as *mut GCUnion)).gc,
                );
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn markbeingfnz(mut g: *mut global_State) -> lu_mem {
    let mut o: *mut GCObject = 0 as *mut GCObject;
    let mut count: lu_mem = 0 as lu_mem;
    o = (*g).tobefnz;
    while !o.is_null() {
        count = count.wrapping_add(1);
        count;
        if (*o).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
            reallymarkobject(g, &mut (*(o as *mut GCUnion)).gc);
        }
        o = (*o).next;
    }
    return count;
}
unsafe extern "C-unwind" fn remarkupvals(mut g: *mut global_State) -> i32 {
    let mut thread: *mut lua_State = 0 as *mut lua_State;
    let mut p: *mut *mut lua_State = &mut (*g).twups;
    let mut work: i32 = 0;
    loop {
        thread = *p;
        if thread.is_null() {
            break;
        }
        work += 1;
        work;
        if (*thread).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) == 0
            && !((*thread).openupval).is_null()
        {
            p = &mut (*thread).twups;
        } else {
            let mut uv: *mut UpVal = 0 as *mut UpVal;
            *p = (*thread).twups;
            (*thread).twups = thread;
            uv = (*thread).openupval;
            while !uv.is_null() {
                work += 1;
                work;
                if (*uv).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) == 0 {
                    if (*(*uv).v.p).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                        || (*(*uv).v.p).tt_ as i32 & 0x3f as i32
                            == (*(*(*uv).v.p).value_.gc).tt as i32
                            && (((*g).mainthread).is_null()
                                || (*(*(*uv).v.p).value_.gc).marked as i32
                                    & ((*(*(*g).mainthread).l_G).currentwhite as i32
                                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                    == 0)
                    {
                    } else {
                    };
                    if (*(*uv).v.p).tt_ as i32 & (1 as i32) << 6 as i32 != 0
                        && (*(*(*uv).v.p).value_.gc).marked as i32
                            & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                            != 0
                    {
                        reallymarkobject(g, (*(*uv).v.p).value_.gc);
                    }
                }
                uv = (*uv).u.open.next;
            }
        }
    }
    return work;
}
unsafe extern "C-unwind" fn cleargraylists(mut g: *mut global_State) {
    (*g).grayagain = 0 as *mut GCObject;
    (*g).gray = (*g).grayagain;
    (*g).ephemeron = 0 as *mut GCObject;
    (*g).allweak = (*g).ephemeron;
    (*g).weak = (*g).allweak;
}
unsafe extern "C-unwind" fn restartcollection(mut g: *mut global_State) {
    cleargraylists(g);
    if (*(*g).mainthread).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
        reallymarkobject(g, &mut (*((*g).mainthread as *mut GCUnion)).gc);
    }
    if (*g).l_registry.tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*g).l_registry.tt_ as i32 & 0x3f as i32 == (*(*g).l_registry.value_.gc).tt as i32
            && (((*g).mainthread).is_null()
                || (*(*g).l_registry.value_.gc).marked as i32
                    & ((*(*(*g).mainthread).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    if (*g).l_registry.tt_ as i32 & (1 as i32) << 6 as i32 != 0
        && (*(*g).l_registry.value_.gc).marked as i32
            & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
            != 0
    {
        reallymarkobject(g, (*g).l_registry.value_.gc);
    }
    markmt(g);
    markbeingfnz(g);
}
unsafe extern "C-unwind" fn genlink(mut g: *mut global_State, mut o: *mut GCObject) {
    if (*o).marked as i32 & 7 as i32 == 5 as i32 {
        linkgclist_(
            &mut (*(o as *mut GCUnion)).gc,
            getgclist(o),
            &mut (*g).grayagain,
        );
    } else if (*o).marked as i32 & 7 as i32 == 6 as i32 {
        (*o).marked = ((*o).marked as i32 ^ (6 as i32 ^ 4 as i32)) as lu_byte;
    }
}
unsafe extern "C-unwind" fn traverseweakvalue(mut g: *mut global_State, mut h: *mut Table) {
    let mut n: *mut Node = 0 as *mut Node;
    let mut limit: *mut Node = &mut *((*h).node)
        .offset(((1 as i32) << (*h).lsizenode as i32) as size_t as isize)
        as *mut Node;
    let mut hasclears: i32 = ((*h).alimit > 0 as u32) as i32;
    n = &mut *((*h).node).offset(0 as isize) as *mut Node;
    while n < limit {
        if (*n).i_val.tt_ as i32 & 0xf as i32 == 0 {
            clearkey(n);
        } else {
            if (*n).u.key_tt as i32 & (1 as i32) << 6 as i32 != 0
                && (*(*n).u.key_val.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                reallymarkobject(g, (*n).u.key_val.gc);
            }
            if hasclears == 0
                && iscleared(
                    g,
                    (if (*n).i_val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                        (*n).i_val.value_.gc
                    } else {
                        0 as *mut GCObject
                    }),
                ) != 0
            {
                hasclears = 1 as i32;
            }
        }
        n = n.offset(1);
        n;
    }
    if (*g).gcstate as i32 == 2 as i32 && hasclears != 0 {
        linkgclist_(
            &mut (*(h as *mut GCUnion)).gc,
            &mut (*h).gclist,
            &mut (*g).weak,
        );
    } else {
        linkgclist_(
            &mut (*(h as *mut GCUnion)).gc,
            &mut (*h).gclist,
            &mut (*g).grayagain,
        );
    };
}
unsafe extern "C-unwind" fn traverseephemeron(
    mut g: *mut global_State,
    mut h: *mut Table,
    mut inv: i32,
) -> i32 {
    let mut marked: i32 = 0;
    let mut hasclears: i32 = 0;
    let mut hasww: i32 = 0;
    let mut i: u32 = 0;
    let mut asize: u32 = luaH_realasize(h);
    let mut nsize: u32 = ((1 as i32) << (*h).lsizenode as i32) as u32;
    i = 0 as u32;
    while i < asize {
        if (*((*h).array).offset(i as isize)).tt_ as i32 & (1 as i32) << 6 as i32 != 0
            && (*(*((*h).array).offset(i as isize)).value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            marked = 1 as i32;
            reallymarkobject(g, (*((*h).array).offset(i as isize)).value_.gc);
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as u32;
    while i < nsize {
        let mut n: *mut Node = if inv != 0 {
            &mut *((*h).node).offset(nsize.wrapping_sub(1).wrapping_sub(i) as isize) as *mut Node
        } else {
            &mut *((*h).node).offset(i as isize) as *mut Node
        };
        if (*n).i_val.tt_ as i32 & 0xf as i32 == 0 {
            clearkey(n);
        } else if iscleared(
            g,
            if (*n).u.key_tt as i32 & (1 as i32) << 6 as i32 != 0 {
                (*n).u.key_val.gc
            } else {
                0 as *mut GCObject
            },
        ) != 0
        {
            hasclears = 1 as i32;
            if (*n).i_val.tt_ as i32 & (1 as i32) << 6 as i32 != 0
                && (*(*n).i_val.value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                hasww = 1 as i32;
            }
        } else if (*n).i_val.tt_ as i32 & (1 as i32) << 6 as i32 != 0
            && (*(*n).i_val.value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            marked = 1 as i32;
            reallymarkobject(g, (*n).i_val.value_.gc);
        }
        i = i.wrapping_add(1);
        i;
    }
    if (*g).gcstate as i32 == 0 {
        linkgclist_(
            &mut (*(h as *mut GCUnion)).gc,
            &mut (*h).gclist,
            &mut (*g).grayagain,
        );
    } else if hasww != 0 {
        linkgclist_(
            &mut (*(h as *mut GCUnion)).gc,
            &mut (*h).gclist,
            &mut (*g).ephemeron,
        );
    } else if hasclears != 0 {
        linkgclist_(
            &mut (*(h as *mut GCUnion)).gc,
            &mut (*h).gclist,
            &mut (*g).allweak,
        );
    } else {
        genlink(g, &mut (*(h as *mut GCUnion)).gc);
    }
    return marked;
}
unsafe extern "C-unwind" fn traversestrongtable(mut g: *mut global_State, mut h: *mut Table) {
    let mut n: *mut Node = 0 as *mut Node;
    let mut limit: *mut Node = &mut *((*h).node)
        .offset(((1 as i32) << (*h).lsizenode as i32) as size_t as isize)
        as *mut Node;
    let mut i: u32 = 0;
    let mut asize: u32 = luaH_realasize(h);
    i = 0 as u32;
    while i < asize {
        if (*((*h).array).offset(i as isize)).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*((*h).array).offset(i as isize)).tt_ as i32 & 0x3f as i32
                == (*(*((*h).array).offset(i as isize)).value_.gc).tt as i32
                && (((*g).mainthread).is_null()
                    || (*(*((*h).array).offset(i as isize)).value_.gc).marked as i32
                        & ((*(*(*g).mainthread).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*h).array).offset(i as isize)).tt_ as i32 & (1 as i32) << 6 as i32 != 0
            && (*(*((*h).array).offset(i as isize)).value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            reallymarkobject(g, (*((*h).array).offset(i as isize)).value_.gc);
        }
        i = i.wrapping_add(1);
        i;
    }
    n = &mut *((*h).node).offset(0 as isize) as *mut Node;
    while n < limit {
        if (*n).i_val.tt_ as i32 & 0xf as i32 == 0 {
            clearkey(n);
        } else {
            if (*n).u.key_tt as i32 & (1 as i32) << 6 as i32 != 0
                && (*(*n).u.key_val.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                reallymarkobject(g, (*n).u.key_val.gc);
            }
            if (*n).i_val.tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*n).i_val.tt_ as i32 & 0x3f as i32 == (*(*n).i_val.value_.gc).tt as i32
                    && (((*g).mainthread).is_null()
                        || (*(*n).i_val.value_.gc).marked as i32
                            & ((*(*(*g).mainthread).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            if (*n).i_val.tt_ as i32 & (1 as i32) << 6 as i32 != 0
                && (*(*n).i_val.value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                reallymarkobject(g, (*n).i_val.value_.gc);
            }
        }
        n = n.offset(1);
        n;
    }
    genlink(g, &mut (*(h as *mut GCUnion)).gc);
}
unsafe extern "C-unwind" fn traversetable(mut g: *mut global_State, mut h: *mut Table) -> lu_mem {
    let mut weakkey: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut weakvalue: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut mode: *const TValue = if ((*h).metatable).is_null() {
        0 as *const TValue
    } else if (*(*h).metatable).flags as u32 & (1 as u32) << TM_MODE as i32 != 0 {
        0 as *const TValue
    } else {
        luaT_gettm(
            (*h).metatable,
            TM_MODE,
            (*g).tmname[TM_MODE as i32 as usize],
        )
    };
    let mut smode: *mut TString = 0 as *mut TString;
    if !((*h).metatable).is_null() {
        if (*(*h).metatable).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
        {
            reallymarkobject(g, &mut (*((*h).metatable as *mut GCUnion)).gc);
        }
    }
    if !mode.is_null()
        && (*mode).tt_ as i32 == 4 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32
        && {
            smode = &mut (*((*mode).value_.gc as *mut GCUnion)).ts as *mut TString;
            weakkey = strchr(((*smode).contents).as_mut_ptr(), 'k' as i32);
            weakvalue = strchr(((*smode).contents).as_mut_ptr(), 'v' as i32);
            !weakkey.is_null() || !weakvalue.is_null()
        }
    {
        if weakkey.is_null() {
            traverseweakvalue(g, h);
        } else if weakvalue.is_null() {
            traverseephemeron(g, h, 0);
        } else {
            linkgclist_(
                &mut (*(h as *mut GCUnion)).gc,
                &mut (*h).gclist,
                &mut (*g).allweak,
            );
        }
    } else {
        traversestrongtable(g, h);
    }
    return (1u32).wrapping_add((*h).alimit).wrapping_add(
        (2 as i32
            * (if ((*h).lastfree).is_null() {
                0
            } else {
                (1 as i32) << (*h).lsizenode as i32
            })) as u32,
    ) as lu_mem;
}
unsafe extern "C-unwind" fn traverseudata(mut g: *mut global_State, mut u: *mut Udata) -> i32 {
    let mut i: i32 = 0;
    if !((*u).metatable).is_null() {
        if (*(*u).metatable).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
        {
            reallymarkobject(g, &mut (*((*u).metatable as *mut GCUnion)).gc);
        }
    }
    i = 0;
    while i < (*u).nuvalue as i32 {
        if (*((*u).uv).as_mut_ptr().offset(i as isize)).uv.tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*((*u).uv).as_mut_ptr().offset(i as isize)).uv.tt_ as i32 & 0x3f as i32
                == (*(*((*u).uv).as_mut_ptr().offset(i as isize)).uv.value_.gc).tt as i32
                && (((*g).mainthread).is_null()
                    || (*(*((*u).uv).as_mut_ptr().offset(i as isize)).uv.value_.gc).marked as i32
                        & ((*(*(*g).mainthread).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*u).uv).as_mut_ptr().offset(i as isize)).uv.tt_ as i32 & (1 as i32) << 6 as i32 != 0
            && (*(*((*u).uv).as_mut_ptr().offset(i as isize)).uv.value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            reallymarkobject(g, (*((*u).uv).as_mut_ptr().offset(i as isize)).uv.value_.gc);
        }
        i += 1;
        i;
    }
    genlink(g, &mut (*(u as *mut GCUnion)).gc);
    return 1 as i32 + (*u).nuvalue as i32;
}
unsafe extern "C-unwind" fn traverseproto(mut g: *mut global_State, mut f: *mut Proto) -> i32 {
    let mut i: i32 = 0;
    if !((*f).source).is_null() {
        if (*(*f).source).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
            reallymarkobject(g, &mut (*((*f).source as *mut GCUnion)).gc);
        }
    }
    i = 0;
    while i < (*f).sizek {
        if (*((*f).k).offset(i as isize)).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*((*f).k).offset(i as isize)).tt_ as i32 & 0x3f as i32
                == (*(*((*f).k).offset(i as isize)).value_.gc).tt as i32
                && (((*g).mainthread).is_null()
                    || (*(*((*f).k).offset(i as isize)).value_.gc).marked as i32
                        & ((*(*(*g).mainthread).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*f).k).offset(i as isize)).tt_ as i32 & (1 as i32) << 6 as i32 != 0
            && (*(*((*f).k).offset(i as isize)).value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            reallymarkobject(g, (*((*f).k).offset(i as isize)).value_.gc);
        }
        i += 1;
        i;
    }
    i = 0;
    while i < (*f).sizeupvalues {
        if !((*((*f).upvalues).offset(i as isize)).name).is_null() {
            if (*(*((*f).upvalues).offset(i as isize)).name).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
            {
                reallymarkobject(
                    g,
                    &mut (*((*((*f).upvalues).offset(i as isize)).name as *mut GCUnion)).gc,
                );
            }
        }
        i += 1;
        i;
    }
    i = 0;
    while i < (*f).sizep {
        if !(*((*f).p).offset(i as isize)).is_null() {
            if (**((*f).p).offset(i as isize)).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
            {
                reallymarkobject(g, &mut (*(*((*f).p).offset(i as isize) as *mut GCUnion)).gc);
            }
        }
        i += 1;
        i;
    }
    i = 0;
    while i < (*f).sizelocvars {
        if !((*((*f).locvars).offset(i as isize)).varname).is_null() {
            if (*(*((*f).locvars).offset(i as isize)).varname).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
            {
                reallymarkobject(
                    g,
                    &mut (*((*((*f).locvars).offset(i as isize)).varname as *mut GCUnion)).gc,
                );
            }
        }
        i += 1;
        i;
    }
    return 1 as i32 + (*f).sizek + (*f).sizeupvalues + (*f).sizep + (*f).sizelocvars;
}
unsafe extern "C-unwind" fn traverseCclosure(
    mut g: *mut global_State,
    mut cl: *mut CClosure,
) -> i32 {
    let mut i: i32 = 0;
    i = 0;
    while i < (*cl).nupvalues as i32 {
        if (*((*cl).upvalue).as_mut_ptr().offset(i as isize)).tt_ as i32 & (1 as i32) << 6 as i32
            == 0
            || (*((*cl).upvalue).as_mut_ptr().offset(i as isize)).tt_ as i32 & 0x3f as i32
                == (*(*((*cl).upvalue).as_mut_ptr().offset(i as isize)).value_.gc).tt as i32
                && (((*g).mainthread).is_null()
                    || (*(*((*cl).upvalue).as_mut_ptr().offset(i as isize)).value_.gc).marked
                        as i32
                        & ((*(*(*g).mainthread).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*cl).upvalue).as_mut_ptr().offset(i as isize)).tt_ as i32 & (1 as i32) << 6 as i32
            != 0
            && (*(*((*cl).upvalue).as_mut_ptr().offset(i as isize)).value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            reallymarkobject(
                g,
                (*((*cl).upvalue).as_mut_ptr().offset(i as isize)).value_.gc,
            );
        }
        i += 1;
        i;
    }
    return 1 as i32 + (*cl).nupvalues as i32;
}
unsafe extern "C-unwind" fn traverseLclosure(
    mut g: *mut global_State,
    mut cl: *mut LClosure,
) -> i32 {
    let mut i: i32 = 0;
    if !((*cl).p).is_null() {
        if (*(*cl).p).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
            reallymarkobject(g, &mut (*((*cl).p as *mut GCUnion)).gc);
        }
    }
    i = 0;
    while i < (*cl).nupvalues as i32 {
        let mut uv: *mut UpVal = *((*cl).upvals).as_mut_ptr().offset(i as isize);
        if !uv.is_null() {
            if (*uv).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
                reallymarkobject(g, &mut (*(uv as *mut GCUnion)).gc);
            }
        }
        i += 1;
        i;
    }
    return 1 as i32 + (*cl).nupvalues as i32;
}
unsafe extern "C-unwind" fn traversethread(
    mut g: *mut global_State,
    mut th: *mut lua_State,
) -> i32 {
    let mut uv: *mut UpVal = 0 as *mut UpVal;
    let mut o: StkId = (*th).stack.p;
    if (*th).marked as i32 & 7 as i32 > 1 as i32 || (*g).gcstate as i32 == 0 {
        linkgclist_(
            &mut (*(th as *mut GCUnion)).gc,
            &mut (*th).gclist,
            &mut (*g).grayagain,
        );
    }
    if o.is_null() {
        return 1 as i32;
    }
    while o < (*th).top.p {
        if (*o).val.tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*o).val.tt_ as i32 & 0x3f as i32 == (*(*o).val.value_.gc).tt as i32
                && (((*g).mainthread).is_null()
                    || (*(*o).val.value_.gc).marked as i32
                        & ((*(*(*g).mainthread).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*o).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0
            && (*(*o).val.value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            reallymarkobject(g, (*o).val.value_.gc);
        }
        o = o.offset(1);
        o;
    }
    uv = (*th).openupval;
    while !uv.is_null() {
        if (*uv).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
            reallymarkobject(g, &mut (*(uv as *mut GCUnion)).gc);
        }
        uv = (*uv).u.open.next;
    }
    if (*g).gcstate as i32 == 2 as i32 {
        if (*g).gcemergency == 0 {
            luaD_shrinkstack(th);
        }
        o = (*th).top.p;
        while o < ((*th).stack_last.p).offset(5) {
            (*o).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
            o = o.offset(1);
            o;
        }
        if !((*th).twups != th) && !((*th).openupval).is_null() {
            (*th).twups = (*g).twups;
            (*g).twups = th;
        }
    }
    return 1 as i32 + ((*th).stack_last.p).offset_from((*th).stack.p) as std::ffi::c_long as i32;
}
unsafe extern "C-unwind" fn propagatemark(mut g: *mut global_State) -> lu_mem {
    let mut o: *mut GCObject = (*g).gray;
    (*o).marked = ((*o).marked as i32 | (1 as i32) << 5 as i32) as lu_byte;
    (*g).gray = *getgclist(o);
    match (*o).tt {
        LUA_VTABLE => return traversetable(g, &mut (*(o as *mut GCUnion)).h),
        LUA_VUSERDATA => return traverseudata(g, &mut (*(o as *mut GCUnion)).u) as lu_mem,
        LUA_VLCL => return traverseLclosure(g, &mut (*(o as *mut GCUnion)).cl.l) as lu_mem,
        LUA_VCCL => return traverseCclosure(g, &mut (*(o as *mut GCUnion)).cl.c) as lu_mem,
        LUA_VPROTO => return traverseproto(g, &mut (*(o as *mut GCUnion)).p) as lu_mem,
        LUA_VTHREAD => return traversethread(g, &mut (*(o as *mut GCUnion)).th) as lu_mem,
        _ => return 0 as lu_mem,
    };
}
unsafe extern "C-unwind" fn propagateall(mut g: *mut global_State) -> lu_mem {
    let mut tot: lu_mem = 0 as lu_mem;
    while !((*g).gray).is_null() {
        tot = tot.wrapping_add(propagatemark(g));
    }
    return tot;
}
unsafe extern "C-unwind" fn convergeephemerons(mut g: *mut global_State) {
    let mut changed: i32 = 0;
    let mut dir: i32 = 0;
    loop {
        let mut w: *mut GCObject = 0 as *mut GCObject;
        let mut next: *mut GCObject = (*g).ephemeron;
        (*g).ephemeron = 0 as *mut GCObject;
        changed = 0;
        loop {
            w = next;
            if w.is_null() {
                break;
            }
            let mut h: *mut Table = &mut (*(w as *mut GCUnion)).h;
            next = (*h).gclist;
            (*h).marked = ((*h).marked as i32 | (1 as i32) << 5 as i32) as lu_byte;
            if traverseephemeron(g, h, dir) != 0 {
                propagateall(g);
                changed = 1 as i32;
            }
        }
        dir = (dir == 0) as i32;
        if !(changed != 0) {
            break;
        }
    }
}
unsafe extern "C-unwind" fn clearbykeys(mut g: *mut global_State, mut l: *mut GCObject) {
    while !l.is_null() {
        let mut h: *mut Table = &mut (*(l as *mut GCUnion)).h;
        let mut limit: *mut Node = &mut *((*h).node)
            .offset(((1 as i32) << (*h).lsizenode as i32) as size_t as isize)
            as *mut Node;
        let mut n: *mut Node = 0 as *mut Node;
        n = &mut *((*h).node).offset(0 as isize) as *mut Node;
        while n < limit {
            if iscleared(
                g,
                if (*n).u.key_tt as i32 & (1 as i32) << 6 as i32 != 0 {
                    (*n).u.key_val.gc
                } else {
                    0 as *mut GCObject
                },
            ) != 0
            {
                (*n).i_val.tt_ = (0 | (1 as i32) << 4 as i32) as lu_byte;
            }
            if (*n).i_val.tt_ as i32 & 0xf as i32 == 0 {
                clearkey(n);
            }
            n = n.offset(1);
            n;
        }
        l = (*&mut (*(l as *mut GCUnion)).h).gclist;
    }
}
unsafe extern "C-unwind" fn clearbyvalues(
    mut g: *mut global_State,
    mut l: *mut GCObject,
    mut f: *mut GCObject,
) {
    while l != f {
        let mut h: *mut Table = &mut (*(l as *mut GCUnion)).h;
        let mut n: *mut Node = 0 as *mut Node;
        let mut limit: *mut Node = &mut *((*h).node)
            .offset(((1 as i32) << (*h).lsizenode as i32) as size_t as isize)
            as *mut Node;
        let mut i: u32 = 0;
        let mut asize: u32 = luaH_realasize(h);
        i = 0 as u32;
        while i < asize {
            let mut o: *mut TValue = &mut *((*h).array).offset(i as isize) as *mut TValue;
            if iscleared(
                g,
                if (*o).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                    (*o).value_.gc
                } else {
                    0 as *mut GCObject
                },
            ) != 0
            {
                (*o).tt_ = (0 | (1 as i32) << 4 as i32) as lu_byte;
            }
            i = i.wrapping_add(1);
            i;
        }
        n = &mut *((*h).node).offset(0 as isize) as *mut Node;
        while n < limit {
            if iscleared(
                g,
                if (*n).i_val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                    (*n).i_val.value_.gc
                } else {
                    0 as *mut GCObject
                },
            ) != 0
            {
                (*n).i_val.tt_ = (0 | (1 as i32) << 4 as i32) as lu_byte;
            }
            if (*n).i_val.tt_ as i32 & 0xf as i32 == 0 {
                clearkey(n);
            }
            n = n.offset(1);
            n;
        }
        l = (*&mut (*(l as *mut GCUnion)).h).gclist;
    }
}
unsafe extern "C-unwind" fn freeupval(mut L: *mut lua_State, mut uv: *mut UpVal) {
    if (*uv).v.p != &mut (*uv).u.value as *mut TValue {
        luaF_unlinkupval(uv);
    }
    luaM_free_(
        L,
        uv as *mut c_void,
        ::core::mem::size_of::<UpVal>() as usize,
    );
}
unsafe extern "C-unwind" fn freeobj(mut L: *mut lua_State, mut o: *mut GCObject) {
    match (*o).tt {
        LUA_VPROTO => {
            luaF_freeproto(L, &mut (*(o as *mut GCUnion)).p);
        }
        LUA_VUPVAL => {
            freeupval(L, &mut (*(o as *mut GCUnion)).upv);
        }
        LUA_VLCL => {
            let mut cl: *mut LClosure = &mut (*(o as *mut GCUnion)).cl.l;
            luaM_free_(
                L,
                cl as *mut c_void,
                (32 as usize as i32
                    + ::core::mem::size_of::<*mut TValue>() as usize as i32
                        * (*cl).nupvalues as i32) as size_t,
            );
        }
        LUA_VCCL => {
            let mut cl_0: *mut CClosure = &mut (*(o as *mut GCUnion)).cl.c;
            luaM_free_(
                L,
                cl_0 as *mut c_void,
                (32 as usize as i32
                    + ::core::mem::size_of::<TValue>() as usize as i32 * (*cl_0).nupvalues as i32)
                    as size_t,
            );
        }
        LUA_VTABLE => {
            luaH_free(L, &mut (*(o as *mut GCUnion)).h);
        }
        LUA_VTHREAD => {
            luaE_freethread(L, &mut (*(o as *mut GCUnion)).th);
        }
        LUA_VUSERDATA => {
            let mut u: *mut Udata = &mut (*(o as *mut GCUnion)).u;
            luaM_free_(
                L,
                o as *mut c_void,
                (if (*u).nuvalue as i32 == 0 {
                    32 as usize
                } else {
                    (40 as usize).wrapping_add(
                        (::core::mem::size_of::<UValue>() as usize)
                            .wrapping_mul((*u).nuvalue as usize),
                    )
                })
                .wrapping_add((*u).len),
            );
        }
        LUA_VSHRSTR => {
            let mut ts: *mut TString = &mut (*(o as *mut GCUnion)).ts;
            luaS_remove(L, ts);
            luaM_free_(
                L,
                ts as *mut c_void,
                (24 as usize).wrapping_add(
                    (((*ts).shrlen as i32 + 1 as i32) as usize)
                        .wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
                ),
            );
        }
        LUA_VLNGSTR => {
            let mut ts_0: *mut TString = &mut (*(o as *mut GCUnion)).ts;
            luaM_free_(
                L,
                ts_0 as *mut c_void,
                (24 as usize).wrapping_add(
                    ((*ts_0).u.lnglen)
                        .wrapping_add(1 as i32 as size_t)
                        .wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
                ),
            );
        }
        _ => {}
    };
}
unsafe extern "C-unwind" fn sweeplist(
    mut L: *mut lua_State,
    mut p: *mut *mut GCObject,
    mut countin: i32,
    mut countout: *mut i32,
) -> *mut *mut GCObject {
    let mut g: *mut global_State = (*L).l_G;
    let mut ow: i32 = (*g).currentwhite as i32 ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32);
    let mut i: i32 = 0;
    let mut white: i32 = ((*g).currentwhite as i32
        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte
        as i32;
    i = 0;
    while !(*p).is_null() && i < countin {
        let mut curr: *mut GCObject = *p;
        let mut marked: i32 = (*curr).marked as i32;
        if marked & ow != 0 {
            *p = (*curr).next;
            freeobj(L, curr);
        } else {
            (*curr).marked = (marked
                & !((1 as i32) << 5 as i32
                    | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    | 7 as i32)
                | white) as lu_byte;
            p = &mut (*curr).next;
        }
        i += 1;
        i;
    }
    if !countout.is_null() {
        *countout = i;
    }
    return if (*p).is_null() {
        0 as *mut *mut GCObject
    } else {
        p
    };
}
unsafe extern "C-unwind" fn sweeptolive(
    mut L: *mut lua_State,
    mut p: *mut *mut GCObject,
) -> *mut *mut GCObject {
    let mut old: *mut *mut GCObject = p;
    loop {
        p = sweeplist(L, p, 1 as i32, 0 as *mut i32);
        if !(p == old) {
            break;
        }
    }
    return p;
}
unsafe extern "C-unwind" fn checkSizes(mut L: *mut lua_State, mut g: *mut global_State) {
    if (*g).gcemergency == 0 {
        if (*g).strt.nuse < (*g).strt.size / 4 as i32 {
            let mut olddebt: l_mem = (*g).GCdebt;
            luaS_resize(L, (*g).strt.size / 2 as i32);
            (*g).GCestimate = ((*g).GCestimate).wrapping_add(((*g).GCdebt - olddebt) as lu_mem);
        }
    }
}
unsafe extern "C-unwind" fn udata2finalize(mut g: *mut global_State) -> *mut GCObject {
    let mut o: *mut GCObject = (*g).tobefnz;
    (*g).tobefnz = (*o).next;
    (*o).next = (*g).allgc;
    (*g).allgc = o;
    (*o).marked = ((*o).marked as i32 & !((1 as i32) << 6 as i32) as lu_byte as i32) as lu_byte;
    if 3 as i32 <= (*g).gcstate as i32 && (*g).gcstate as i32 <= 6 as i32 {
        (*o).marked = ((*o).marked as i32
            & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
            | ((*g).currentwhite as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                as lu_byte as i32) as lu_byte;
    } else if (*o).marked as i32 & 7 as i32 == 3 as i32 {
        (*g).firstold1 = o;
    }
    return o;
}
unsafe extern "C-unwind" fn dothecall(mut L: *mut lua_State, mut ud: *mut c_void) {
    luaD_callnoyield(L, ((*L).top.p).offset(-(2)), 0);
}
unsafe extern "C-unwind" fn GCTM(mut L: *mut lua_State) {
    let mut g: *mut global_State = (*L).l_G;
    let mut tm: *const TValue = 0 as *const TValue;
    let mut v: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut io: *mut TValue = &mut v;
    let mut i_g: *mut GCObject = udata2finalize(g);
    (*io).value_.gc = i_g;
    (*io).tt_ = ((*i_g).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
    tm = luaT_gettmbyobj(L, &mut v, TM_GC);
    if !((*tm).tt_ as i32 & 0xf as i32 == 0) {
        let mut status: i32 = 0;
        let mut oldah: lu_byte = (*L).allowhook;
        let mut oldgcstp: i32 = (*g).gcstp as i32;
        (*g).gcstp = ((*g).gcstp as i32 | 2 as i32) as lu_byte;
        (*L).allowhook = 0 as lu_byte;
        let fresh9 = (*L).top.p;
        (*L).top.p = ((*L).top.p).offset(1);
        let mut io1: *mut TValue = &mut (*fresh9).val;
        let mut io2: *const TValue = tm;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        let fresh10 = (*L).top.p;
        (*L).top.p = ((*L).top.p).offset(1);
        let mut io1_0: *mut TValue = &mut (*fresh10).val;
        let mut io2_0: *const TValue = &mut v;
        (*io1_0).value_ = (*io2_0).value_;
        (*io1_0).tt_ = (*io2_0).tt_;
        if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1_0).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*(*L).ci).callstatus = ((*(*L).ci).callstatus as i32 | (1 as i32) << 7 as i32) as u16;
        status = luaD_pcall(
            L,
            Some(dothecall as unsafe extern "C-unwind" fn(*mut lua_State, *mut c_void) -> ()),
            0 as *mut c_void,
            (((*L).top.p).offset(-(2)) as *mut std::ffi::c_char)
                .offset_from((*L).stack.p as *mut std::ffi::c_char),
            0 as ptrdiff_t,
        );
        (*(*L).ci).callstatus = ((*(*L).ci).callstatus as i32 & !((1 as i32) << 7 as i32)) as u16;
        (*L).allowhook = oldah;
        (*g).gcstp = oldgcstp as lu_byte;
        if ((status != 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            luaE_warnerror(L, c"__gc".as_ptr());
            (*L).top.p = ((*L).top.p).offset(-1);
            (*L).top.p;
        }
    }
}
unsafe extern "C-unwind" fn runafewfinalizers(mut L: *mut lua_State, mut n: i32) -> i32 {
    let mut g: *mut global_State = (*L).l_G;
    let mut i: i32 = 0;
    i = 0;
    while i < n && !((*g).tobefnz).is_null() {
        GCTM(L);
        i += 1;
        i;
    }
    return i;
}
unsafe extern "C-unwind" fn callallpendingfinalizers(mut L: *mut lua_State) {
    let mut g: *mut global_State = (*L).l_G;
    while !((*g).tobefnz).is_null() {
        GCTM(L);
    }
}
unsafe extern "C-unwind" fn findlast(mut p: *mut *mut GCObject) -> *mut *mut GCObject {
    while !(*p).is_null() {
        p = &mut (**p).next;
    }
    return p;
}
unsafe extern "C-unwind" fn separatetobefnz(mut g: *mut global_State, mut all: i32) {
    let mut curr: *mut GCObject = 0 as *mut GCObject;
    let mut p: *mut *mut GCObject = &mut (*g).finobj;
    let mut lastnext: *mut *mut GCObject = findlast(&mut (*g).tobefnz);
    loop {
        curr = *p;
        if !(curr != (*g).finobjold1) {
            break;
        }
        if !((*curr).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
            || all != 0)
        {
            p = &mut (*curr).next;
        } else {
            if curr == (*g).finobjsur {
                (*g).finobjsur = (*curr).next;
            }
            *p = (*curr).next;
            (*curr).next = *lastnext;
            *lastnext = curr;
            lastnext = &mut (*curr).next;
        }
    }
}
unsafe extern "C-unwind" fn checkpointer(mut p: *mut *mut GCObject, mut o: *mut GCObject) {
    if o == *p {
        *p = (*o).next;
    }
}
unsafe extern "C-unwind" fn correctpointers(mut g: *mut global_State, mut o: *mut GCObject) {
    checkpointer(&mut (*g).survival, o);
    checkpointer(&mut (*g).old1, o);
    checkpointer(&mut (*g).reallyold, o);
    checkpointer(&mut (*g).firstold1, o);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_checkfinalizer(
    mut L: *mut lua_State,
    mut o: *mut GCObject,
    mut mt: *mut Table,
) {
    let mut g: *mut global_State = (*L).l_G;
    if (*o).marked as i32 & (1 as i32) << 6 as i32 != 0
        || (if mt.is_null() {
            0 as *const TValue
        } else {
            (if (*mt).flags as u32 & (1 as u32) << TM_GC as i32 != 0 {
                0 as *const TValue
            } else {
                luaT_gettm(mt, TM_GC, (*g).tmname[TM_GC as i32 as usize])
            })
        })
        .is_null()
        || (*g).gcstp as i32 & 4 as i32 != 0
    {
        return;
    } else {
        let mut p: *mut *mut GCObject = 0 as *mut *mut GCObject;
        if 3 as i32 <= (*g).gcstate as i32 && (*g).gcstate as i32 <= 6 as i32 {
            (*o).marked = ((*o).marked as i32
                & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                | ((*g).currentwhite as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    as lu_byte as i32) as lu_byte;
            if (*g).sweepgc == &mut (*o).next as *mut *mut GCObject {
                (*g).sweepgc = sweeptolive(L, (*g).sweepgc);
            }
        } else {
            correctpointers(g, o);
        }
        p = &mut (*g).allgc;
        while *p != o {
            p = &mut (**p).next;
        }
        *p = (*o).next;
        (*o).next = (*g).finobj;
        (*g).finobj = o;
        (*o).marked = ((*o).marked as i32 | (1 as i32) << 6 as i32) as lu_byte;
    };
}
unsafe extern "C-unwind" fn setpause(mut g: *mut global_State) {
    let mut threshold: l_mem = 0;
    let mut debt: l_mem = 0;
    let mut pause: i32 = (*g).gcpause as i32 * 4 as i32;
    let mut estimate: l_mem = ((*g).GCestimate / 100 as lu_mem) as l_mem;
    threshold = if (pause as l_mem) < (!(0 as lu_mem) >> 1 as i32) as l_mem / estimate {
        estimate * pause as l_mem
    } else {
        (!(0 as lu_mem) >> 1 as i32) as l_mem
    };
    debt = (((*g).totalbytes + (*g).GCdebt) as lu_mem).wrapping_sub(threshold as lu_mem) as l_mem;
    if debt > 0 as l_mem {
        debt = 0 as l_mem;
    }
    luaE_setdebt(g, debt);
}
unsafe extern "C-unwind" fn sweep2old(mut L: *mut lua_State, mut p: *mut *mut GCObject) {
    let mut curr: *mut GCObject = 0 as *mut GCObject;
    let mut g: *mut global_State = (*L).l_G;
    loop {
        curr = *p;
        if curr.is_null() {
            break;
        }
        if (*curr).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
            *p = (*curr).next;
            freeobj(L, curr);
        } else {
            (*curr).marked = ((*curr).marked as i32 & !(7 as i32) | 4 as i32) as lu_byte;
            if (*curr).tt as i32 == 8 as i32 | (0) << 4 as i32 {
                let mut th: *mut lua_State = &mut (*(curr as *mut GCUnion)).th;
                linkgclist_(
                    &mut (*(th as *mut GCUnion)).gc,
                    &mut (*th).gclist,
                    &mut (*g).grayagain,
                );
            } else if (*curr).tt as i32 == 9 as i32 | (0) << 4 as i32
                && (*(&mut (*(curr as *mut GCUnion)).upv as *mut UpVal)).v.p
                    != &mut (*(&mut (*(curr as *mut GCUnion)).upv as *mut UpVal))
                        .u
                        .value as *mut TValue
            {
                (*curr).marked = ((*curr).marked as i32
                    & !((1 as i32) << 5 as i32 | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        as lu_byte as i32) as lu_byte;
            } else {
                (*curr).marked = ((*curr).marked as i32 | (1 as i32) << 5 as i32) as lu_byte;
            }
            p = &mut (*curr).next;
        }
    }
}
unsafe extern "C-unwind" fn sweepgen(
    mut L: *mut lua_State,
    mut g: *mut global_State,
    mut p: *mut *mut GCObject,
    mut limit: *mut GCObject,
    mut pfirstold1: *mut *mut GCObject,
) -> *mut *mut GCObject {
    static mut nextage: [lu_byte; 7] = [
        1 as i32 as lu_byte,
        3 as i32 as lu_byte,
        3 as i32 as lu_byte,
        4 as i32 as lu_byte,
        4 as i32 as lu_byte,
        5 as i32 as lu_byte,
        6 as i32 as lu_byte,
    ];
    let mut white: i32 = ((*g).currentwhite as i32
        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte
        as i32;
    let mut curr: *mut GCObject = 0 as *mut GCObject;
    loop {
        curr = *p;
        if !(curr != limit) {
            break;
        }
        if (*curr).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
            *p = (*curr).next;
            freeobj(L, curr);
        } else {
            if (*curr).marked as i32 & 7 as i32 == 0 {
                let mut marked: i32 = (*curr).marked as i32
                    & !((1 as i32) << 5 as i32
                        | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                        | 7 as i32);
                (*curr).marked = (marked | 1 as i32 | white) as lu_byte;
            } else {
                (*curr).marked = ((*curr).marked as i32 & !(7 as i32)
                    | nextage[((*curr).marked as i32 & 7 as i32) as usize] as i32)
                    as lu_byte;
                if (*curr).marked as i32 & 7 as i32 == 3 as i32 && (*pfirstold1).is_null() {
                    *pfirstold1 = curr;
                }
            }
            p = &mut (*curr).next;
        }
    }
    return p;
}
unsafe extern "C-unwind" fn whitelist(mut g: *mut global_State, mut p: *mut GCObject) {
    let mut white: i32 = ((*g).currentwhite as i32
        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte
        as i32;
    while !p.is_null() {
        (*p).marked = ((*p).marked as i32
            & !((1 as i32) << 5 as i32
                | ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                | 7 as i32)
            | white) as lu_byte;
        p = (*p).next;
    }
}
unsafe extern "C-unwind" fn correctgraylist(mut p: *mut *mut GCObject) -> *mut *mut GCObject {
    let mut current_block: u64;
    let mut curr: *mut GCObject = 0 as *mut GCObject;
    loop {
        curr = *p;
        if curr.is_null() {
            break;
        }
        let mut next: *mut *mut GCObject = getgclist(curr);
        if !((*curr).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0) {
            if (*curr).marked as i32 & 7 as i32 == 5 as i32 {
                (*curr).marked = ((*curr).marked as i32 | (1 as i32) << 5 as i32) as lu_byte;
                (*curr).marked = ((*curr).marked as i32 ^ (5 as i32 ^ 6 as i32)) as lu_byte;
                current_block = 8466888583218658643;
            } else if (*curr).tt as i32 == 8 as i32 | (0) << 4 as i32 {
                current_block = 8466888583218658643;
            } else {
                if (*curr).marked as i32 & 7 as i32 == 6 as i32 {
                    (*curr).marked = ((*curr).marked as i32 ^ (6 as i32 ^ 4 as i32)) as lu_byte;
                }
                (*curr).marked = ((*curr).marked as i32 | (1 as i32) << 5 as i32) as lu_byte;
                current_block = 17465232319020127661;
            }
            match current_block {
                17465232319020127661 => {}
                _ => {
                    p = next;
                    continue;
                }
            }
        }
        *p = *next;
    }
    return p;
}
unsafe extern "C-unwind" fn correctgraylists(mut g: *mut global_State) {
    let mut list: *mut *mut GCObject = correctgraylist(&mut (*g).grayagain);
    *list = (*g).weak;
    (*g).weak = 0 as *mut GCObject;
    list = correctgraylist(list);
    *list = (*g).allweak;
    (*g).allweak = 0 as *mut GCObject;
    list = correctgraylist(list);
    *list = (*g).ephemeron;
    (*g).ephemeron = 0 as *mut GCObject;
    correctgraylist(list);
}
unsafe extern "C-unwind" fn markold(
    mut g: *mut global_State,
    mut from: *mut GCObject,
    mut to: *mut GCObject,
) {
    let mut p: *mut GCObject = 0 as *mut GCObject;
    p = from;
    while p != to {
        if (*p).marked as i32 & 7 as i32 == 3 as i32 {
            (*p).marked = ((*p).marked as i32 ^ (3 as i32 ^ 4 as i32)) as lu_byte;
            if (*p).marked as i32 & (1 as i32) << 5 as i32 != 0 {
                reallymarkobject(g, p);
            }
        }
        p = (*p).next;
    }
}
unsafe extern "C-unwind" fn finishgencycle(mut L: *mut lua_State, mut g: *mut global_State) {
    correctgraylists(g);
    checkSizes(L, g);
    (*g).gcstate = 0 as lu_byte;
    if (*g).gcemergency == 0 {
        callallpendingfinalizers(L);
    }
}
unsafe extern "C-unwind" fn youngcollection(mut L: *mut lua_State, mut g: *mut global_State) {
    let mut psurvival: *mut *mut GCObject = 0 as *mut *mut GCObject;
    let mut dummy: *mut GCObject = 0 as *mut GCObject;
    if !((*g).firstold1).is_null() {
        markold(g, (*g).firstold1, (*g).reallyold);
        (*g).firstold1 = 0 as *mut GCObject;
    }
    markold(g, (*g).finobj, (*g).finobjrold);
    markold(g, (*g).tobefnz, 0 as *mut GCObject);
    atomic(L);
    (*g).gcstate = 3 as i32 as lu_byte;
    psurvival = sweepgen(L, g, &mut (*g).allgc, (*g).survival, &mut (*g).firstold1);
    sweepgen(L, g, psurvival, (*g).old1, &mut (*g).firstold1);
    (*g).reallyold = (*g).old1;
    (*g).old1 = *psurvival;
    (*g).survival = (*g).allgc;
    dummy = 0 as *mut GCObject;
    psurvival = sweepgen(L, g, &mut (*g).finobj, (*g).finobjsur, &mut dummy);
    sweepgen(L, g, psurvival, (*g).finobjold1, &mut dummy);
    (*g).finobjrold = (*g).finobjold1;
    (*g).finobjold1 = *psurvival;
    (*g).finobjsur = (*g).finobj;
    sweepgen(L, g, &mut (*g).tobefnz, 0 as *mut GCObject, &mut dummy);
    finishgencycle(L, g);
}
unsafe extern "C-unwind" fn atomic2gen(mut L: *mut lua_State, mut g: *mut global_State) {
    cleargraylists(g);
    (*g).gcstate = 3 as i32 as lu_byte;
    sweep2old(L, &mut (*g).allgc);
    (*g).survival = (*g).allgc;
    (*g).old1 = (*g).survival;
    (*g).reallyold = (*g).old1;
    (*g).firstold1 = 0 as *mut GCObject;
    sweep2old(L, &mut (*g).finobj);
    (*g).finobjsur = (*g).finobj;
    (*g).finobjold1 = (*g).finobjsur;
    (*g).finobjrold = (*g).finobjold1;
    sweep2old(L, &mut (*g).tobefnz);
    (*g).gckind = 1 as i32 as lu_byte;
    (*g).lastatomic = 0 as lu_mem;
    (*g).GCestimate = ((*g).totalbytes + (*g).GCdebt) as lu_mem;
    finishgencycle(L, g);
}
unsafe extern "C-unwind" fn setminordebt(mut g: *mut global_State) {
    luaE_setdebt(
        g,
        -((((*g).totalbytes + (*g).GCdebt) as lu_mem / 100 as lu_mem) as l_mem
            * (*g).genminormul as l_mem),
    );
}
unsafe extern "C-unwind" fn entergen(mut L: *mut lua_State, mut g: *mut global_State) -> lu_mem {
    let mut numobjs: lu_mem = 0;
    luaC_runtilstate(L, (1 as i32) << 8 as i32);
    luaC_runtilstate(L, (1 as i32) << 0);
    numobjs = atomic(L);
    atomic2gen(L, g);
    setminordebt(g);
    return numobjs;
}
unsafe extern "C-unwind" fn enterinc(mut g: *mut global_State) {
    whitelist(g, (*g).allgc);
    (*g).survival = 0 as *mut GCObject;
    (*g).old1 = (*g).survival;
    (*g).reallyold = (*g).old1;
    whitelist(g, (*g).finobj);
    whitelist(g, (*g).tobefnz);
    (*g).finobjsur = 0 as *mut GCObject;
    (*g).finobjold1 = (*g).finobjsur;
    (*g).finobjrold = (*g).finobjold1;
    (*g).gcstate = 8 as i32 as lu_byte;
    (*g).gckind = 0 as lu_byte;
    (*g).lastatomic = 0 as lu_mem;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_changemode(mut L: *mut lua_State, mut newmode: i32) {
    let mut g: *mut global_State = (*L).l_G;
    if newmode != (*g).gckind as i32 {
        if newmode == 1 as i32 {
            entergen(L, g);
        } else {
            enterinc(g);
        }
    }
    (*g).lastatomic = 0 as lu_mem;
}
unsafe extern "C-unwind" fn fullgen(mut L: *mut lua_State, mut g: *mut global_State) -> lu_mem {
    enterinc(g);
    return entergen(L, g);
}
unsafe extern "C-unwind" fn stepgenfull(mut L: *mut lua_State, mut g: *mut global_State) {
    let mut newatomic: lu_mem = 0;
    let mut lastatomic: lu_mem = (*g).lastatomic;
    if (*g).gckind as i32 == 1 as i32 {
        enterinc(g);
    }
    luaC_runtilstate(L, (1 as i32) << 0);
    newatomic = atomic(L);
    if newatomic < lastatomic.wrapping_add(lastatomic >> 3 as i32) {
        atomic2gen(L, g);
        setminordebt(g);
    } else {
        (*g).GCestimate = ((*g).totalbytes + (*g).GCdebt) as lu_mem;
        entersweep(L);
        luaC_runtilstate(L, (1 as i32) << 8 as i32);
        setpause(g);
        (*g).lastatomic = newatomic;
    };
}
unsafe extern "C-unwind" fn genstep(mut L: *mut lua_State, mut g: *mut global_State) {
    if (*g).lastatomic != 0 as lu_mem {
        stepgenfull(L, g);
    } else {
        let mut majorbase: lu_mem = (*g).GCestimate;
        let mut majorinc: lu_mem =
            majorbase / 100 as lu_mem * ((*g).genmajormul as i32 * 4 as i32) as lu_mem;
        if (*g).GCdebt > 0 as l_mem
            && ((*g).totalbytes + (*g).GCdebt) as lu_mem > majorbase.wrapping_add(majorinc)
        {
            let mut numobjs: lu_mem = fullgen(L, g);
            if !((((*g).totalbytes + (*g).GCdebt) as lu_mem)
                < majorbase.wrapping_add(majorinc / 2 as i32 as lu_mem))
            {
                (*g).lastatomic = numobjs;
                setpause(g);
            }
        } else {
            youngcollection(L, g);
            setminordebt(g);
            (*g).GCestimate = majorbase;
        }
    };
}
unsafe extern "C-unwind" fn entersweep(mut L: *mut lua_State) {
    let mut g: *mut global_State = (*L).l_G;
    (*g).gcstate = 3 as i32 as lu_byte;
    (*g).sweepgc = sweeptolive(L, &mut (*g).allgc);
}
unsafe extern "C-unwind" fn deletelist(
    mut L: *mut lua_State,
    mut p: *mut GCObject,
    mut limit: *mut GCObject,
) {
    while p != limit {
        let mut next: *mut GCObject = (*p).next;
        freeobj(L, p);
        p = next;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_freeallobjects(mut L: *mut lua_State) {
    let mut g: *mut global_State = (*L).l_G;
    (*g).gcstp = 4 as i32 as lu_byte;
    luaC_changemode(L, 0);
    separatetobefnz(g, 1 as i32);
    callallpendingfinalizers(L);
    deletelist(L, (*g).allgc, &mut (*((*g).mainthread as *mut GCUnion)).gc);
    deletelist(L, (*g).fixedgc, 0 as *mut GCObject);
}
unsafe extern "C-unwind" fn atomic(mut L: *mut lua_State) -> lu_mem {
    let mut g: *mut global_State = (*L).l_G;
    let mut work: lu_mem = 0 as lu_mem;
    let mut origweak: *mut GCObject = 0 as *mut GCObject;
    let mut origall: *mut GCObject = 0 as *mut GCObject;
    let mut grayagain: *mut GCObject = (*g).grayagain;
    (*g).grayagain = 0 as *mut GCObject;
    (*g).gcstate = 2 as i32 as lu_byte;
    if (*L).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0 {
        reallymarkobject(g, &mut (*(L as *mut GCUnion)).gc);
    }
    if (*g).l_registry.tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*g).l_registry.tt_ as i32 & 0x3f as i32 == (*(*g).l_registry.value_.gc).tt as i32
            && (((*g).mainthread).is_null()
                || (*(*g).l_registry.value_.gc).marked as i32
                    & ((*(*(*g).mainthread).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    if (*g).l_registry.tt_ as i32 & (1 as i32) << 6 as i32 != 0
        && (*(*g).l_registry.value_.gc).marked as i32
            & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
            != 0
    {
        reallymarkobject(g, (*g).l_registry.value_.gc);
    }
    markmt(g);
    work = work.wrapping_add(propagateall(g));
    work = work.wrapping_add(remarkupvals(g) as lu_mem);
    work = work.wrapping_add(propagateall(g));
    (*g).gray = grayagain;
    work = work.wrapping_add(propagateall(g));
    convergeephemerons(g);
    clearbyvalues(g, (*g).weak, 0 as *mut GCObject);
    clearbyvalues(g, (*g).allweak, 0 as *mut GCObject);
    origweak = (*g).weak;
    origall = (*g).allweak;
    separatetobefnz(g, 0);
    work = work.wrapping_add(markbeingfnz(g));
    work = work.wrapping_add(propagateall(g));
    convergeephemerons(g);
    clearbykeys(g, (*g).ephemeron);
    clearbykeys(g, (*g).allweak);
    clearbyvalues(g, (*g).weak, origweak);
    clearbyvalues(g, (*g).allweak, origall);
    luaS_clearcache(g);
    (*g).currentwhite =
        ((*g).currentwhite as i32 ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)) as lu_byte;
    return work;
}
unsafe extern "C-unwind" fn sweepstep(
    mut L: *mut lua_State,
    mut g: *mut global_State,
    mut nextstate: i32,
    mut nextlist: *mut *mut GCObject,
) -> i32 {
    if !((*g).sweepgc).is_null() {
        let mut olddebt: l_mem = (*g).GCdebt;
        let mut count: i32 = 0;
        (*g).sweepgc = sweeplist(L, (*g).sweepgc, 100, &mut count);
        (*g).GCestimate = ((*g).GCestimate).wrapping_add(((*g).GCdebt - olddebt) as lu_mem);
        return count;
    } else {
        (*g).gcstate = nextstate as lu_byte;
        (*g).sweepgc = nextlist;
        return 0;
    };
}
unsafe extern "C-unwind" fn singlestep(mut L: *mut lua_State) -> lu_mem {
    let mut g: *mut global_State = (*L).l_G;
    let mut work: lu_mem = 0;
    (*g).gcstopem = 1 as i32 as lu_byte;
    match (*g).gcstate as i32 {
        8 => {
            restartcollection(g);
            (*g).gcstate = 0 as lu_byte;
            work = 1 as i32 as lu_mem;
        }
        0 => {
            if ((*g).gray).is_null() {
                (*g).gcstate = 1 as i32 as lu_byte;
                work = 0 as lu_mem;
            } else {
                work = propagatemark(g);
            }
        }
        1 => {
            work = atomic(L);
            entersweep(L);
            (*g).GCestimate = ((*g).totalbytes + (*g).GCdebt) as lu_mem;
        }
        3 => {
            work = sweepstep(L, g, 4 as i32, &mut (*g).finobj) as lu_mem;
        }
        4 => {
            work = sweepstep(L, g, 5 as i32, &mut (*g).tobefnz) as lu_mem;
        }
        5 => {
            work = sweepstep(L, g, 6 as i32, 0 as *mut *mut GCObject) as lu_mem;
        }
        6 => {
            checkSizes(L, g);
            (*g).gcstate = 7 as i32 as lu_byte;
            work = 0 as lu_mem;
        }
        7 => {
            if !((*g).tobefnz).is_null() && (*g).gcemergency == 0 {
                (*g).gcstopem = 0 as lu_byte;
                work = (runafewfinalizers(L, 10) * 50) as lu_mem;
            } else {
                (*g).gcstate = 8 as i32 as lu_byte;
                work = 0 as lu_mem;
            }
        }
        _ => return 0 as lu_mem,
    }
    (*g).gcstopem = 0 as lu_byte;
    return work;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_runtilstate(mut L: *mut lua_State, mut statesmask: i32) {
    let mut g: *mut global_State = (*L).l_G;
    while statesmask & (1 as i32) << (*g).gcstate as i32 == 0 {
        singlestep(L);
    }
}
unsafe extern "C-unwind" fn incstep(mut L: *mut lua_State, mut g: *mut global_State) {
    let mut stepmul: i32 = (*g).gcstepmul as i32 * 4 as i32 | 1 as i32;
    let mut debt: l_mem = ((*g).GCdebt as usize)
        .wrapping_div(::core::mem::size_of::<TValue>() as usize)
        .wrapping_mul(stepmul as usize) as l_mem;
    let mut stepsize: l_mem = (if (*g).gcstepsize as usize
        <= (::core::mem::size_of::<l_mem>() as usize)
            .wrapping_mul(8)
            .wrapping_sub(2)
    {
        (((1 as i32 as l_mem) << (*g).gcstepsize as i32) as usize)
            .wrapping_div(::core::mem::size_of::<TValue>() as usize)
            .wrapping_mul(stepmul as usize)
    } else {
        (!(0 as lu_mem) >> 1 as i32) as l_mem as usize
    }) as l_mem;
    loop {
        let mut work: lu_mem = singlestep(L);
        debt = (debt as lu_mem).wrapping_sub(work) as l_mem as l_mem;
        if !(debt > -stepsize && (*g).gcstate as i32 != 8 as i32) {
            break;
        }
    }
    if (*g).gcstate as i32 == 8 as i32 {
        setpause(g);
    } else {
        debt = ((debt / stepmul as l_mem) as usize)
            .wrapping_mul(::core::mem::size_of::<TValue>() as usize) as l_mem;
        luaE_setdebt(g, debt);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_step(mut L: *mut lua_State) {
    let mut g: *mut global_State = (*L).l_G;
    if !((*g).gcstp as i32 == 0) {
        luaE_setdebt(g, -(2000) as l_mem);
    } else if (*g).gckind as i32 == 1 as i32 || (*g).lastatomic != 0 as lu_mem {
        genstep(L, g);
    } else {
        incstep(L, g);
    };
}
unsafe extern "C-unwind" fn fullinc(mut L: *mut lua_State, mut g: *mut global_State) {
    if (*g).gcstate as i32 <= 2 as i32 {
        entersweep(L);
    }
    luaC_runtilstate(L, (1 as i32) << 8 as i32);
    luaC_runtilstate(L, (1 as i32) << 0);
    (*g).gcstate = 1 as i32 as lu_byte;
    luaC_runtilstate(L, (1 as i32) << 7 as i32);
    luaC_runtilstate(L, (1 as i32) << 8 as i32);
    setpause(g);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaC_fullgc(mut L: *mut lua_State, mut isemergency: i32) {
    let mut g: *mut global_State = (*L).l_G;
    (*g).gcemergency = isemergency as lu_byte;
    if (*g).gckind as i32 == 0 {
        fullinc(L, g);
    } else {
        fullgen(L, g);
    }
    (*g).gcemergency = 0 as lu_byte;
}
static mut luaX_tokens: [*const std::ffi::c_char; 37] = [
    c"and".as_ptr(),
    c"break".as_ptr(),
    c"do".as_ptr(),
    c"else".as_ptr(),
    c"elseif".as_ptr(),
    c"end".as_ptr(),
    c"false".as_ptr(),
    c"for".as_ptr(),
    c"function".as_ptr(),
    c"goto".as_ptr(),
    c"if".as_ptr(),
    c"in".as_ptr(),
    c"local".as_ptr(),
    c"nil".as_ptr(),
    c"not".as_ptr(),
    c"or".as_ptr(),
    c"repeat".as_ptr(),
    c"return".as_ptr(),
    c"then".as_ptr(),
    c"true".as_ptr(),
    c"until".as_ptr(),
    c"while".as_ptr(),
    c"//".as_ptr(),
    c"..".as_ptr(),
    c"...".as_ptr(),
    c"==".as_ptr(),
    c">=".as_ptr(),
    c"<=".as_ptr(),
    c"~=".as_ptr(),
    c"<<".as_ptr(),
    c">>".as_ptr(),
    c"::".as_ptr(),
    c"<eof>".as_ptr(),
    c"<number>".as_ptr(),
    c"<integer>".as_ptr(),
    c"<name>".as_ptr(),
    c"<string>".as_ptr(),
];
unsafe extern "C-unwind" fn save(mut ls: *mut LexState, mut c: i32) {
    let mut b: *mut Mbuffer = (*ls).buff;
    if ((*b).n).wrapping_add(1 as i32 as size_t) > (*b).buffsize {
        let mut newsize: size_t = 0;
        if (*b).buffsize
            >= (if (::core::mem::size_of::<size_t>() as usize)
                < ::core::mem::size_of::<lua_Integer>() as usize
            {
                !(0 as size_t)
            } else {
                9223372036854775807 as std::ffi::c_longlong as size_t
            }) / 2 as i32 as size_t
        {
            lexerror(ls, c"lexical element too long".as_ptr(), 0);
        }
        newsize = (*b).buffsize * 2 as i32 as size_t;
        (*b).buffer = luaM_saferealloc_(
            (*ls).L,
            (*b).buffer as *mut c_void,
            ((*b).buffsize).wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
            newsize.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
        ) as *mut std::ffi::c_char;
        (*b).buffsize = newsize;
    }
    let fresh11 = (*b).n;
    (*b).n = ((*b).n).wrapping_add(1);
    *((*b).buffer).offset(fresh11 as isize) = c as std::ffi::c_char;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaX_init(mut L: *mut lua_State) {
    let mut i: i32 = 0;
    let mut e: *mut TString = luaS_newlstr(
        L,
        c"_ENV".as_ptr(),
        (::core::mem::size_of::<[std::ffi::c_char; 5]>() as usize)
            .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
            .wrapping_sub(1),
    );
    luaC_fix(L, &mut (*(e as *mut GCUnion)).gc);
    i = 0;
    while i < TK_WHILE as i32 - (127 as i32 * 2 as i32 + 1 as i32 + 1 as i32) + 1 as i32 {
        let mut ts: *mut TString = luaS_new(L, luaX_tokens[i as usize]);
        luaC_fix(L, &mut (*(ts as *mut GCUnion)).gc);
        (*ts).extra = (i + 1 as i32) as lu_byte;
        i += 1;
        i;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaX_token2str(
    mut ls: *mut LexState,
    mut token: i32,
) -> *const std::ffi::c_char {
    if token < 127 as i32 * 2 as i32 + 1 as i32 + 1 as i32 {
        if luai_ctype_[(token + 1 as i32) as usize] as i32 & (1 as i32) << 2 as i32 != 0 {
            return luaO_pushfstring((*ls).L, c"'%c'".as_ptr(), token);
        } else {
            return luaO_pushfstring((*ls).L, c"'<\\%d>'".as_ptr(), token);
        }
    } else {
        let mut s: *const std::ffi::c_char =
            luaX_tokens[(token - (127 as i32 * 2 as i32 + 1 as i32 + 1 as i32)) as usize];
        if token < TK_EOS as i32 {
            return luaO_pushfstring((*ls).L, c"'%s'".as_ptr(), s);
        } else {
            return s;
        }
    };
}
unsafe extern "C-unwind" fn txtToken(
    mut ls: *mut LexState,
    mut token: i32,
) -> *const std::ffi::c_char {
    match token {
        291 | 292 | 289 | 290 => {
            save(ls, '\0' as i32);
            return luaO_pushfstring((*ls).L, c"'%s'".as_ptr(), (*(*ls).buff).buffer);
        }
        _ => return luaX_token2str(ls, token),
    };
}
unsafe extern "C-unwind" fn lexerror(
    mut ls: *mut LexState,
    mut msg: *const std::ffi::c_char,
    mut token: i32,
) -> ! {
    msg = luaG_addinfo((*ls).L, msg, (*ls).source, (*ls).linenumber);
    if token != 0 {
        luaO_pushfstring((*ls).L, c"%s near %s".as_ptr(), msg, txtToken(ls, token));
    }
    luaD_throw((*ls).L, 3 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaX_syntaxerror(
    mut ls: *mut LexState,
    mut msg: *const std::ffi::c_char,
) -> ! {
    lexerror(ls, msg, (*ls).t.token);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaX_newstring(
    mut ls: *mut LexState,
    mut str: *const std::ffi::c_char,
    mut l: size_t,
) -> *mut TString {
    let mut L: *mut lua_State = (*ls).L;
    let mut ts: *mut TString = luaS_newlstr(L, str, l);
    let mut o: *const TValue = luaH_getstr((*ls).h, ts);
    if !((*o).tt_ as i32 & 0xf as i32 == 0) {
        ts = &mut (*((*(o as *mut Node)).u.key_val.gc as *mut GCUnion)).ts;
    } else {
        let fresh12 = (*L).top.p;
        (*L).top.p = ((*L).top.p).offset(1);
        let mut stv: *mut TValue = &mut (*fresh12).val;
        let mut io: *mut TValue = stv;
        let mut x_: *mut TString = ts;
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        luaH_finishset(L, (*ls).h, stv, o, stv);
        if (*(*L).l_G).GCdebt > 0 as l_mem {
            luaC_step(L);
        }
        (*L).top.p = ((*L).top.p).offset(-1);
        (*L).top.p;
    }
    return ts;
}
unsafe extern "C-unwind" fn inclinenumber(mut ls: *mut LexState) {
    let mut old: i32 = (*ls).current;
    let fresh13 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = if fresh13 > 0 as size_t {
        let fresh14 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh14 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    };
    if ((*ls).current == '\n' as i32 || (*ls).current == '\r' as i32) && (*ls).current != old {
        let fresh15 = (*(*ls).z).n;
        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
        (*ls).current = if fresh15 > 0 as size_t {
            let fresh16 = (*(*ls).z).p;
            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
            *fresh16 as u8 as i32
        } else {
            luaZ_fill((*ls).z)
        };
    }
    (*ls).linenumber += 1;
    if (*ls).linenumber >= 2147483647 as i32 {
        lexerror(ls, c"chunk has too many lines".as_ptr(), 0);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaX_setinput(
    mut L: *mut lua_State,
    mut ls: *mut LexState,
    mut z: *mut ZIO,
    mut source: *mut TString,
    mut firstchar: i32,
) {
    (*ls).t.token = 0;
    (*ls).L = L;
    (*ls).current = firstchar;
    (*ls).lookahead.token = TK_EOS as i32;
    (*ls).z = z;
    (*ls).fs = 0 as *mut FuncState;
    (*ls).linenumber = 1 as i32;
    (*ls).lastline = 1 as i32;
    (*ls).source = source;
    (*ls).envn = luaS_newlstr(
        L,
        c"_ENV".as_ptr(),
        (::core::mem::size_of::<[std::ffi::c_char; 5]>() as usize)
            .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
            .wrapping_sub(1),
    );
    (*(*ls).buff).buffer = luaM_saferealloc_(
        (*ls).L,
        (*(*ls).buff).buffer as *mut c_void,
        ((*(*ls).buff).buffsize).wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
        (32usize).wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
    ) as *mut std::ffi::c_char;
    (*(*ls).buff).buffsize = 32 as i32 as size_t;
}
unsafe extern "C-unwind" fn check_next1(mut ls: *mut LexState, mut c: i32) -> i32 {
    if (*ls).current == c {
        let fresh17 = (*(*ls).z).n;
        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
        (*ls).current = if fresh17 > 0 as size_t {
            let fresh18 = (*(*ls).z).p;
            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
            *fresh18 as u8 as i32
        } else {
            luaZ_fill((*ls).z)
        };
        return 1 as i32;
    } else {
        return 0;
    };
}
unsafe extern "C-unwind" fn check_next2(
    mut ls: *mut LexState,
    mut set: *const std::ffi::c_char,
) -> i32 {
    if (*ls).current == *set.offset(0 as isize) as i32 || (*ls).current == *set.offset(1) as i32 {
        save(ls, (*ls).current);
        let fresh19 = (*(*ls).z).n;
        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
        (*ls).current = (if fresh19 > 0 as size_t {
            let fresh20 = (*(*ls).z).p;
            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
            *fresh20 as u8 as i32
        } else {
            luaZ_fill((*ls).z)
        });
        return 1 as i32;
    } else {
        return 0;
    };
}
unsafe extern "C-unwind" fn read_numeral(mut ls: *mut LexState, mut seminfo: *mut SemInfo) -> i32 {
    let mut obj: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut expo: *const std::ffi::c_char = c"Ee".as_ptr();
    let mut first: i32 = (*ls).current;
    save(ls, (*ls).current);
    let fresh21 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = (if fresh21 > 0 as size_t {
        let fresh22 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh22 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    });
    if first == '0' as i32 && check_next2(ls, c"xX".as_ptr()) != 0 {
        expo = c"Pp".as_ptr();
    }
    loop {
        if check_next2(ls, expo) != 0 {
            check_next2(ls, c"-+".as_ptr());
        } else {
            if !(luai_ctype_[((*ls).current + 1 as i32) as usize] as i32 & (1 as i32) << 4 as i32
                != 0
                || (*ls).current == '.' as i32)
            {
                break;
            }
            save(ls, (*ls).current);
            let fresh23 = (*(*ls).z).n;
            (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
            (*ls).current = (if fresh23 > 0 as size_t {
                let fresh24 = (*(*ls).z).p;
                (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                *fresh24 as u8 as i32
            } else {
                luaZ_fill((*ls).z)
            });
        }
    }
    if luai_ctype_[((*ls).current + 1 as i32) as usize] as i32 & (1 as i32) << 0 != 0 {
        save(ls, (*ls).current);
        let fresh25 = (*(*ls).z).n;
        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
        (*ls).current = (if fresh25 > 0 as size_t {
            let fresh26 = (*(*ls).z).p;
            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
            *fresh26 as u8 as i32
        } else {
            luaZ_fill((*ls).z)
        });
    }
    save(ls, '\0' as i32);
    if luaO_str2num((*(*ls).buff).buffer, &mut obj) == 0 as size_t {
        lexerror(ls, c"malformed number".as_ptr(), TK_FLT as i32);
    }
    if obj.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        (*seminfo).i = obj.value_.i;
        return TK_INT as i32;
    } else {
        (*seminfo).r = obj.value_.n;
        return TK_FLT as i32;
    };
}
unsafe extern "C-unwind" fn skip_sep(mut ls: *mut LexState) -> size_t {
    let mut count: size_t = 0 as size_t;
    let mut s: i32 = (*ls).current;
    save(ls, (*ls).current);
    let fresh27 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = (if fresh27 > 0 as size_t {
        let fresh28 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh28 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    });
    while (*ls).current == '=' as i32 {
        save(ls, (*ls).current);
        let fresh29 = (*(*ls).z).n;
        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
        (*ls).current = (if fresh29 > 0 as size_t {
            let fresh30 = (*(*ls).z).p;
            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
            *fresh30 as u8 as i32
        } else {
            luaZ_fill((*ls).z)
        });
        count = count.wrapping_add(1);
        count;
    }
    return if (*ls).current == s {
        count.wrapping_add(2 as i32 as size_t)
    } else {
        (if count == 0 as size_t { 1 as i32 } else { 0 }) as size_t
    };
}
unsafe extern "C-unwind" fn read_long_string(
    mut ls: *mut LexState,
    mut seminfo: *mut SemInfo,
    mut sep: size_t,
) {
    let mut line: i32 = (*ls).linenumber;
    save(ls, (*ls).current);
    let fresh31 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = (if fresh31 > 0 as size_t {
        let fresh32 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh32 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    });
    if (*ls).current == '\n' as i32 || (*ls).current == '\r' as i32 {
        inclinenumber(ls);
    }
    loop {
        match (*ls).current {
            -1 => {
                let mut what: *const std::ffi::c_char = if !seminfo.is_null() {
                    c"string".as_ptr()
                } else {
                    c"comment".as_ptr()
                };
                let mut msg: *const std::ffi::c_char = luaO_pushfstring(
                    (*ls).L,
                    c"unfinished long %s (starting at line %d)".as_ptr(),
                    what,
                    line,
                );
                lexerror(ls, msg, TK_EOS as i32);
            }
            93 => {
                if !(skip_sep(ls) == sep) {
                    continue;
                }
                save(ls, (*ls).current);
                let fresh33 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = (if fresh33 > 0 as size_t {
                    let fresh34 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh34 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                });
                break;
            }
            10 | 13 => {
                save(ls, '\n' as i32);
                inclinenumber(ls);
                if seminfo.is_null() {
                    (*(*ls).buff).n = 0 as size_t;
                }
            }
            _ => {
                if !seminfo.is_null() {
                    save(ls, (*ls).current);
                    let fresh35 = (*(*ls).z).n;
                    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                    (*ls).current = (if fresh35 > 0 as size_t {
                        let fresh36 = (*(*ls).z).p;
                        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                        *fresh36 as u8 as i32
                    } else {
                        luaZ_fill((*ls).z)
                    });
                } else {
                    let fresh37 = (*(*ls).z).n;
                    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                    (*ls).current = if fresh37 > 0 as size_t {
                        let fresh38 = (*(*ls).z).p;
                        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                        *fresh38 as u8 as i32
                    } else {
                        luaZ_fill((*ls).z)
                    };
                }
            }
        }
    }
    if !seminfo.is_null() {
        (*seminfo).ts = luaX_newstring(
            ls,
            ((*(*ls).buff).buffer).offset(sep as isize),
            ((*(*ls).buff).n).wrapping_sub(2 as i32 as size_t * sep),
        );
    }
}
unsafe extern "C-unwind" fn esccheck(
    mut ls: *mut LexState,
    mut c: i32,
    mut msg: *const std::ffi::c_char,
) {
    if c == 0 {
        if (*ls).current != -(1 as i32) {
            save(ls, (*ls).current);
            let fresh39 = (*(*ls).z).n;
            (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
            (*ls).current = (if fresh39 > 0 as size_t {
                let fresh40 = (*(*ls).z).p;
                (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                *fresh40 as u8 as i32
            } else {
                luaZ_fill((*ls).z)
            });
        }
        lexerror(ls, msg, TK_STRING as i32);
    }
}
unsafe extern "C-unwind" fn gethexa(mut ls: *mut LexState) -> i32 {
    save(ls, (*ls).current);
    let fresh41 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = (if fresh41 > 0 as size_t {
        let fresh42 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh42 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    });
    esccheck(
        ls,
        luai_ctype_[((*ls).current + 1 as i32) as usize] as i32 & (1 as i32) << 4 as i32,
        c"hexadecimal digit expected".as_ptr(),
    );
    return luaO_hexavalue((*ls).current);
}
unsafe extern "C-unwind" fn readhexaesc(mut ls: *mut LexState) -> i32 {
    let mut r: i32 = gethexa(ls);
    r = (r << 4 as i32) + gethexa(ls);
    (*(*ls).buff).n = ((*(*ls).buff).n).wrapping_sub(2 as i32 as size_t);
    return r;
}
unsafe extern "C-unwind" fn readutf8esc(mut ls: *mut LexState) -> usize {
    let mut r: usize = 0;
    let mut i: i32 = 4 as i32;
    save(ls, (*ls).current);
    let fresh43 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = (if fresh43 > 0 as size_t {
        let fresh44 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh44 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    });
    esccheck(
        ls,
        ((*ls).current == '{' as i32) as i32,
        c"missing '{'".as_ptr(),
    );
    r = gethexa(ls) as usize;
    loop {
        save(ls, (*ls).current);
        let fresh45 = (*(*ls).z).n;
        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
        (*ls).current = (if fresh45 > 0 as size_t {
            let fresh46 = (*(*ls).z).p;
            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
            *fresh46 as u8 as i32
        } else {
            luaZ_fill((*ls).z)
        });
        if !(luai_ctype_[((*ls).current + 1 as i32) as usize] as i32 & (1 as i32) << 4 as i32 != 0)
        {
            break;
        }
        i += 1;
        i;
        esccheck(
            ls,
            (r <= (0x7fffffff as u32 >> 4 as i32) as usize) as i32,
            c"UTF-8 value too large".as_ptr(),
        );
        r = (r << 4 as i32).wrapping_add(luaO_hexavalue((*ls).current) as usize);
    }
    esccheck(
        ls,
        ((*ls).current == '}' as i32) as i32,
        c"missing '}'".as_ptr(),
    );
    let fresh47 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = if fresh47 > 0 as size_t {
        let fresh48 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh48 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    };
    (*(*ls).buff).n = ((*(*ls).buff).n).wrapping_sub(i as size_t);
    return r;
}
unsafe extern "C-unwind" fn utf8esc(mut ls: *mut LexState) {
    let mut buff: [std::ffi::c_char; 8] = [0; 8];
    let mut n: i32 = luaO_utf8esc(buff.as_mut_ptr(), readutf8esc(ls));
    while n > 0 {
        save(ls, buff[(8 as i32 - n) as usize] as i32);
        n -= 1;
        n;
    }
}
unsafe extern "C-unwind" fn readdecesc(mut ls: *mut LexState) -> i32 {
    let mut i: i32 = 0;
    let mut r: i32 = 0;
    i = 0;
    while i < 3 as i32
        && luai_ctype_[((*ls).current + 1 as i32) as usize] as i32 & (1 as i32) << 1 as i32 != 0
    {
        r = 10 * r + (*ls).current - '0' as i32;
        save(ls, (*ls).current);
        let fresh49 = (*(*ls).z).n;
        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
        (*ls).current = (if fresh49 > 0 as size_t {
            let fresh50 = (*(*ls).z).p;
            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
            *fresh50 as u8 as i32
        } else {
            luaZ_fill((*ls).z)
        });
        i += 1;
        i;
    }
    esccheck(
        ls,
        (r <= 127 as i32 * 2 as i32 + 1 as i32) as i32,
        c"decimal escape too large".as_ptr(),
    );
    (*(*ls).buff).n = ((*(*ls).buff).n).wrapping_sub(i as size_t);
    return r;
}
unsafe extern "C-unwind" fn read_string(
    mut ls: *mut LexState,
    mut del: i32,
    mut seminfo: *mut SemInfo,
) {
    let mut current_block: u64;
    save(ls, (*ls).current);
    let fresh51 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = (if fresh51 > 0 as size_t {
        let fresh52 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh52 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    });
    while (*ls).current != del {
        match (*ls).current {
            -1 => {
                lexerror(ls, c"unfinished string".as_ptr(), TK_EOS as i32);
            }
            10 | 13 => {
                lexerror(ls, c"unfinished string".as_ptr(), TK_STRING as i32);
            }
            92 => {
                let mut c: i32 = 0;
                save(ls, (*ls).current);
                let fresh53 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = (if fresh53 > 0 as size_t {
                    let fresh54 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh54 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                });
                match (*ls).current {
                    97 => {
                        c = '\u{7}' as i32;
                        current_block = 8623330865402145409;
                    }
                    98 => {
                        c = '\u{8}' as i32;
                        current_block = 8623330865402145409;
                    }
                    102 => {
                        c = '\u{c}' as i32;
                        current_block = 8623330865402145409;
                    }
                    110 => {
                        c = '\n' as i32;
                        current_block = 8623330865402145409;
                    }
                    114 => {
                        c = '\r' as i32;
                        current_block = 8623330865402145409;
                    }
                    116 => {
                        c = '\t' as i32;
                        current_block = 8623330865402145409;
                    }
                    118 => {
                        c = '\u{b}' as i32;
                        current_block = 8623330865402145409;
                    }
                    120 => {
                        c = readhexaesc(ls);
                        current_block = 8623330865402145409;
                    }
                    117 => {
                        utf8esc(ls);
                        continue;
                    }
                    10 | 13 => {
                        inclinenumber(ls);
                        c = '\n' as i32;
                        current_block = 14094486417619109786;
                    }
                    92 | 34 | 39 => {
                        c = (*ls).current;
                        current_block = 8623330865402145409;
                    }
                    -1 => {
                        continue;
                    }
                    122 => {
                        (*(*ls).buff).n = ((*(*ls).buff).n).wrapping_sub(1 as i32 as size_t);
                        let fresh55 = (*(*ls).z).n;
                        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                        (*ls).current = if fresh55 > 0 as size_t {
                            let fresh56 = (*(*ls).z).p;
                            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                            *fresh56 as u8 as i32
                        } else {
                            luaZ_fill((*ls).z)
                        };
                        while luai_ctype_[((*ls).current + 1 as i32) as usize] as i32
                            & (1 as i32) << 3 as i32
                            != 0
                        {
                            if (*ls).current == '\n' as i32 || (*ls).current == '\r' as i32 {
                                inclinenumber(ls);
                            } else {
                                let fresh57 = (*(*ls).z).n;
                                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                                (*ls).current = if fresh57 > 0 as size_t {
                                    let fresh58 = (*(*ls).z).p;
                                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                                    *fresh58 as u8 as i32
                                } else {
                                    luaZ_fill((*ls).z)
                                };
                            }
                        }
                        continue;
                    }
                    _ => {
                        esccheck(
                            ls,
                            luai_ctype_[((*ls).current + 1 as i32) as usize] as i32
                                & (1 as i32) << 1 as i32,
                            c"invalid escape sequence".as_ptr(),
                        );
                        c = readdecesc(ls);
                        current_block = 14094486417619109786;
                    }
                }
                match current_block {
                    8623330865402145409 => {
                        let fresh59 = (*(*ls).z).n;
                        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                        (*ls).current = if fresh59 > 0 as size_t {
                            let fresh60 = (*(*ls).z).p;
                            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                            *fresh60 as u8 as i32
                        } else {
                            luaZ_fill((*ls).z)
                        };
                    }
                    _ => {}
                }
                (*(*ls).buff).n = ((*(*ls).buff).n).wrapping_sub(1 as i32 as size_t);
                save(ls, c);
            }
            _ => {
                save(ls, (*ls).current);
                let fresh61 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = (if fresh61 > 0 as size_t {
                    let fresh62 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh62 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                });
            }
        }
    }
    save(ls, (*ls).current);
    let fresh63 = (*(*ls).z).n;
    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
    (*ls).current = (if fresh63 > 0 as size_t {
        let fresh64 = (*(*ls).z).p;
        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
        *fresh64 as u8 as i32
    } else {
        luaZ_fill((*ls).z)
    });
    (*seminfo).ts = luaX_newstring(
        ls,
        ((*(*ls).buff).buffer).offset(1),
        ((*(*ls).buff).n).wrapping_sub(2 as i32 as size_t),
    );
}
unsafe extern "C-unwind" fn llex(mut ls: *mut LexState, mut seminfo: *mut SemInfo) -> i32 {
    (*(*ls).buff).n = 0 as size_t;
    loop {
        let mut current_block_85: u64;
        match (*ls).current {
            10 | 13 => {
                inclinenumber(ls);
            }
            32 | 12 | 9 | 11 => {
                let fresh65 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh65 > 0 as size_t {
                    let fresh66 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh66 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
            }
            45 => {
                let fresh67 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh67 > 0 as size_t {
                    let fresh68 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh68 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if (*ls).current != '-' as i32 {
                    return '-' as i32;
                }
                let fresh69 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh69 > 0 as size_t {
                    let fresh70 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh70 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if (*ls).current == '[' as i32 {
                    let mut sep: size_t = skip_sep(ls);
                    (*(*ls).buff).n = 0 as size_t;
                    if sep >= 2 as i32 as size_t {
                        read_long_string(ls, 0 as *mut SemInfo, sep);
                        (*(*ls).buff).n = 0 as size_t;
                        current_block_85 = 10512632378975961025;
                    } else {
                        current_block_85 = 3512920355445576850;
                    }
                } else {
                    current_block_85 = 3512920355445576850;
                }
                match current_block_85 {
                    10512632378975961025 => {}
                    _ => {
                        while !((*ls).current == '\n' as i32 || (*ls).current == '\r' as i32)
                            && (*ls).current != -(1 as i32)
                        {
                            let fresh71 = (*(*ls).z).n;
                            (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                            (*ls).current = if fresh71 > 0 as size_t {
                                let fresh72 = (*(*ls).z).p;
                                (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                                *fresh72 as u8 as i32
                            } else {
                                luaZ_fill((*ls).z)
                            };
                        }
                    }
                }
            }
            91 => {
                let mut sep_0: size_t = skip_sep(ls);
                if sep_0 >= 2 as i32 as size_t {
                    read_long_string(ls, seminfo, sep_0);
                    return TK_STRING as i32;
                } else if sep_0 == 0 as size_t {
                    lexerror(
                        ls,
                        c"invalid long string delimiter".as_ptr(),
                        TK_STRING as i32,
                    );
                }
                return '[' as i32;
            }
            61 => {
                let fresh73 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh73 > 0 as size_t {
                    let fresh74 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh74 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if check_next1(ls, '=' as i32) != 0 {
                    return TK_EQ as i32;
                } else {
                    return '=' as i32;
                }
            }
            60 => {
                let fresh75 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh75 > 0 as size_t {
                    let fresh76 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh76 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if check_next1(ls, '=' as i32) != 0 {
                    return TK_LE as i32;
                } else if check_next1(ls, '<' as i32) != 0 {
                    return TK_SHL as i32;
                } else {
                    return '<' as i32;
                }
            }
            62 => {
                let fresh77 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh77 > 0 as size_t {
                    let fresh78 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh78 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if check_next1(ls, '=' as i32) != 0 {
                    return TK_GE as i32;
                } else if check_next1(ls, '>' as i32) != 0 {
                    return TK_SHR as i32;
                } else {
                    return '>' as i32;
                }
            }
            47 => {
                let fresh79 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh79 > 0 as size_t {
                    let fresh80 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh80 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if check_next1(ls, '/' as i32) != 0 {
                    return TK_IDIV as i32;
                } else {
                    return '/' as i32;
                }
            }
            126 => {
                let fresh81 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh81 > 0 as size_t {
                    let fresh82 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh82 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if check_next1(ls, '=' as i32) != 0 {
                    return TK_NE as i32;
                } else {
                    return '~' as i32;
                }
            }
            58 => {
                let fresh83 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = if fresh83 > 0 as size_t {
                    let fresh84 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh84 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                };
                if check_next1(ls, ':' as i32) != 0 {
                    return TK_DBCOLON as i32;
                } else {
                    return ':' as i32;
                }
            }
            34 | 39 => {
                read_string(ls, (*ls).current, seminfo);
                return TK_STRING as i32;
            }
            46 => {
                save(ls, (*ls).current);
                let fresh85 = (*(*ls).z).n;
                (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                (*ls).current = (if fresh85 > 0 as size_t {
                    let fresh86 = (*(*ls).z).p;
                    (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                    *fresh86 as u8 as i32
                } else {
                    luaZ_fill((*ls).z)
                });
                if check_next1(ls, '.' as i32) != 0 {
                    if check_next1(ls, '.' as i32) != 0 {
                        return TK_DOTS as i32;
                    } else {
                        return TK_CONCAT as i32;
                    }
                } else if luai_ctype_[((*ls).current + 1 as i32) as usize] as i32
                    & (1 as i32) << 1 as i32
                    == 0
                {
                    return '.' as i32;
                } else {
                    return read_numeral(ls, seminfo);
                }
            }
            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {
                return read_numeral(ls, seminfo);
            }
            -1 => return TK_EOS as i32,
            _ => {
                if luai_ctype_[((*ls).current + 1 as i32) as usize] as i32 & (1 as i32) << 0 != 0 {
                    let mut ts: *mut TString = 0 as *mut TString;
                    loop {
                        save(ls, (*ls).current);
                        let fresh87 = (*(*ls).z).n;
                        (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                        (*ls).current = (if fresh87 > 0 as size_t {
                            let fresh88 = (*(*ls).z).p;
                            (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                            *fresh88 as u8 as i32
                        } else {
                            luaZ_fill((*ls).z)
                        });
                        if !(luai_ctype_[((*ls).current + 1 as i32) as usize] as i32
                            & ((1 as i32) << 0 | (1 as i32) << 1 as i32)
                            != 0)
                        {
                            break;
                        }
                    }
                    ts = luaX_newstring(ls, (*(*ls).buff).buffer, (*(*ls).buff).n);
                    (*seminfo).ts = ts;
                    if (*ts).tt as i32 == 4 as i32 | (0) << 4 as i32 && (*ts).extra as i32 > 0 {
                        return (*ts).extra as i32 - 1 as i32
                            + (127 as i32 * 2 as i32 + 1 as i32 + 1 as i32);
                    } else {
                        return TK_NAME as i32;
                    }
                } else {
                    let mut c: i32 = (*ls).current;
                    let fresh89 = (*(*ls).z).n;
                    (*(*ls).z).n = ((*(*ls).z).n).wrapping_sub(1);
                    (*ls).current = if fresh89 > 0 as size_t {
                        let fresh90 = (*(*ls).z).p;
                        (*(*ls).z).p = ((*(*ls).z).p).offset(1);
                        *fresh90 as u8 as i32
                    } else {
                        luaZ_fill((*ls).z)
                    };
                    return c;
                }
            }
        }
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaX_next(mut ls: *mut LexState) {
    (*ls).lastline = (*ls).linenumber;
    if (*ls).lookahead.token != TK_EOS as i32 {
        (*ls).t = (*ls).lookahead;
        (*ls).lookahead.token = TK_EOS as i32;
    } else {
        (*ls).t.token = llex(ls, &mut (*ls).t.seminfo);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaX_lookahead(mut ls: *mut LexState) -> i32 {
    (*ls).lookahead.token = llex(ls, &mut (*ls).lookahead.seminfo);
    return (*ls).lookahead.token;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_semerror(
    mut ls: *mut LexState,
    mut msg: *const std::ffi::c_char,
) -> ! {
    (*ls).t.token = 0;
    luaX_syntaxerror(ls, msg);
}
unsafe extern "C-unwind" fn tonumeral(mut e: *const expdesc, mut v: *mut TValue) -> i32 {
    if (*e).t != (*e).f {
        return 0;
    }
    match (*e).k as u32 {
        6 => {
            if !v.is_null() {
                let mut io: *mut TValue = v;
                (*io).value_.i = (*e).u.ival;
                (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
            }
            return 1 as i32;
        }
        5 => {
            if !v.is_null() {
                let mut io_0: *mut TValue = v;
                (*io_0).value_.n = (*e).u.nval;
                (*io_0).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            }
            return 1 as i32;
        }
        _ => return 0,
    };
}
unsafe extern "C-unwind" fn const2val(
    mut fs: *mut FuncState,
    mut e: *const expdesc,
) -> *mut TValue {
    return &mut (*((*(*(*fs).ls).dyd).actvar.arr).offset((*e).u.info as isize)).k;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_exp2const(
    mut fs: *mut FuncState,
    mut e: *const expdesc,
    mut v: *mut TValue,
) -> i32 {
    if (*e).t != (*e).f {
        return 0;
    }
    match (*e).k as u32 {
        3 => {
            (*v).tt_ = (1 as i32 | (0) << 4 as i32) as lu_byte;
            return 1 as i32;
        }
        2 => {
            (*v).tt_ = (1 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            return 1 as i32;
        }
        1 => {
            (*v).tt_ = (0 | (0) << 4 as i32) as lu_byte;
            return 1 as i32;
        }
        7 => {
            let mut io: *mut TValue = v;
            let mut x_: *mut TString = (*e).u.strval;
            (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
            (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
            if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                    && (((*(*fs).ls).L).is_null()
                        || (*(*io).value_.gc).marked as i32
                            & ((*(*(*(*fs).ls).L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            return 1 as i32;
        }
        11 => {
            let mut io1: *mut TValue = v;
            let mut io2: *const TValue = const2val(fs, e);
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (((*(*fs).ls).L).is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*(*(*fs).ls).L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            return 1 as i32;
        }
        _ => return tonumeral(e, v),
    };
}
unsafe extern "C-unwind" fn previousinstruction(mut fs: *mut FuncState) -> *mut Instruction {
    static mut invalidinstruction: Instruction = !(0 as Instruction);
    if (*fs).pc > (*fs).lasttarget {
        return &mut *((*(*fs).f).code).offset(((*fs).pc - 1 as i32) as isize) as *mut Instruction;
    } else {
        return &raw const invalidinstruction as *const Instruction as *mut Instruction;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_nil(mut fs: *mut FuncState, mut from: i32, mut n: i32) {
    let mut l: i32 = from + n - 1 as i32;
    let mut previous: *mut Instruction = previousinstruction(fs);
    if (*previous >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32
        == OP_LOADNIL as i32 as u32
    {
        let mut pfrom: i32 =
            (*previous >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
        let mut pl: i32 = pfrom
            + (*previous >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
        if pfrom <= from && from <= pl + 1 as i32 || from <= pfrom && pfrom <= l + 1 as i32 {
            if pfrom < from {
                from = pfrom;
            }
            if pl > l {
                l = pl;
            }
            *previous = *previous & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32)
                | (from as Instruction) << 0 + 7 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32;
            *previous = *previous
                & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32 + 8 as i32 + 1 as i32)
                | ((l - from) as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32 + 8 as i32 + 1 as i32;
            return;
        }
    }
    luaK_codeABCk(fs, OP_LOADNIL, from, n - 1 as i32, 0, 0);
}
unsafe extern "C-unwind" fn getjump(mut fs: *mut FuncState, mut pc: i32) -> i32 {
    let mut offset: i32 = (*((*(*fs).f).code).offset(pc as isize) >> 0 + 7 as i32
        & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) << 0)
        as i32
        - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32 >> 1 as i32);
    if offset == -(1 as i32) {
        return -(1 as i32);
    } else {
        return pc + 1 as i32 + offset;
    };
}
unsafe extern "C-unwind" fn fixjump(mut fs: *mut FuncState, mut pc: i32, mut dest: i32) {
    let mut jmp: *mut Instruction = &mut *((*(*fs).f).code).offset(pc as isize) as *mut Instruction;
    let mut offset: i32 = dest - (pc + 1 as i32);
    if !(-(((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32 >> 1 as i32)
        <= offset
        && offset
            <= ((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                - 1 as i32
                - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32
                    >> 1 as i32))
    {
        luaX_syntaxerror((*fs).ls, c"control structure too long".as_ptr());
    }
    *jmp = *jmp
        & !(!(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) << 0 + 7 as i32)
        | ((offset
            + (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32 >> 1 as i32))
            as u32)
            << 0 + 7 as i32
            & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) << 0 + 7 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_concat(mut fs: *mut FuncState, mut l1: *mut i32, mut l2: i32) {
    if l2 == -(1 as i32) {
        return;
    } else if *l1 == -(1 as i32) {
        *l1 = l2;
    } else {
        let mut list: i32 = *l1;
        let mut next: i32 = 0;
        loop {
            next = getjump(fs, list);
            if !(next != -(1 as i32)) {
                break;
            }
            list = next;
        }
        fixjump(fs, list, l2);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_jump(mut fs: *mut FuncState) -> i32 {
    return codesJ(fs, OP_JMP, -(1 as i32), 0);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_ret(mut fs: *mut FuncState, mut first: i32, mut nret: i32) {
    let mut op: OpCode = OP_MOVE;
    match nret {
        0 => {
            op = OP_RETURN0;
        }
        1 => {
            op = OP_RETURN1;
        }
        _ => {
            op = OP_RETURN;
        }
    }
    luaK_codeABCk(fs, op, first, nret + 1 as i32, 0, 0);
}
unsafe extern "C-unwind" fn condjump(
    mut fs: *mut FuncState,
    mut op: OpCode,
    mut A: i32,
    mut B: i32,
    mut C: i32,
    mut k: i32,
) -> i32 {
    luaK_codeABCk(fs, op, A, B, C, k);
    return luaK_jump(fs);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_getlabel(mut fs: *mut FuncState) -> i32 {
    (*fs).lasttarget = (*fs).pc;
    return (*fs).pc;
}
unsafe extern "C-unwind" fn getjumpcontrol(
    mut fs: *mut FuncState,
    mut pc: i32,
) -> *mut Instruction {
    let mut pi: *mut Instruction = &mut *((*(*fs).f).code).offset(pc as isize) as *mut Instruction;
    if pc >= 1 as i32
        && luaP_opmodes
            [(*pi.offset(-(1)) >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as usize]
            as i32
            & (1 as i32) << 4 as i32
            != 0
    {
        return pi.offset(-(1));
    } else {
        return pi;
    };
}
unsafe extern "C-unwind" fn patchtestreg(
    mut fs: *mut FuncState,
    mut node: i32,
    mut reg: i32,
) -> i32 {
    let mut i: *mut Instruction = getjumpcontrol(fs, node);
    if (*i >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32
        != OP_TESTSET as i32 as u32
    {
        return 0;
    }
    if reg != ((1 as i32) << 8 as i32) - 1 as i32
        && reg
            != (*i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 & !(!(0 as Instruction) << 8 as i32) << 0)
                as i32
    {
        *i = *i & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32)
            | (reg as Instruction) << 0 + 7 as i32
                & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32;
    } else {
        *i = (OP_TEST as i32 as Instruction) << 0
            | ((*i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 & !(!(0 as Instruction) << 8 as i32) << 0)
                as i32 as Instruction)
                << 0 + 7 as i32
            | (0 as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32
            | (0 as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
            | ((*i >> 0 + 7 as i32 + 8 as i32 & !(!(0 as Instruction) << 1 as i32) << 0) as i32
                as Instruction)
                << 0 + 7 as i32 + 8 as i32;
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn removevalues(mut fs: *mut FuncState, mut list: i32) {
    while list != -(1 as i32) {
        patchtestreg(fs, list, ((1 as i32) << 8 as i32) - 1 as i32);
        list = getjump(fs, list);
    }
}
unsafe extern "C-unwind" fn patchlistaux(
    mut fs: *mut FuncState,
    mut list: i32,
    mut vtarget: i32,
    mut reg: i32,
    mut dtarget: i32,
) {
    while list != -(1 as i32) {
        let mut next: i32 = getjump(fs, list);
        if patchtestreg(fs, list, reg) != 0 {
            fixjump(fs, list, vtarget);
        } else {
            fixjump(fs, list, dtarget);
        }
        list = next;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_patchlist(
    mut fs: *mut FuncState,
    mut list: i32,
    mut target: i32,
) {
    patchlistaux(
        fs,
        list,
        target,
        ((1 as i32) << 8 as i32) - 1 as i32,
        target,
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_patchtohere(mut fs: *mut FuncState, mut list: i32) {
    let mut hr: i32 = luaK_getlabel(fs);
    luaK_patchlist(fs, list, hr);
}
unsafe extern "C-unwind" fn savelineinfo(mut fs: *mut FuncState, mut f: *mut Proto, mut line: i32) {
    let mut linedif: i32 = line - (*fs).previousline;
    let mut pc: i32 = (*fs).pc - 1 as i32;
    if abs(linedif) >= 0x80 || {
        let fresh91 = (*fs).iwthabs;
        (*fs).iwthabs = ((*fs).iwthabs).wrapping_add(1);
        fresh91 as i32 >= 128 as i32
    } {
        (*f).abslineinfo = luaM_growaux_(
            (*(*fs).ls).L,
            (*f).abslineinfo as *mut c_void,
            (*fs).nabslineinfo,
            &mut (*f).sizeabslineinfo,
            ::core::mem::size_of::<AbsLineInfo>() as usize as i32,
            (if 2147483647 as i32 as size_t
                <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<AbsLineInfo>() as usize)
            {
                2147483647
            } else {
                (!(0 as size_t)).wrapping_div(::core::mem::size_of::<AbsLineInfo>() as usize) as u32
            }) as i32,
            c"lines".as_ptr(),
        ) as *mut AbsLineInfo;
        (*((*f).abslineinfo).offset((*fs).nabslineinfo as isize)).pc = pc;
        let fresh92 = (*fs).nabslineinfo;
        (*fs).nabslineinfo = (*fs).nabslineinfo + 1;
        (*((*f).abslineinfo).offset(fresh92 as isize)).line = line;
        linedif = -(0x80);
        (*fs).iwthabs = 1 as i32 as lu_byte;
    }
    (*f).lineinfo = luaM_growaux_(
        (*(*fs).ls).L,
        (*f).lineinfo as *mut c_void,
        pc,
        &mut (*f).sizelineinfo,
        ::core::mem::size_of::<ls_byte>() as usize as i32,
        (if 2147483647 as i32 as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<ls_byte>() as usize)
        {
            2147483647
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<ls_byte>() as usize) as u32
        }) as i32,
        c"opcodes".as_ptr(),
    ) as *mut ls_byte;
    *((*f).lineinfo).offset(pc as isize) = linedif as ls_byte;
    (*fs).previousline = line;
}
unsafe extern "C-unwind" fn removelastlineinfo(mut fs: *mut FuncState) {
    let mut f: *mut Proto = (*fs).f;
    let mut pc: i32 = (*fs).pc - 1 as i32;
    if *((*f).lineinfo).offset(pc as isize) as i32 != -(0x80) {
        (*fs).previousline -= *((*f).lineinfo).offset(pc as isize) as i32;
        (*fs).iwthabs = ((*fs).iwthabs).wrapping_sub(1);
        (*fs).iwthabs;
    } else {
        (*fs).nabslineinfo -= 1;
        (*fs).nabslineinfo;
        (*fs).iwthabs = (128 as i32 + 1 as i32) as lu_byte;
    };
}
unsafe extern "C-unwind" fn removelastinstruction(mut fs: *mut FuncState) {
    removelastlineinfo(fs);
    (*fs).pc -= 1;
    (*fs).pc;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_code(mut fs: *mut FuncState, mut i: Instruction) -> i32 {
    let mut f: *mut Proto = (*fs).f;
    (*f).code = luaM_growaux_(
        (*(*fs).ls).L,
        (*f).code as *mut c_void,
        (*fs).pc,
        &mut (*f).sizecode,
        ::core::mem::size_of::<Instruction>() as usize as i32,
        (if 2147483647 as i32 as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Instruction>() as usize)
        {
            2147483647
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Instruction>() as usize) as u32
        }) as i32,
        c"opcodes".as_ptr(),
    ) as *mut Instruction;
    let fresh93 = (*fs).pc;
    (*fs).pc = (*fs).pc + 1;
    *((*f).code).offset(fresh93 as isize) = i;
    savelineinfo(fs, f, (*(*fs).ls).lastline);
    return (*fs).pc - 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_codeABCk(
    mut fs: *mut FuncState,
    mut o: OpCode,
    mut a: i32,
    mut b: i32,
    mut c: i32,
    mut k: i32,
) -> i32 {
    return luaK_code(
        fs,
        (o as Instruction) << 0
            | (a as Instruction) << 0 + 7 as i32
            | (b as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32
            | (c as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
            | (k as Instruction) << 0 + 7 as i32 + 8 as i32,
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_codeABx(
    mut fs: *mut FuncState,
    mut o: OpCode,
    mut a: i32,
    mut bc: u32,
) -> i32 {
    return luaK_code(
        fs,
        (o as Instruction) << 0
            | (a as Instruction) << 0 + 7 as i32
            | bc << 0 + 7 as i32 + 8 as i32,
    );
}
unsafe extern "C-unwind" fn codeAsBx(
    mut fs: *mut FuncState,
    mut o: OpCode,
    mut a: i32,
    mut bc: i32,
) -> i32 {
    let mut b: u32 =
        (bc + (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32 >> 1 as i32)) as u32;
    return luaK_code(
        fs,
        (o as Instruction) << 0 | (a as Instruction) << 0 + 7 as i32 | b << 0 + 7 as i32 + 8 as i32,
    );
}
unsafe extern "C-unwind" fn codesJ(
    mut fs: *mut FuncState,
    mut o: OpCode,
    mut sj: i32,
    mut k: i32,
) -> i32 {
    let mut j: u32 = (sj
        + (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32 >> 1 as i32))
        as u32;
    return luaK_code(
        fs,
        (o as Instruction) << 0 | j << 0 + 7 as i32 | (k as Instruction) << 0 + 7 as i32 + 8 as i32,
    );
}
unsafe extern "C-unwind" fn codeextraarg(mut fs: *mut FuncState, mut a: i32) -> i32 {
    return luaK_code(
        fs,
        (OP_EXTRAARG as i32 as Instruction) << 0 | (a as Instruction) << 0 + 7 as i32,
    );
}
unsafe extern "C-unwind" fn luaK_codek(mut fs: *mut FuncState, mut reg: i32, mut k: i32) -> i32 {
    if k <= ((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32 {
        return luaK_codeABx(fs, OP_LOADK, reg, k as u32);
    } else {
        let mut p: i32 = luaK_codeABx(fs, OP_LOADKX, reg, 0 as u32);
        codeextraarg(fs, k);
        return p;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_checkstack(mut fs: *mut FuncState, mut n: i32) {
    let mut newstack: i32 = (*fs).freereg as i32 + n;
    if newstack > (*(*fs).f).maxstacksize as i32 {
        if newstack >= 255 as i32 {
            luaX_syntaxerror(
                (*fs).ls,
                c"function or expression needs too many registers".as_ptr(),
            );
        }
        (*(*fs).f).maxstacksize = newstack as lu_byte;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_reserveregs(mut fs: *mut FuncState, mut n: i32) {
    luaK_checkstack(fs, n);
    (*fs).freereg = ((*fs).freereg as i32 + n) as lu_byte;
}
unsafe extern "C-unwind" fn freereg(mut fs: *mut FuncState, mut reg: i32) {
    if reg >= luaY_nvarstack(fs) {
        (*fs).freereg = ((*fs).freereg).wrapping_sub(1);
        (*fs).freereg;
    }
}
unsafe extern "C-unwind" fn freeregs(mut fs: *mut FuncState, mut r1: i32, mut r2: i32) {
    if r1 > r2 {
        freereg(fs, r1);
        freereg(fs, r2);
    } else {
        freereg(fs, r2);
        freereg(fs, r1);
    };
}
unsafe extern "C-unwind" fn freeexp(mut fs: *mut FuncState, mut e: *mut expdesc) {
    if (*e).k as u32 == VNONRELOC as i32 as u32 {
        freereg(fs, (*e).u.info);
    }
}
unsafe extern "C-unwind" fn freeexps(
    mut fs: *mut FuncState,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
) {
    let mut r1: i32 = if (*e1).k as u32 == VNONRELOC as i32 as u32 {
        (*e1).u.info
    } else {
        -(1 as i32)
    };
    let mut r2: i32 = if (*e2).k as u32 == VNONRELOC as i32 as u32 {
        (*e2).u.info
    } else {
        -(1 as i32)
    };
    freeregs(fs, r1, r2);
}
unsafe extern "C-unwind" fn addk(
    mut fs: *mut FuncState,
    mut key: *mut TValue,
    mut v: *mut TValue,
) -> i32 {
    let mut val: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut L: *mut lua_State = (*(*fs).ls).L;
    let mut f: *mut Proto = (*fs).f;
    let mut idx: *const TValue = luaH_get((*(*fs).ls).h, key);
    let mut k: i32 = 0;
    let mut oldsize: i32 = 0;
    if (*idx).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        k = (*idx).value_.i as i32;
        if k < (*fs).nk
            && (*((*f).k).offset(k as isize)).tt_ as i32 & 0x3f as i32
                == (*v).tt_ as i32 & 0x3f as i32
            && luaV_equalobj(0 as *mut lua_State, &mut *((*f).k).offset(k as isize), v) != 0
        {
            return k;
        }
    }
    oldsize = (*f).sizek;
    k = (*fs).nk;
    let mut io: *mut TValue = &mut val;
    (*io).value_.i = k as lua_Integer;
    (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
    luaH_finishset(L, (*(*fs).ls).h, key, idx, &mut val);
    (*f).k = luaM_growaux_(
        L,
        (*f).k as *mut c_void,
        k,
        &mut (*f).sizek,
        ::core::mem::size_of::<TValue>() as usize as i32,
        (if (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32) as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<TValue>() as usize)
        {
            (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32) as u32
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<TValue>() as usize) as u32
        }) as i32,
        c"constants".as_ptr(),
    ) as *mut TValue;
    while oldsize < (*f).sizek {
        let fresh94 = oldsize;
        oldsize = oldsize + 1;
        (*((*f).k).offset(fresh94 as isize)).tt_ = (0 | (0) << 4 as i32) as lu_byte;
    }
    let mut io1: *mut TValue = &mut *((*f).k).offset(k as isize) as *mut TValue;
    let mut io2: *const TValue = v;
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*fs).nk += 1;
    (*fs).nk;
    if (*v).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
        if (*f).marked as i32 & (1 as i32) << 5 as i32 != 0
            && (*(*v).value_.gc).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            luaC_barrier_(
                L,
                &mut (*(f as *mut GCUnion)).gc,
                &mut (*((*v).value_.gc as *mut GCUnion)).gc,
            );
        } else {
        };
    } else {
    };
    return k;
}
unsafe extern "C-unwind" fn stringK(mut fs: *mut FuncState, mut s: *mut TString) -> i32 {
    let mut o: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut io: *mut TValue = &mut o;
    let mut x_: *mut TString = s;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (((*(*fs).ls).L).is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*(*(*fs).ls).L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    return addk(fs, &mut o, &mut o);
}
unsafe extern "C-unwind" fn luaK_intK(mut fs: *mut FuncState, mut n: lua_Integer) -> i32 {
    let mut o: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut io: *mut TValue = &mut o;
    (*io).value_.i = n;
    (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
    return addk(fs, &mut o, &mut o);
}
unsafe extern "C-unwind" fn luaK_numberK(mut fs: *mut FuncState, mut r: lua_Number) -> i32 {
    let mut o: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut ik: lua_Integer = 0;
    let mut io: *mut TValue = &mut o;
    (*io).value_.n = r;
    (*io).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
    if luaV_flttointeger(r, &mut ik, F2Ieq) == 0 {
        return addk(fs, &mut o, &mut o);
    } else {
        let nbm: i32 = 53 as i32;
        let q: lua_Number = ldexp(1.0f64, -nbm + 1 as i32);
        let k: lua_Number = if ik == 0 as lua_Integer { q } else { r + r * q };
        let mut kv: TValue = TValue {
            value_: Value {
                gc: 0 as *mut GCObject,
            },
            tt_: 0,
        };
        let mut io_0: *mut TValue = &mut kv;
        (*io_0).value_.n = k;
        (*io_0).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
        return addk(fs, &mut kv, &mut o);
    };
}
unsafe extern "C-unwind" fn boolF(mut fs: *mut FuncState) -> i32 {
    let mut o: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    o.tt_ = (1 as i32 | (0) << 4 as i32) as lu_byte;
    return addk(fs, &mut o, &mut o);
}
unsafe extern "C-unwind" fn boolT(mut fs: *mut FuncState) -> i32 {
    let mut o: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    o.tt_ = (1 as i32 | (1 as i32) << 4 as i32) as lu_byte;
    return addk(fs, &mut o, &mut o);
}
unsafe extern "C-unwind" fn nilK(mut fs: *mut FuncState) -> i32 {
    let mut k: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut v: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    v.tt_ = (0 | (0) << 4 as i32) as lu_byte;
    let mut io: *mut TValue = &mut k;
    let mut x_: *mut Table = (*(*fs).ls).h;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (((*(*fs).ls).L).is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*(*(*fs).ls).L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    return addk(fs, &mut k, &mut v);
}
unsafe extern "C-unwind" fn fitsC(mut i: lua_Integer) -> i32 {
    return ((i as lua_Unsigned)
        .wrapping_add((((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32) as lua_Unsigned)
        <= (((1 as i32) << 8 as i32) - 1 as i32) as u32 as lua_Unsigned) as i32;
}
unsafe extern "C-unwind" fn fitsBx(mut i: lua_Integer) -> i32 {
    return (-(((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32 >> 1 as i32) as lua_Integer
        <= i
        && i <= (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32)
            - 1 as i32
            - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32 >> 1 as i32))
            as lua_Integer) as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_int(mut fs: *mut FuncState, mut reg: i32, mut i: lua_Integer) {
    if fitsBx(i) != 0 {
        codeAsBx(fs, OP_LOADI, reg, i as i32);
    } else {
        luaK_codek(fs, reg, luaK_intK(fs, i));
    };
}
unsafe extern "C-unwind" fn luaK_float(mut fs: *mut FuncState, mut reg: i32, mut f: lua_Number) {
    let mut fi: lua_Integer = 0;
    if luaV_flttointeger(f, &mut fi, F2Ieq) != 0 && fitsBx(fi) != 0 {
        codeAsBx(fs, OP_LOADF, reg, fi as i32);
    } else {
        luaK_codek(fs, reg, luaK_numberK(fs, f));
    };
}
unsafe extern "C-unwind" fn const2exp(mut v: *mut TValue, mut e: *mut expdesc) {
    match (*v).tt_ as i32 & 0x3f as i32 {
        3 => {
            (*e).k = VKINT;
            (*e).u.ival = (*v).value_.i;
        }
        19 => {
            (*e).k = VKFLT;
            (*e).u.nval = (*v).value_.n;
        }
        1 => {
            (*e).k = VFALSE;
        }
        17 => {
            (*e).k = VTRUE;
        }
        0 => {
            (*e).k = VNIL;
        }
        4 | 20 => {
            (*e).k = VKSTR;
            (*e).u.strval = &mut (*((*v).value_.gc as *mut GCUnion)).ts;
        }
        _ => {}
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_setreturns(
    mut fs: *mut FuncState,
    mut e: *mut expdesc,
    mut nresults: i32,
) {
    let mut pc: *mut Instruction =
        &mut *((*(*fs).f).code).offset((*e).u.info as isize) as *mut Instruction;
    if (*e).k as u32 == VCALL as i32 as u32 {
        *pc = *pc
            & !(!(!(0 as Instruction) << 8 as i32)
                << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
            | ((nresults + 1 as i32) as Instruction)
                << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                & !(!(0 as Instruction) << 8 as i32)
                    << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32;
    } else {
        *pc = *pc
            & !(!(!(0 as Instruction) << 8 as i32)
                << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
            | ((nresults + 1 as i32) as Instruction)
                << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                & !(!(0 as Instruction) << 8 as i32)
                    << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32;
        *pc = *pc & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32)
            | ((*fs).freereg as Instruction) << 0 + 7 as i32
                & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32;
        luaK_reserveregs(fs, 1 as i32);
    };
}
unsafe extern "C-unwind" fn str2K(mut fs: *mut FuncState, mut e: *mut expdesc) {
    (*e).u.info = stringK(fs, (*e).u.strval);
    (*e).k = VK;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_setoneret(mut fs: *mut FuncState, mut e: *mut expdesc) {
    if (*e).k as u32 == VCALL as i32 as u32 {
        (*e).k = VNONRELOC;
        (*e).u.info = (*((*(*fs).f).code).offset((*e).u.info as isize) >> 0 + 7 as i32
            & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
    } else if (*e).k as u32 == VVARARG as i32 as u32 {
        *((*(*fs).f).code).offset((*e).u.info as isize) = *((*(*fs).f).code)
            .offset((*e).u.info as isize)
            & !(!(!(0 as Instruction) << 8 as i32)
                << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
            | (2 as i32 as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                & !(!(0 as Instruction) << 8 as i32)
                    << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32;
        (*e).k = VRELOC;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_dischargevars(mut fs: *mut FuncState, mut e: *mut expdesc) {
    match (*e).k as u32 {
        11 => {
            const2exp(const2val(fs, e), e);
        }
        9 => {
            let mut temp: i32 = (*e).u.var.ridx as i32;
            (*e).u.info = temp;
            (*e).k = VNONRELOC;
        }
        10 => {
            (*e).u.info = luaK_codeABCk(fs, OP_GETUPVAL, 0, (*e).u.info, 0, 0);
            (*e).k = VRELOC;
        }
        13 => {
            (*e).u.info = luaK_codeABCk(
                fs,
                OP_GETTABUP,
                0,
                (*e).u.ind.t as i32,
                (*e).u.ind.idx as i32,
                0,
            );
            (*e).k = VRELOC;
        }
        14 => {
            freereg(fs, (*e).u.ind.t as i32);
            (*e).u.info = luaK_codeABCk(
                fs,
                OP_GETI,
                0,
                (*e).u.ind.t as i32,
                (*e).u.ind.idx as i32,
                0,
            );
            (*e).k = VRELOC;
        }
        15 => {
            freereg(fs, (*e).u.ind.t as i32);
            (*e).u.info = luaK_codeABCk(
                fs,
                OP_GETFIELD,
                0,
                (*e).u.ind.t as i32,
                (*e).u.ind.idx as i32,
                0,
            );
            (*e).k = VRELOC;
        }
        12 => {
            freeregs(fs, (*e).u.ind.t as i32, (*e).u.ind.idx as i32);
            (*e).u.info = luaK_codeABCk(
                fs,
                OP_GETTABLE,
                0,
                (*e).u.ind.t as i32,
                (*e).u.ind.idx as i32,
                0,
            );
            (*e).k = VRELOC;
        }
        19 | 18 => {
            luaK_setoneret(fs, e);
        }
        _ => {}
    };
}
unsafe extern "C-unwind" fn discharge2reg(
    mut fs: *mut FuncState,
    mut e: *mut expdesc,
    mut reg: i32,
) {
    luaK_dischargevars(fs, e);
    let mut current_block_14: u64;
    match (*e).k as u32 {
        1 => {
            luaK_nil(fs, reg, 1 as i32);
            current_block_14 = 13242334135786603907;
        }
        3 => {
            luaK_codeABCk(fs, OP_LOADFALSE, reg, 0, 0, 0);
            current_block_14 = 13242334135786603907;
        }
        2 => {
            luaK_codeABCk(fs, OP_LOADTRUE, reg, 0, 0, 0);
            current_block_14 = 13242334135786603907;
        }
        7 => {
            str2K(fs, e);
            current_block_14 = 6937071982253665452;
        }
        4 => {
            current_block_14 = 6937071982253665452;
        }
        5 => {
            luaK_float(fs, reg, (*e).u.nval);
            current_block_14 = 13242334135786603907;
        }
        6 => {
            luaK_int(fs, reg, (*e).u.ival);
            current_block_14 = 13242334135786603907;
        }
        17 => {
            let mut pc: *mut Instruction =
                &mut *((*(*fs).f).code).offset((*e).u.info as isize) as *mut Instruction;
            *pc = *pc & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32)
                | (reg as Instruction) << 0 + 7 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32;
            current_block_14 = 13242334135786603907;
        }
        8 => {
            if reg != (*e).u.info {
                luaK_codeABCk(fs, OP_MOVE, reg, (*e).u.info, 0, 0);
            }
            current_block_14 = 13242334135786603907;
        }
        _ => return,
    }
    match current_block_14 {
        6937071982253665452 => {
            luaK_codek(fs, reg, (*e).u.info);
        }
        _ => {}
    }
    (*e).u.info = reg;
    (*e).k = VNONRELOC;
}
unsafe extern "C-unwind" fn discharge2anyreg(mut fs: *mut FuncState, mut e: *mut expdesc) {
    if (*e).k as u32 != VNONRELOC as i32 as u32 {
        luaK_reserveregs(fs, 1 as i32);
        discharge2reg(fs, e, (*fs).freereg as i32 - 1 as i32);
    }
}
unsafe extern "C-unwind" fn code_loadbool(
    mut fs: *mut FuncState,
    mut A: i32,
    mut op: OpCode,
) -> i32 {
    luaK_getlabel(fs);
    return luaK_codeABCk(fs, op, A, 0, 0, 0);
}
unsafe extern "C-unwind" fn need_value(mut fs: *mut FuncState, mut list: i32) -> i32 {
    while list != -(1 as i32) {
        let mut i: Instruction = *getjumpcontrol(fs, list);
        if (i >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32
            != OP_TESTSET as i32 as u32
        {
            return 1 as i32;
        }
        list = getjump(fs, list);
    }
    return 0;
}
unsafe extern "C-unwind" fn exp2reg(mut fs: *mut FuncState, mut e: *mut expdesc, mut reg: i32) {
    discharge2reg(fs, e, reg);
    if (*e).k as u32 == VJMP as i32 as u32 {
        luaK_concat(fs, &mut (*e).t, (*e).u.info);
    }
    if (*e).t != (*e).f {
        let mut final_0: i32 = 0;
        let mut p_f: i32 = -(1 as i32);
        let mut p_t: i32 = -(1 as i32);
        if need_value(fs, (*e).t) != 0 || need_value(fs, (*e).f) != 0 {
            let mut fj: i32 = if (*e).k as u32 == VJMP as i32 as u32 {
                -(1 as i32)
            } else {
                luaK_jump(fs)
            };
            p_f = code_loadbool(fs, reg, OP_LFALSESKIP);
            p_t = code_loadbool(fs, reg, OP_LOADTRUE);
            luaK_patchtohere(fs, fj);
        }
        final_0 = luaK_getlabel(fs);
        patchlistaux(fs, (*e).f, final_0, reg, p_f);
        patchlistaux(fs, (*e).t, final_0, reg, p_t);
    }
    (*e).t = -(1 as i32);
    (*e).f = (*e).t;
    (*e).u.info = reg;
    (*e).k = VNONRELOC;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_exp2nextreg(mut fs: *mut FuncState, mut e: *mut expdesc) {
    luaK_dischargevars(fs, e);
    freeexp(fs, e);
    luaK_reserveregs(fs, 1 as i32);
    exp2reg(fs, e, (*fs).freereg as i32 - 1 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_exp2anyreg(
    mut fs: *mut FuncState,
    mut e: *mut expdesc,
) -> i32 {
    luaK_dischargevars(fs, e);
    if (*e).k as u32 == VNONRELOC as i32 as u32 {
        if !((*e).t != (*e).f) {
            return (*e).u.info;
        }
        if (*e).u.info >= luaY_nvarstack(fs) {
            exp2reg(fs, e, (*e).u.info);
            return (*e).u.info;
        }
    }
    luaK_exp2nextreg(fs, e);
    return (*e).u.info;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_exp2anyregup(mut fs: *mut FuncState, mut e: *mut expdesc) {
    if (*e).k as u32 != VUPVAL as i32 as u32 || (*e).t != (*e).f {
        luaK_exp2anyreg(fs, e);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_exp2val(mut fs: *mut FuncState, mut e: *mut expdesc) {
    if (*e).t != (*e).f {
        luaK_exp2anyreg(fs, e);
    } else {
        luaK_dischargevars(fs, e);
    };
}
unsafe extern "C-unwind" fn luaK_exp2K(mut fs: *mut FuncState, mut e: *mut expdesc) -> i32 {
    if !((*e).t != (*e).f) {
        let mut info: i32 = 0;
        match (*e).k as u32 {
            2 => {
                info = boolT(fs);
            }
            3 => {
                info = boolF(fs);
            }
            1 => {
                info = nilK(fs);
            }
            6 => {
                info = luaK_intK(fs, (*e).u.ival);
            }
            5 => {
                info = luaK_numberK(fs, (*e).u.nval);
            }
            7 => {
                info = stringK(fs, (*e).u.strval);
            }
            4 => {
                info = (*e).u.info;
            }
            _ => return 0,
        }
        if info <= ((1 as i32) << 8 as i32) - 1 as i32 {
            (*e).k = VK;
            (*e).u.info = info;
            return 1 as i32;
        }
    }
    return 0;
}
unsafe extern "C-unwind" fn exp2RK(mut fs: *mut FuncState, mut e: *mut expdesc) -> i32 {
    if luaK_exp2K(fs, e) != 0 {
        return 1 as i32;
    } else {
        luaK_exp2anyreg(fs, e);
        return 0;
    };
}
unsafe extern "C-unwind" fn codeABRK(
    mut fs: *mut FuncState,
    mut o: OpCode,
    mut a: i32,
    mut b: i32,
    mut ec: *mut expdesc,
) {
    let mut k: i32 = exp2RK(fs, ec);
    luaK_codeABCk(fs, o, a, b, (*ec).u.info, k);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_storevar(
    mut fs: *mut FuncState,
    mut var: *mut expdesc,
    mut ex: *mut expdesc,
) {
    match (*var).k as u32 {
        9 => {
            freeexp(fs, ex);
            exp2reg(fs, ex, (*var).u.var.ridx as i32);
            return;
        }
        10 => {
            let mut e: i32 = luaK_exp2anyreg(fs, ex);
            luaK_codeABCk(fs, OP_SETUPVAL, e, (*var).u.info, 0, 0);
        }
        13 => {
            codeABRK(
                fs,
                OP_SETTABUP,
                (*var).u.ind.t as i32,
                (*var).u.ind.idx as i32,
                ex,
            );
        }
        14 => {
            codeABRK(
                fs,
                OP_SETI,
                (*var).u.ind.t as i32,
                (*var).u.ind.idx as i32,
                ex,
            );
        }
        15 => {
            codeABRK(
                fs,
                OP_SETFIELD,
                (*var).u.ind.t as i32,
                (*var).u.ind.idx as i32,
                ex,
            );
        }
        12 => {
            codeABRK(
                fs,
                OP_SETTABLE,
                (*var).u.ind.t as i32,
                (*var).u.ind.idx as i32,
                ex,
            );
        }
        _ => {}
    }
    freeexp(fs, ex);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_self(
    mut fs: *mut FuncState,
    mut e: *mut expdesc,
    mut key: *mut expdesc,
) {
    let mut ereg: i32 = 0;
    luaK_exp2anyreg(fs, e);
    ereg = (*e).u.info;
    freeexp(fs, e);
    (*e).u.info = (*fs).freereg as i32;
    (*e).k = VNONRELOC;
    luaK_reserveregs(fs, 2 as i32);
    codeABRK(fs, OP_SELF, (*e).u.info, ereg, key);
    freeexp(fs, key);
}
unsafe extern "C-unwind" fn negatecondition(mut fs: *mut FuncState, mut e: *mut expdesc) {
    let mut pc: *mut Instruction = getjumpcontrol(fs, (*e).u.info);
    *pc = *pc & !(!(!(0 as Instruction) << 1 as i32) << 0 + 7 as i32 + 8 as i32)
        | (((*pc >> 0 + 7 as i32 + 8 as i32 & !(!(0 as Instruction) << 1 as i32) << 0) as i32
            ^ 1 as i32) as Instruction)
            << 0 + 7 as i32 + 8 as i32
            & !(!(0 as Instruction) << 1 as i32) << 0 + 7 as i32 + 8 as i32;
}
unsafe extern "C-unwind" fn jumponcond(
    mut fs: *mut FuncState,
    mut e: *mut expdesc,
    mut cond_0: i32,
) -> i32 {
    if (*e).k as u32 == VRELOC as i32 as u32 {
        let mut ie: Instruction = *((*(*fs).f).code).offset((*e).u.info as isize);
        if (ie >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32
            == OP_NOT as i32 as u32
        {
            removelastinstruction(fs);
            return condjump(
                fs,
                OP_TEST,
                (ie >> 0 + 7 as i32 + 8 as i32 + 1 as i32 & !(!(0 as Instruction) << 8 as i32) << 0)
                    as i32,
                0,
                0,
                (cond_0 == 0) as i32,
            );
        }
    }
    discharge2anyreg(fs, e);
    freeexp(fs, e);
    return condjump(
        fs,
        OP_TESTSET,
        ((1 as i32) << 8 as i32) - 1 as i32,
        (*e).u.info,
        0,
        cond_0,
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_goiftrue(mut fs: *mut FuncState, mut e: *mut expdesc) {
    let mut pc: i32 = 0;
    luaK_dischargevars(fs, e);
    match (*e).k as u32 {
        16 => {
            negatecondition(fs, e);
            pc = (*e).u.info;
        }
        4 | 5 | 6 | 7 | 2 => {
            pc = -(1 as i32);
        }
        _ => {
            pc = jumponcond(fs, e, 0);
        }
    }
    luaK_concat(fs, &mut (*e).f, pc);
    luaK_patchtohere(fs, (*e).t);
    (*e).t = -(1 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_goiffalse(mut fs: *mut FuncState, mut e: *mut expdesc) {
    let mut pc: i32 = 0;
    luaK_dischargevars(fs, e);
    match (*e).k as u32 {
        16 => {
            pc = (*e).u.info;
        }
        1 | 3 => {
            pc = -(1 as i32);
        }
        _ => {
            pc = jumponcond(fs, e, 1 as i32);
        }
    }
    luaK_concat(fs, &mut (*e).t, pc);
    luaK_patchtohere(fs, (*e).f);
    (*e).f = -(1 as i32);
}
unsafe extern "C-unwind" fn codenot(mut fs: *mut FuncState, mut e: *mut expdesc) {
    match (*e).k as u32 {
        1 | 3 => {
            (*e).k = VTRUE;
        }
        4 | 5 | 6 | 7 | 2 => {
            (*e).k = VFALSE;
        }
        16 => {
            negatecondition(fs, e);
        }
        17 | 8 => {
            discharge2anyreg(fs, e);
            freeexp(fs, e);
            (*e).u.info = luaK_codeABCk(fs, OP_NOT, 0, (*e).u.info, 0, 0);
            (*e).k = VRELOC;
        }
        _ => {}
    }
    let mut temp: i32 = (*e).f;
    (*e).f = (*e).t;
    (*e).t = temp;
    removevalues(fs, (*e).f);
    removevalues(fs, (*e).t);
}
unsafe extern "C-unwind" fn isKstr(mut fs: *mut FuncState, mut e: *mut expdesc) -> i32 {
    return ((*e).k as u32 == VK as i32 as u32
        && !((*e).t != (*e).f)
        && (*e).u.info <= ((1 as i32) << 8 as i32) - 1 as i32
        && (*((*(*fs).f).k).offset((*e).u.info as isize)).tt_ as i32
            == 4 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as i32;
}
unsafe extern "C-unwind" fn isKint(mut e: *mut expdesc) -> i32 {
    return ((*e).k as u32 == VKINT as i32 as u32 && !((*e).t != (*e).f)) as i32;
}
unsafe extern "C-unwind" fn isCint(mut e: *mut expdesc) -> i32 {
    return (isKint(e) != 0
        && (*e).u.ival as lua_Unsigned <= (((1 as i32) << 8 as i32) - 1 as i32) as lua_Unsigned)
        as i32;
}
unsafe extern "C-unwind" fn isSCint(mut e: *mut expdesc) -> i32 {
    return (isKint(e) != 0 && fitsC((*e).u.ival) != 0) as i32;
}
unsafe extern "C-unwind" fn isSCnumber(
    mut e: *mut expdesc,
    mut pi: *mut i32,
    mut isfloat: *mut i32,
) -> i32 {
    let mut i: lua_Integer = 0;
    if (*e).k as u32 == VKINT as i32 as u32 {
        i = (*e).u.ival;
    } else if (*e).k as u32 == VKFLT as i32 as u32
        && luaV_flttointeger((*e).u.nval, &mut i, F2Ieq) != 0
    {
        *isfloat = 1 as i32;
    } else {
        return 0;
    }
    if !((*e).t != (*e).f) && fitsC(i) != 0 {
        *pi = i as i32 + (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
        return 1 as i32;
    } else {
        return 0;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_indexed(
    mut fs: *mut FuncState,
    mut t: *mut expdesc,
    mut k: *mut expdesc,
) {
    if (*k).k as u32 == VKSTR as i32 as u32 {
        str2K(fs, k);
    }
    if (*t).k as u32 == VUPVAL as i32 as u32 && isKstr(fs, k) == 0 {
        luaK_exp2anyreg(fs, t);
    }
    if (*t).k as u32 == VUPVAL as i32 as u32 {
        let mut temp: i32 = (*t).u.info;
        (*t).u.ind.t = temp as lu_byte;
        (*t).u.ind.idx = (*k).u.info as std::ffi::c_short;
        (*t).k = VINDEXUP;
    } else {
        (*t).u.ind.t = (if (*t).k as u32 == VLOCAL as i32 as u32 {
            (*t).u.var.ridx as i32
        } else {
            (*t).u.info
        }) as lu_byte;
        if isKstr(fs, k) != 0 {
            (*t).u.ind.idx = (*k).u.info as std::ffi::c_short;
            (*t).k = VINDEXSTR;
        } else if isCint(k) != 0 {
            (*t).u.ind.idx = (*k).u.ival as i32 as std::ffi::c_short;
            (*t).k = VINDEXI;
        } else {
            (*t).u.ind.idx = luaK_exp2anyreg(fs, k) as std::ffi::c_short;
            (*t).k = VINDEXED;
        }
    };
}
unsafe extern "C-unwind" fn validop(mut op: i32, mut v1: *mut TValue, mut v2: *mut TValue) -> i32 {
    match op {
        7 | 8 | 9 | 10 | 11 | 13 => {
            let mut i: lua_Integer = 0;
            return (luaV_tointegerns(v1, &mut i, F2Ieq) != 0
                && luaV_tointegerns(v2, &mut i, F2Ieq) != 0) as i32;
        }
        5 | 6 | 3 => {
            return ((if (*v2).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                (*v2).value_.i as lua_Number
            } else {
                (*v2).value_.n
            }) != 0 as lua_Number) as i32;
        }
        _ => return 1 as i32,
    };
}
unsafe extern "C-unwind" fn constfolding(
    mut fs: *mut FuncState,
    mut op: i32,
    mut e1: *mut expdesc,
    mut e2: *const expdesc,
) -> i32 {
    let mut v1: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut v2: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut res: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    if tonumeral(e1, &mut v1) == 0
        || tonumeral(e2, &mut v2) == 0
        || validop(op, &mut v1, &mut v2) == 0
    {
        return 0;
    }
    luaO_rawarith((*(*fs).ls).L, op, &mut v1, &mut v2, &mut res);
    if res.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        (*e1).k = VKINT;
        (*e1).u.ival = res.value_.i;
    } else {
        let mut n: lua_Number = res.value_.n;
        if !(n == n) || n == 0 as lua_Number {
            return 0;
        }
        (*e1).k = VKFLT;
        (*e1).u.nval = n;
    }
    return 1 as i32;
}
#[inline]
unsafe extern "C-unwind" fn binopr2op(
    mut opr: BinOpr,
    mut baser: BinOpr,
    mut base: OpCode,
) -> OpCode {
    return (opr as i32 - baser as i32 + base as i32) as OpCode;
}
#[inline]
unsafe extern "C-unwind" fn unopr2op(mut opr: UnOpr) -> OpCode {
    return (opr as i32 - OPR_MINUS as i32 + OP_UNM as i32) as OpCode;
}
#[inline]
unsafe extern "C-unwind" fn binopr2TM(mut opr: BinOpr) -> TMS {
    return (opr as i32 - OPR_ADD as i32 + TM_ADD as i32) as TMS;
}
unsafe extern "C-unwind" fn codeunexpval(
    mut fs: *mut FuncState,
    mut op: OpCode,
    mut e: *mut expdesc,
    mut line: i32,
) {
    let mut r: i32 = luaK_exp2anyreg(fs, e);
    freeexp(fs, e);
    (*e).u.info = luaK_codeABCk(fs, op, 0, r, 0, 0);
    (*e).k = VRELOC;
    luaK_fixline(fs, line);
}
unsafe extern "C-unwind" fn finishbinexpval(
    mut fs: *mut FuncState,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut op: OpCode,
    mut v2: i32,
    mut flip: i32,
    mut line: i32,
    mut mmop: OpCode,
    mut event: TMS,
) {
    let mut v1: i32 = luaK_exp2anyreg(fs, e1);
    let mut pc: i32 = luaK_codeABCk(fs, op, 0, v1, v2, 0);
    freeexps(fs, e1, e2);
    (*e1).u.info = pc;
    (*e1).k = VRELOC;
    luaK_fixline(fs, line);
    luaK_codeABCk(fs, mmop, v1, v2, event as i32, flip);
    luaK_fixline(fs, line);
}
unsafe extern "C-unwind" fn codebinexpval(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut line: i32,
) {
    let mut op: OpCode = binopr2op(opr, OPR_ADD, OP_ADD);
    let mut v2: i32 = luaK_exp2anyreg(fs, e2);
    finishbinexpval(fs, e1, e2, op, v2, 0, line, OP_MMBIN, binopr2TM(opr));
}
unsafe extern "C-unwind" fn codebini(
    mut fs: *mut FuncState,
    mut op: OpCode,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut flip: i32,
    mut line: i32,
    mut event: TMS,
) {
    let mut v2: i32 = (*e2).u.ival as i32 + (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
    finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINI, event);
}
unsafe extern "C-unwind" fn codebinK(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut flip: i32,
    mut line: i32,
) {
    let mut event: TMS = binopr2TM(opr);
    let mut v2: i32 = (*e2).u.info;
    let mut op: OpCode = binopr2op(opr, OPR_ADD, OP_ADDK);
    finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINK, event);
}
unsafe extern "C-unwind" fn finishbinexpneg(
    mut fs: *mut FuncState,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut op: OpCode,
    mut line: i32,
    mut event: TMS,
) -> i32 {
    if isKint(e2) == 0 {
        return 0;
    } else {
        let mut i2: lua_Integer = (*e2).u.ival;
        if !(fitsC(i2) != 0 && fitsC(-i2) != 0) {
            return 0;
        } else {
            let mut v2: i32 = i2 as i32;
            finishbinexpval(
                fs,
                e1,
                e2,
                op,
                -v2 + (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32),
                0,
                line,
                OP_MMBINI,
                event,
            );
            *((*(*fs).f).code).offset(((*fs).pc - 1 as i32) as isize) = *((*(*fs).f).code)
                .offset(((*fs).pc - 1 as i32) as isize)
                & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32 + 8 as i32 + 1 as i32)
                | ((v2 + (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32)) as Instruction)
                    << 0 + 7 as i32 + 8 as i32 + 1 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32 + 8 as i32 + 1 as i32;
            return 1 as i32;
        }
    };
}
unsafe extern "C-unwind" fn swapexps(mut e1: *mut expdesc, mut e2: *mut expdesc) {
    let mut temp: expdesc = *e1;
    *e1 = *e2;
    *e2 = temp;
}
unsafe extern "C-unwind" fn codebinNoK(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut flip: i32,
    mut line: i32,
) {
    if flip != 0 {
        swapexps(e1, e2);
    }
    codebinexpval(fs, opr, e1, e2, line);
}
unsafe extern "C-unwind" fn codearith(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut flip: i32,
    mut line: i32,
) {
    if tonumeral(e2, 0 as *mut TValue) != 0 && luaK_exp2K(fs, e2) != 0 {
        codebinK(fs, opr, e1, e2, flip, line);
    } else {
        codebinNoK(fs, opr, e1, e2, flip, line);
    };
}
unsafe extern "C-unwind" fn codecommutative(
    mut fs: *mut FuncState,
    mut op: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut line: i32,
) {
    let mut flip: i32 = 0;
    if tonumeral(e1, 0 as *mut TValue) != 0 {
        swapexps(e1, e2);
        flip = 1 as i32;
    }
    if op as u32 == OPR_ADD as i32 as u32 && isSCint(e2) != 0 {
        codebini(fs, OP_ADDI, e1, e2, flip, line, TM_ADD);
    } else {
        codearith(fs, op, e1, e2, flip, line);
    };
}
unsafe extern "C-unwind" fn codebitwise(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut line: i32,
) {
    let mut flip: i32 = 0;
    if (*e1).k as u32 == VKINT as i32 as u32 {
        swapexps(e1, e2);
        flip = 1 as i32;
    }
    if (*e2).k as u32 == VKINT as i32 as u32 && luaK_exp2K(fs, e2) != 0 {
        codebinK(fs, opr, e1, e2, flip, line);
    } else {
        codebinNoK(fs, opr, e1, e2, flip, line);
    };
}
unsafe extern "C-unwind" fn codeorder(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
) {
    let mut r1: i32 = 0;
    let mut r2: i32 = 0;
    let mut im: i32 = 0;
    let mut isfloat: i32 = 0;
    let mut op: OpCode = OP_MOVE;
    if isSCnumber(e2, &mut im, &mut isfloat) != 0 {
        r1 = luaK_exp2anyreg(fs, e1);
        r2 = im;
        op = binopr2op(opr, OPR_LT, OP_LTI);
    } else if isSCnumber(e1, &mut im, &mut isfloat) != 0 {
        r1 = luaK_exp2anyreg(fs, e2);
        r2 = im;
        op = binopr2op(opr, OPR_LT, OP_GTI);
    } else {
        r1 = luaK_exp2anyreg(fs, e1);
        r2 = luaK_exp2anyreg(fs, e2);
        op = binopr2op(opr, OPR_LT, OP_LT);
    }
    freeexps(fs, e1, e2);
    (*e1).u.info = condjump(fs, op, r1, r2, isfloat, 1 as i32);
    (*e1).k = VJMP;
}
unsafe extern "C-unwind" fn codeeq(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
) {
    let mut r1: i32 = 0;
    let mut r2: i32 = 0;
    let mut im: i32 = 0;
    let mut isfloat: i32 = 0;
    let mut op: OpCode = OP_MOVE;
    if (*e1).k as u32 != VNONRELOC as i32 as u32 {
        swapexps(e1, e2);
    }
    r1 = luaK_exp2anyreg(fs, e1);
    if isSCnumber(e2, &mut im, &mut isfloat) != 0 {
        op = OP_EQI;
        r2 = im;
    } else if exp2RK(fs, e2) != 0 {
        op = OP_EQK;
        r2 = (*e2).u.info;
    } else {
        op = OP_EQ;
        r2 = luaK_exp2anyreg(fs, e2);
    }
    freeexps(fs, e1, e2);
    (*e1).u.info = condjump(
        fs,
        op,
        r1,
        r2,
        isfloat,
        (opr as u32 == OPR_EQ as i32 as u32) as i32,
    );
    (*e1).k = VJMP;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_prefix(
    mut fs: *mut FuncState,
    mut opr: UnOpr,
    mut e: *mut expdesc,
    mut line: i32,
) {
    static mut ef: expdesc = {
        let mut init = expdesc {
            k: VKINT,
            u: C2RustUnnamed_11 {
                ival: 0 as lua_Integer,
            },
            t: -(1 as i32),
            f: -(1 as i32),
        };
        init
    };
    luaK_dischargevars(fs, e);
    let mut current_block_3: u64;
    match opr as u32 {
        0 | 1 => {
            if constfolding(fs, (opr as u32).wrapping_add(12) as i32, e, &raw const ef) != 0 {
                current_block_3 = 7815301370352969686;
            } else {
                current_block_3 = 8039936322597116006;
            }
        }
        3 => {
            current_block_3 = 8039936322597116006;
        }
        2 => {
            codenot(fs, e);
            current_block_3 = 7815301370352969686;
        }
        _ => {
            current_block_3 = 7815301370352969686;
        }
    }
    match current_block_3 {
        8039936322597116006 => {
            codeunexpval(fs, unopr2op(opr), e, line);
        }
        _ => {}
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_infix(
    mut fs: *mut FuncState,
    mut op: BinOpr,
    mut v: *mut expdesc,
) {
    luaK_dischargevars(fs, v);
    match op as u32 {
        19 => {
            luaK_goiftrue(fs, v);
        }
        20 => {
            luaK_goiffalse(fs, v);
        }
        12 => {
            luaK_exp2nextreg(fs, v);
        }
        0 | 1 | 2 | 5 | 6 | 3 | 4 | 7 | 8 | 9 | 10 | 11 => {
            if tonumeral(v, 0 as *mut TValue) == 0 {
                luaK_exp2anyreg(fs, v);
            }
        }
        13 | 16 => {
            if tonumeral(v, 0 as *mut TValue) == 0 {
                exp2RK(fs, v);
            }
        }
        14 | 15 | 17 | 18 => {
            let mut dummy: i32 = 0;
            let mut dummy2: i32 = 0;
            if isSCnumber(v, &mut dummy, &mut dummy2) == 0 {
                luaK_exp2anyreg(fs, v);
            }
        }
        _ => {}
    };
}
unsafe extern "C-unwind" fn codeconcat(
    mut fs: *mut FuncState,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut line: i32,
) {
    let mut ie2: *mut Instruction = previousinstruction(fs);
    if (*ie2 >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32
        == OP_CONCAT as i32 as u32
    {
        let mut n: i32 = (*ie2 >> 0 + 7 as i32 + 8 as i32 + 1 as i32
            & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
        freeexp(fs, e2);
        *ie2 = *ie2 & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32)
            | ((*e1).u.info as Instruction) << 0 + 7 as i32
                & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32;
        *ie2 = *ie2 & !(!(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32 + 8 as i32 + 1 as i32)
            | ((n + 1 as i32) as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32
                & !(!(0 as Instruction) << 8 as i32) << 0 + 7 as i32 + 8 as i32 + 1 as i32;
    } else {
        luaK_codeABCk(fs, OP_CONCAT, (*e1).u.info, 2 as i32, 0, 0);
        freeexp(fs, e2);
        luaK_fixline(fs, line);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_posfix(
    mut fs: *mut FuncState,
    mut opr: BinOpr,
    mut e1: *mut expdesc,
    mut e2: *mut expdesc,
    mut line: i32,
) {
    luaK_dischargevars(fs, e2);
    if opr as u32 <= OPR_SHR as i32 as u32
        && constfolding(fs, (opr as u32).wrapping_add(0 as u32) as i32, e1, e2) != 0
    {
        return;
    }
    let mut current_block_30: u64;
    match opr as u32 {
        19 => {
            luaK_concat(fs, &mut (*e2).f, (*e1).f);
            *e1 = *e2;
            current_block_30 = 8180496224585318153;
        }
        20 => {
            luaK_concat(fs, &mut (*e2).t, (*e1).t);
            *e1 = *e2;
            current_block_30 = 8180496224585318153;
        }
        12 => {
            luaK_exp2nextreg(fs, e2);
            codeconcat(fs, e1, e2, line);
            current_block_30 = 8180496224585318153;
        }
        0 | 2 => {
            codecommutative(fs, opr, e1, e2, line);
            current_block_30 = 8180496224585318153;
        }
        1 => {
            if finishbinexpneg(fs, e1, e2, OP_ADDI, line, TM_SUB) != 0 {
                current_block_30 = 8180496224585318153;
            } else {
                current_block_30 = 12599329904712511516;
            }
        }
        5 | 6 | 3 | 4 => {
            current_block_30 = 12599329904712511516;
        }
        7 | 8 | 9 => {
            codebitwise(fs, opr, e1, e2, line);
            current_block_30 = 8180496224585318153;
        }
        10 => {
            if isSCint(e1) != 0 {
                swapexps(e1, e2);
                codebini(fs, OP_SHLI, e1, e2, 1 as i32, line, TM_SHL);
            } else if !(finishbinexpneg(fs, e1, e2, OP_SHRI, line, TM_SHL) != 0) {
                codebinexpval(fs, opr, e1, e2, line);
            }
            current_block_30 = 8180496224585318153;
        }
        11 => {
            if isSCint(e2) != 0 {
                codebini(fs, OP_SHRI, e1, e2, 0, line, TM_SHR);
            } else {
                codebinexpval(fs, opr, e1, e2, line);
            }
            current_block_30 = 8180496224585318153;
        }
        13 | 16 => {
            codeeq(fs, opr, e1, e2);
            current_block_30 = 8180496224585318153;
        }
        17 | 18 => {
            swapexps(e1, e2);
            opr = (opr as u32)
                .wrapping_sub(OPR_GT as i32 as u32)
                .wrapping_add(OPR_LT as i32 as u32) as BinOpr;
            current_block_30 = 1118134448028020070;
        }
        14 | 15 => {
            current_block_30 = 1118134448028020070;
        }
        _ => {
            current_block_30 = 8180496224585318153;
        }
    }
    match current_block_30 {
        12599329904712511516 => {
            codearith(fs, opr, e1, e2, 0, line);
        }
        1118134448028020070 => {
            codeorder(fs, opr, e1, e2);
        }
        _ => {}
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_fixline(mut fs: *mut FuncState, mut line: i32) {
    removelastlineinfo(fs);
    savelineinfo(fs, (*fs).f, line);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_settablesize(
    mut fs: *mut FuncState,
    mut pc: i32,
    mut ra: i32,
    mut asize: i32,
    mut hsize: i32,
) {
    let mut inst: *mut Instruction =
        &mut *((*(*fs).f).code).offset(pc as isize) as *mut Instruction;
    let mut rb: i32 = if hsize != 0 {
        luaO_ceillog2(hsize as u32) + 1 as i32
    } else {
        0
    };
    let mut extra: i32 = asize / (((1 as i32) << 8 as i32) - 1 as i32 + 1 as i32);
    let mut rc: i32 = asize % (((1 as i32) << 8 as i32) - 1 as i32 + 1 as i32);
    let mut k: i32 = (extra > 0) as i32;
    *inst = (OP_NEWTABLE as i32 as Instruction) << 0
        | (ra as Instruction) << 0 + 7 as i32
        | (rb as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32
        | (rc as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
        | (k as Instruction) << 0 + 7 as i32 + 8 as i32;
    *inst.offset(1) =
        (OP_EXTRAARG as i32 as Instruction) << 0 | (extra as Instruction) << 0 + 7 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_setlist(
    mut fs: *mut FuncState,
    mut base: i32,
    mut nelems: i32,
    mut tostore: i32,
) {
    if tostore == -(1 as i32) {
        tostore = 0;
    }
    if nelems <= ((1 as i32) << 8 as i32) - 1 as i32 {
        luaK_codeABCk(fs, OP_SETLIST, base, tostore, nelems, 0);
    } else {
        let mut extra: i32 = nelems / (((1 as i32) << 8 as i32) - 1 as i32 + 1 as i32);
        nelems %= ((1 as i32) << 8 as i32) - 1 as i32 + 1 as i32;
        luaK_codeABCk(fs, OP_SETLIST, base, tostore, nelems, 1 as i32);
        codeextraarg(fs, extra);
    }
    (*fs).freereg = (base + 1 as i32) as lu_byte;
}
unsafe extern "C-unwind" fn finaltarget(mut code: *mut Instruction, mut i: i32) -> i32 {
    let mut count: i32 = 0;
    count = 0;
    while count < 100 {
        let mut pc: Instruction = *code.offset(i as isize);
        if (pc >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32
            != OP_JMP as i32 as u32
        {
            break;
        }
        i += (pc >> 0 + 7 as i32
            & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) << 0)
            as i32
            - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32 >> 1 as i32)
            + 1 as i32;
        count += 1;
        count;
    }
    return i;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaK_finish(mut fs: *mut FuncState) {
    let mut i: i32 = 0;
    let mut p: *mut Proto = (*fs).f;
    i = 0;
    while i < (*fs).pc {
        let mut pc: *mut Instruction = &mut *((*p).code).offset(i as isize) as *mut Instruction;
        let mut current_block_7: u64;
        match (*pc >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32 {
            71 | 72 => {
                if !((*fs).needclose as i32 != 0 || (*p).is_vararg as i32 != 0) {
                    current_block_7 = 12599329904712511516;
                } else {
                    *pc = *pc & !(!(!(0 as Instruction) << 7 as i32) << 0)
                        | (OP_RETURN as i32 as Instruction) << 0
                            & !(!(0 as Instruction) << 7 as i32) << 0;
                    current_block_7 = 11006700562992250127;
                }
            }
            70 | 69 => {
                current_block_7 = 11006700562992250127;
            }
            56 => {
                let mut target: i32 = finaltarget((*p).code, i);
                fixjump(fs, i, target);
                current_block_7 = 12599329904712511516;
            }
            _ => {
                current_block_7 = 12599329904712511516;
            }
        }
        match current_block_7 {
            11006700562992250127 => {
                if (*fs).needclose != 0 {
                    *pc = *pc & !(!(!(0 as Instruction) << 1 as i32) << 0 + 7 as i32 + 8 as i32)
                        | (1 as i32 as Instruction) << 0 + 7 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 1 as i32) << 0 + 7 as i32 + 8 as i32;
                }
                if (*p).is_vararg != 0 {
                    *pc = *pc
                        & !(!(!(0 as Instruction) << 8 as i32)
                            << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                        | (((*p).numparams as i32 + 1 as i32) as Instruction)
                            << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32)
                                << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32;
                }
            }
            _ => {}
        }
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn error_expected(mut ls: *mut LexState, mut token: i32) -> ! {
    luaX_syntaxerror(
        ls,
        luaO_pushfstring((*ls).L, c"%s expected".as_ptr(), luaX_token2str(ls, token)),
    );
}
unsafe extern "C-unwind" fn errorlimit(
    mut fs: *mut FuncState,
    mut limit: i32,
    mut what: *const std::ffi::c_char,
) -> ! {
    let mut L: *mut lua_State = (*(*fs).ls).L;
    let mut msg: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut line: i32 = (*(*fs).f).linedefined;
    let mut where_0: *const std::ffi::c_char = if line == 0 {
        c"main function".as_ptr()
    } else {
        luaO_pushfstring(L, c"function at line %d".as_ptr(), line)
    };
    msg = luaO_pushfstring(
        L,
        c"too many %s (limit is %d) in %s".as_ptr(),
        what,
        limit,
        where_0,
    );
    luaX_syntaxerror((*fs).ls, msg);
}
unsafe extern "C-unwind" fn checklimit(
    mut fs: *mut FuncState,
    mut v: i32,
    mut l: i32,
    mut what: *const std::ffi::c_char,
) {
    if v > l {
        errorlimit(fs, l, what);
    }
}
unsafe extern "C-unwind" fn testnext(mut ls: *mut LexState, mut c: i32) -> i32 {
    if (*ls).t.token == c {
        luaX_next(ls);
        return 1 as i32;
    } else {
        return 0;
    };
}
unsafe extern "C-unwind" fn check(mut ls: *mut LexState, mut c: i32) {
    if (*ls).t.token != c {
        error_expected(ls, c);
    }
}
unsafe extern "C-unwind" fn checknext(mut ls: *mut LexState, mut c: i32) {
    check(ls, c);
    luaX_next(ls);
}
unsafe extern "C-unwind" fn check_match(
    mut ls: *mut LexState,
    mut what: i32,
    mut who: i32,
    mut where_0: i32,
) {
    if ((testnext(ls, what) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        if where_0 == (*ls).linenumber {
            error_expected(ls, what);
        } else {
            luaX_syntaxerror(
                ls,
                luaO_pushfstring(
                    (*ls).L,
                    c"%s expected (to close %s at line %d)".as_ptr(),
                    luaX_token2str(ls, what),
                    luaX_token2str(ls, who),
                    where_0,
                ),
            );
        }
    }
}
unsafe extern "C-unwind" fn str_checkname(mut ls: *mut LexState) -> *mut TString {
    let mut ts: *mut TString = 0 as *mut TString;
    check(ls, TK_NAME as i32);
    ts = (*ls).t.seminfo.ts;
    luaX_next(ls);
    return ts;
}
unsafe extern "C-unwind" fn init_exp(mut e: *mut expdesc, mut k: expkind, mut i: i32) {
    (*e).t = -(1 as i32);
    (*e).f = (*e).t;
    (*e).k = k;
    (*e).u.info = i;
}
unsafe extern "C-unwind" fn codestring(mut e: *mut expdesc, mut s: *mut TString) {
    (*e).t = -(1 as i32);
    (*e).f = (*e).t;
    (*e).k = VKSTR;
    (*e).u.strval = s;
}
unsafe extern "C-unwind" fn codename(mut ls: *mut LexState, mut e: *mut expdesc) {
    codestring(e, str_checkname(ls));
}
unsafe extern "C-unwind" fn registerlocalvar(
    mut ls: *mut LexState,
    mut fs: *mut FuncState,
    mut varname: *mut TString,
) -> i32 {
    let mut f: *mut Proto = (*fs).f;
    let mut oldsize: i32 = (*f).sizelocvars;
    (*f).locvars = luaM_growaux_(
        (*ls).L,
        (*f).locvars as *mut c_void,
        (*fs).ndebugvars as i32,
        &mut (*f).sizelocvars,
        ::core::mem::size_of::<LocVar>() as usize as i32,
        (if 32767 as i32 as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<LocVar>() as usize)
        {
            32767
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<LocVar>() as usize) as u32
        }) as i32,
        c"local variables".as_ptr(),
    ) as *mut LocVar;
    while oldsize < (*f).sizelocvars {
        let fresh95 = oldsize;
        oldsize = oldsize + 1;
        let ref mut fresh96 = (*((*f).locvars).offset(fresh95 as isize)).varname;
        *fresh96 = 0 as *mut TString;
    }
    let ref mut fresh97 = (*((*f).locvars).offset((*fs).ndebugvars as isize)).varname;
    *fresh97 = varname;
    (*((*f).locvars).offset((*fs).ndebugvars as isize)).startpc = (*fs).pc;
    if (*f).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*varname).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            (*ls).L,
            &mut (*(f as *mut GCUnion)).gc,
            &mut (*(varname as *mut GCUnion)).gc,
        );
    } else {
    };
    let fresh98 = (*fs).ndebugvars;
    (*fs).ndebugvars = (*fs).ndebugvars + 1;
    return fresh98 as i32;
}
unsafe extern "C-unwind" fn new_localvar(mut ls: *mut LexState, mut name: *mut TString) -> i32 {
    let mut L: *mut lua_State = (*ls).L;
    let mut fs: *mut FuncState = (*ls).fs;
    let mut dyd: *mut Dyndata = (*ls).dyd;
    let mut var: *mut Vardesc = 0 as *mut Vardesc;
    checklimit(
        fs,
        (*dyd).actvar.n + 1 as i32 - (*fs).firstlocal,
        200,
        c"local variables".as_ptr(),
    );
    (*dyd).actvar.arr = luaM_growaux_(
        L,
        (*dyd).actvar.arr as *mut c_void,
        (*dyd).actvar.n + 1 as i32,
        &mut (*dyd).actvar.size,
        ::core::mem::size_of::<Vardesc>() as usize as i32,
        (if (32767 as i32 * 2 as i32 + 1 as i32) as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Vardesc>() as usize)
        {
            (32767 as i32 * 2 as i32 + 1 as i32) as u32
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Vardesc>() as usize) as u32
        }) as i32,
        c"local variables".as_ptr(),
    ) as *mut Vardesc;
    let fresh99 = (*dyd).actvar.n;
    (*dyd).actvar.n = (*dyd).actvar.n + 1;
    var = &mut *((*dyd).actvar.arr).offset(fresh99 as isize) as *mut Vardesc;
    (*var).vd.kind = 0 as lu_byte;
    (*var).vd.name = name;
    return (*dyd).actvar.n - 1 as i32 - (*fs).firstlocal;
}
unsafe extern "C-unwind" fn getlocalvardesc(mut fs: *mut FuncState, mut vidx: i32) -> *mut Vardesc {
    return &mut *((*(*(*fs).ls).dyd).actvar.arr).offset(((*fs).firstlocal + vidx) as isize)
        as *mut Vardesc;
}
unsafe extern "C-unwind" fn reglevel(mut fs: *mut FuncState, mut nvar: i32) -> i32 {
    loop {
        let fresh100 = nvar;
        nvar = nvar - 1;
        if !(fresh100 > 0) {
            break;
        }
        let mut vd: *mut Vardesc = getlocalvardesc(fs, nvar);
        if (*vd).vd.kind as i32 != 3 as i32 {
            return (*vd).vd.ridx as i32 + 1 as i32;
        }
    }
    return 0;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaY_nvarstack(mut fs: *mut FuncState) -> i32 {
    return reglevel(fs, (*fs).nactvar as i32);
}
unsafe extern "C-unwind" fn localdebuginfo(mut fs: *mut FuncState, mut vidx: i32) -> *mut LocVar {
    let mut vd: *mut Vardesc = getlocalvardesc(fs, vidx);
    if (*vd).vd.kind as i32 == 3 as i32 {
        return 0 as *mut LocVar;
    } else {
        let mut idx: i32 = (*vd).vd.pidx as i32;
        return &mut *((*(*fs).f).locvars).offset(idx as isize) as *mut LocVar;
    };
}
unsafe extern "C-unwind" fn init_var(mut fs: *mut FuncState, mut e: *mut expdesc, mut vidx: i32) {
    (*e).t = -(1 as i32);
    (*e).f = (*e).t;
    (*e).k = VLOCAL;
    (*e).u.var.vidx = vidx as u16;
    (*e).u.var.ridx = (*getlocalvardesc(fs, vidx)).vd.ridx;
}
unsafe extern "C-unwind" fn check_readonly(mut ls: *mut LexState, mut e: *mut expdesc) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut varname: *mut TString = 0 as *mut TString;
    match (*e).k as u32 {
        11 => {
            varname = (*((*(*ls).dyd).actvar.arr).offset((*e).u.info as isize))
                .vd
                .name;
        }
        9 => {
            let mut vardesc: *mut Vardesc = getlocalvardesc(fs, (*e).u.var.vidx as i32);
            if (*vardesc).vd.kind as i32 != 0 {
                varname = (*vardesc).vd.name;
            }
        }
        10 => {
            let mut up: *mut Upvaldesc =
                &mut *((*(*fs).f).upvalues).offset((*e).u.info as isize) as *mut Upvaldesc;
            if (*up).kind as i32 != 0 {
                varname = (*up).name;
            }
        }
        _ => return,
    }
    if !varname.is_null() {
        let mut msg: *const std::ffi::c_char = luaO_pushfstring(
            (*ls).L,
            c"attempt to assign to const variable '%s'".as_ptr(),
            ((*varname).contents).as_mut_ptr(),
        );
        luaK_semerror(ls, msg);
    }
}
unsafe extern "C-unwind" fn adjustlocalvars(mut ls: *mut LexState, mut nvars: i32) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut reglevel_0: i32 = luaY_nvarstack(fs);
    let mut i: i32 = 0;
    i = 0;
    while i < nvars {
        let fresh101 = (*fs).nactvar;
        (*fs).nactvar = ((*fs).nactvar).wrapping_add(1);
        let mut vidx: i32 = fresh101 as i32;
        let mut var: *mut Vardesc = getlocalvardesc(fs, vidx);
        let fresh102 = reglevel_0;
        reglevel_0 = reglevel_0 + 1;
        (*var).vd.ridx = fresh102 as lu_byte;
        (*var).vd.pidx = registerlocalvar(ls, fs, (*var).vd.name) as std::ffi::c_short;
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn removevars(mut fs: *mut FuncState, mut tolevel: i32) {
    (*(*(*fs).ls).dyd).actvar.n -= (*fs).nactvar as i32 - tolevel;
    while (*fs).nactvar as i32 > tolevel {
        (*fs).nactvar = ((*fs).nactvar).wrapping_sub(1);
        let mut var: *mut LocVar = localdebuginfo(fs, (*fs).nactvar as i32);
        if !var.is_null() {
            (*var).endpc = (*fs).pc;
        }
    }
}
unsafe extern "C-unwind" fn searchupvalue(mut fs: *mut FuncState, mut name: *mut TString) -> i32 {
    let mut i: i32 = 0;
    let mut up: *mut Upvaldesc = (*(*fs).f).upvalues;
    i = 0;
    while i < (*fs).nups as i32 {
        if (*up.offset(i as isize)).name == name {
            return i;
        }
        i += 1;
        i;
    }
    return -(1 as i32);
}
unsafe extern "C-unwind" fn allocupvalue(mut fs: *mut FuncState) -> *mut Upvaldesc {
    let mut f: *mut Proto = (*fs).f;
    let mut oldsize: i32 = (*f).sizeupvalues;
    checklimit(
        fs,
        (*fs).nups as i32 + 1 as i32,
        255 as i32,
        c"upvalues".as_ptr(),
    );
    (*f).upvalues = luaM_growaux_(
        (*(*fs).ls).L,
        (*f).upvalues as *mut c_void,
        (*fs).nups as i32,
        &mut (*f).sizeupvalues,
        ::core::mem::size_of::<Upvaldesc>() as usize as i32,
        (if 255 as i32 as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Upvaldesc>() as usize)
        {
            255
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Upvaldesc>() as usize) as u32
        }) as i32,
        c"upvalues".as_ptr(),
    ) as *mut Upvaldesc;
    while oldsize < (*f).sizeupvalues {
        let fresh103 = oldsize;
        oldsize = oldsize + 1;
        let ref mut fresh104 = (*((*f).upvalues).offset(fresh103 as isize)).name;
        *fresh104 = 0 as *mut TString;
    }
    let fresh105 = (*fs).nups;
    (*fs).nups = ((*fs).nups).wrapping_add(1);
    return &mut *((*f).upvalues).offset(fresh105 as isize) as *mut Upvaldesc;
}
unsafe extern "C-unwind" fn newupvalue(
    mut fs: *mut FuncState,
    mut name: *mut TString,
    mut v: *mut expdesc,
) -> i32 {
    let mut up: *mut Upvaldesc = allocupvalue(fs);
    let mut prev: *mut FuncState = (*fs).prev;
    if (*v).k as u32 == VLOCAL as i32 as u32 {
        (*up).instack = 1 as i32 as lu_byte;
        (*up).idx = (*v).u.var.ridx;
        (*up).kind = (*getlocalvardesc(prev, (*v).u.var.vidx as i32)).vd.kind;
    } else {
        (*up).instack = 0 as lu_byte;
        (*up).idx = (*v).u.info as lu_byte;
        (*up).kind = (*((*(*prev).f).upvalues).offset((*v).u.info as isize)).kind;
    }
    (*up).name = name;
    if (*(*fs).f).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*name).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            (*(*fs).ls).L,
            &mut (*((*fs).f as *mut GCUnion)).gc,
            &mut (*(name as *mut GCUnion)).gc,
        );
    } else {
    };
    return (*fs).nups as i32 - 1 as i32;
}
unsafe extern "C-unwind" fn searchvar(
    mut fs: *mut FuncState,
    mut n: *mut TString,
    mut var: *mut expdesc,
) -> i32 {
    let mut i: i32 = 0;
    i = (*fs).nactvar as i32 - 1 as i32;
    while i >= 0 {
        let mut vd: *mut Vardesc = getlocalvardesc(fs, i);
        if n == (*vd).vd.name {
            if (*vd).vd.kind as i32 == 3 as i32 {
                init_exp(var, VCONST, (*fs).firstlocal + i);
            } else {
                init_var(fs, var, i);
            }
            return (*var).k as i32;
        }
        i -= 1;
        i;
    }
    return -(1 as i32);
}
unsafe extern "C-unwind" fn markupval(mut fs: *mut FuncState, mut level: i32) {
    let mut bl: *mut BlockCnt = (*fs).bl;
    while (*bl).nactvar as i32 > level {
        bl = (*bl).previous;
    }
    (*bl).upval = 1 as i32 as lu_byte;
    (*fs).needclose = 1 as i32 as lu_byte;
}
unsafe extern "C-unwind" fn marktobeclosed(mut fs: *mut FuncState) {
    let mut bl: *mut BlockCnt = (*fs).bl;
    (*bl).upval = 1 as i32 as lu_byte;
    (*bl).insidetbc = 1 as i32 as lu_byte;
    (*fs).needclose = 1 as i32 as lu_byte;
}
unsafe extern "C-unwind" fn singlevaraux(
    mut fs: *mut FuncState,
    mut n: *mut TString,
    mut var: *mut expdesc,
    mut base: i32,
) {
    if fs.is_null() {
        init_exp(var, VVOID, 0);
    } else {
        let mut v: i32 = searchvar(fs, n, var);
        if v >= 0 {
            if v == VLOCAL as i32 && base == 0 {
                markupval(fs, (*var).u.var.vidx as i32);
            }
        } else {
            let mut idx: i32 = searchupvalue(fs, n);
            if idx < 0 {
                singlevaraux((*fs).prev, n, var, 0);
                if (*var).k as u32 == VLOCAL as i32 as u32
                    || (*var).k as u32 == VUPVAL as i32 as u32
                {
                    idx = newupvalue(fs, n, var);
                } else {
                    return;
                }
            }
            init_exp(var, VUPVAL, idx);
        }
    };
}
unsafe extern "C-unwind" fn singlevar(mut ls: *mut LexState, mut var: *mut expdesc) {
    let mut varname: *mut TString = str_checkname(ls);
    let mut fs: *mut FuncState = (*ls).fs;
    singlevaraux(fs, varname, var, 1 as i32);
    if (*var).k as u32 == VVOID as i32 as u32 {
        let mut key: expdesc = expdesc {
            k: VVOID,
            u: C2RustUnnamed_11 { ival: 0 },
            t: 0,
            f: 0,
        };
        singlevaraux(fs, (*ls).envn, var, 1 as i32);
        luaK_exp2anyregup(fs, var);
        codestring(&mut key, varname);
        luaK_indexed(fs, var, &mut key);
    }
}
unsafe extern "C-unwind" fn adjust_assign(
    mut ls: *mut LexState,
    mut nvars: i32,
    mut nexps: i32,
    mut e: *mut expdesc,
) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut needed: i32 = nvars - nexps;
    if (*e).k as u32 == VCALL as i32 as u32 || (*e).k as u32 == VVARARG as i32 as u32 {
        let mut extra: i32 = needed + 1 as i32;
        if extra < 0 {
            extra = 0;
        }
        luaK_setreturns(fs, e, extra);
    } else {
        if (*e).k as u32 != VVOID as i32 as u32 {
            luaK_exp2nextreg(fs, e);
        }
        if needed > 0 {
            luaK_nil(fs, (*fs).freereg as i32, needed);
        }
    }
    if needed > 0 {
        luaK_reserveregs(fs, needed);
    } else {
        (*fs).freereg = ((*fs).freereg as i32 + needed) as lu_byte;
    };
}
unsafe extern "C-unwind" fn jumpscopeerror(mut ls: *mut LexState, mut gt: *mut Labeldesc) -> ! {
    let mut varname: *const std::ffi::c_char =
        ((*(*getlocalvardesc((*ls).fs, (*gt).nactvar as i32)).vd.name).contents).as_mut_ptr();
    let mut msg: *const std::ffi::c_char =
        c"<goto %s> at line %d jumps into the scope of local '%s'".as_ptr();
    msg = luaO_pushfstring(
        (*ls).L,
        msg,
        ((*(*gt).name).contents).as_mut_ptr(),
        (*gt).line,
        varname,
    );
    luaK_semerror(ls, msg);
}
unsafe extern "C-unwind" fn solvegoto(
    mut ls: *mut LexState,
    mut g: i32,
    mut label: *mut Labeldesc,
) {
    let mut i: i32 = 0;
    let mut gl: *mut Labellist = &mut (*(*ls).dyd).gt;
    let mut gt: *mut Labeldesc = &mut *((*gl).arr).offset(g as isize) as *mut Labeldesc;
    if ((((*gt).nactvar as i32) < (*label).nactvar as i32) as i32 != 0) as i32 as std::ffi::c_long
        != 0
    {
        jumpscopeerror(ls, gt);
    }
    luaK_patchlist((*ls).fs, (*gt).pc, (*label).pc);
    i = g;
    while i < (*gl).n - 1 as i32 {
        *((*gl).arr).offset(i as isize) = *((*gl).arr).offset((i + 1 as i32) as isize);
        i += 1;
        i;
    }
    (*gl).n -= 1;
    (*gl).n;
}
unsafe extern "C-unwind" fn findlabel(
    mut ls: *mut LexState,
    mut name: *mut TString,
) -> *mut Labeldesc {
    let mut i: i32 = 0;
    let mut dyd: *mut Dyndata = (*ls).dyd;
    i = (*(*ls).fs).firstlabel;
    while i < (*dyd).label.n {
        let mut lb: *mut Labeldesc = &mut *((*dyd).label.arr).offset(i as isize) as *mut Labeldesc;
        if (*lb).name == name {
            return lb;
        }
        i += 1;
        i;
    }
    return 0 as *mut Labeldesc;
}
unsafe extern "C-unwind" fn newlabelentry(
    mut ls: *mut LexState,
    mut l: *mut Labellist,
    mut name: *mut TString,
    mut line: i32,
    mut pc: i32,
) -> i32 {
    let mut n: i32 = (*l).n;
    (*l).arr = luaM_growaux_(
        (*ls).L,
        (*l).arr as *mut c_void,
        n,
        &mut (*l).size,
        ::core::mem::size_of::<Labeldesc>() as usize as i32,
        (if 32767 as i32 as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Labeldesc>() as usize)
        {
            32767
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Labeldesc>() as usize) as u32
        }) as i32,
        c"labels/gotos".as_ptr(),
    ) as *mut Labeldesc;
    let ref mut fresh106 = (*((*l).arr).offset(n as isize)).name;
    *fresh106 = name;
    (*((*l).arr).offset(n as isize)).line = line;
    (*((*l).arr).offset(n as isize)).nactvar = (*(*ls).fs).nactvar;
    (*((*l).arr).offset(n as isize)).close = 0 as lu_byte;
    (*((*l).arr).offset(n as isize)).pc = pc;
    (*l).n = n + 1 as i32;
    return n;
}
unsafe extern "C-unwind" fn newgotoentry(
    mut ls: *mut LexState,
    mut name: *mut TString,
    mut line: i32,
    mut pc: i32,
) -> i32 {
    return newlabelentry(ls, &mut (*(*ls).dyd).gt, name, line, pc);
}
unsafe extern "C-unwind" fn solvegotos(mut ls: *mut LexState, mut lb: *mut Labeldesc) -> i32 {
    let mut gl: *mut Labellist = &mut (*(*ls).dyd).gt;
    let mut i: i32 = (*(*(*ls).fs).bl).firstgoto;
    let mut needsclose: i32 = 0;
    while i < (*gl).n {
        if (*((*gl).arr).offset(i as isize)).name == (*lb).name {
            needsclose |= (*((*gl).arr).offset(i as isize)).close as i32;
            solvegoto(ls, i, lb);
        } else {
            i += 1;
            i;
        }
    }
    return needsclose;
}
unsafe extern "C-unwind" fn createlabel(
    mut ls: *mut LexState,
    mut name: *mut TString,
    mut line: i32,
    mut last: i32,
) -> i32 {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut ll: *mut Labellist = &mut (*(*ls).dyd).label;
    let mut l: i32 = newlabelentry(ls, ll, name, line, luaK_getlabel(fs));
    if last != 0 {
        (*((*ll).arr).offset(l as isize)).nactvar = (*(*fs).bl).nactvar;
    }
    if solvegotos(ls, &mut *((*ll).arr).offset(l as isize)) != 0 {
        luaK_codeABCk(fs, OP_CLOSE, luaY_nvarstack(fs), 0, 0, 0);
        return 1 as i32;
    }
    return 0;
}
unsafe extern "C-unwind" fn movegotosout(mut fs: *mut FuncState, mut bl: *mut BlockCnt) {
    let mut i: i32 = 0;
    let mut gl: *mut Labellist = &mut (*(*(*fs).ls).dyd).gt;
    i = (*bl).firstgoto;
    while i < (*gl).n {
        let mut gt: *mut Labeldesc = &mut *((*gl).arr).offset(i as isize) as *mut Labeldesc;
        if reglevel(fs, (*gt).nactvar as i32) > reglevel(fs, (*bl).nactvar as i32) {
            (*gt).close = ((*gt).close as i32 | (*bl).upval as i32) as lu_byte;
        }
        (*gt).nactvar = (*bl).nactvar;
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn enterblock(
    mut fs: *mut FuncState,
    mut bl: *mut BlockCnt,
    mut isloop: lu_byte,
) {
    (*bl).isloop = isloop;
    (*bl).nactvar = (*fs).nactvar;
    (*bl).firstlabel = (*(*(*fs).ls).dyd).label.n;
    (*bl).firstgoto = (*(*(*fs).ls).dyd).gt.n;
    (*bl).upval = 0 as lu_byte;
    (*bl).insidetbc =
        (!((*fs).bl).is_null() && (*(*fs).bl).insidetbc as i32 != 0) as i32 as lu_byte;
    (*bl).previous = (*fs).bl;
    (*fs).bl = bl;
}
unsafe extern "C-unwind" fn undefgoto(mut ls: *mut LexState, mut gt: *mut Labeldesc) -> ! {
    let mut msg: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if (*gt).name
        == luaS_newlstr(
            (*ls).L,
            c"break".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 6]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        )
    {
        msg = c"break outside loop at line %d".as_ptr();
        msg = luaO_pushfstring((*ls).L, msg, (*gt).line);
    } else {
        msg = c"no visible label '%s' for <goto> at line %d".as_ptr();
        msg = luaO_pushfstring(
            (*ls).L,
            msg,
            ((*(*gt).name).contents).as_mut_ptr(),
            (*gt).line,
        );
    }
    luaK_semerror(ls, msg);
}
unsafe extern "C-unwind" fn leaveblock(mut fs: *mut FuncState) {
    let mut bl: *mut BlockCnt = (*fs).bl;
    let mut ls: *mut LexState = (*fs).ls;
    let mut hasclose: i32 = 0;
    let mut stklevel: i32 = reglevel(fs, (*bl).nactvar as i32);
    removevars(fs, (*bl).nactvar as i32);
    if (*bl).isloop != 0 {
        hasclose = createlabel(
            ls,
            luaS_newlstr(
                (*ls).L,
                c"break".as_ptr(),
                (::core::mem::size_of::<[std::ffi::c_char; 6]>() as usize)
                    .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                    .wrapping_sub(1),
            ),
            0,
            0,
        );
    }
    if hasclose == 0 && !((*bl).previous).is_null() && (*bl).upval as i32 != 0 {
        luaK_codeABCk(fs, OP_CLOSE, stklevel, 0, 0, 0);
    }
    (*fs).freereg = stklevel as lu_byte;
    (*(*ls).dyd).label.n = (*bl).firstlabel;
    (*fs).bl = (*bl).previous;
    if !((*bl).previous).is_null() {
        movegotosout(fs, bl);
    } else if (*bl).firstgoto < (*(*ls).dyd).gt.n {
        undefgoto(
            ls,
            &mut *((*(*ls).dyd).gt.arr).offset((*bl).firstgoto as isize),
        );
    }
}
unsafe extern "C-unwind" fn addprototype(mut ls: *mut LexState) -> *mut Proto {
    let mut clp: *mut Proto = 0 as *mut Proto;
    let mut L: *mut lua_State = (*ls).L;
    let mut fs: *mut FuncState = (*ls).fs;
    let mut f: *mut Proto = (*fs).f;
    if (*fs).np >= (*f).sizep {
        let mut oldsize: i32 = (*f).sizep;
        (*f).p = luaM_growaux_(
            L,
            (*f).p as *mut c_void,
            (*fs).np,
            &mut (*f).sizep,
            ::core::mem::size_of::<*mut Proto>() as usize as i32,
            (if (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32) as size_t
                <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<*mut Proto>() as usize)
            {
                (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32) as u32
            } else {
                (!(0 as size_t)).wrapping_div(::core::mem::size_of::<*mut Proto>() as usize) as u32
            }) as i32,
            c"functions".as_ptr(),
        ) as *mut *mut Proto;
        while oldsize < (*f).sizep {
            let fresh107 = oldsize;
            oldsize = oldsize + 1;
            let ref mut fresh108 = *((*f).p).offset(fresh107 as isize);
            *fresh108 = 0 as *mut Proto;
        }
    }
    clp = luaF_newproto(L);
    let fresh109 = (*fs).np;
    (*fs).np = (*fs).np + 1;
    let ref mut fresh110 = *((*f).p).offset(fresh109 as isize);
    *fresh110 = clp;
    if (*f).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*clp).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            L,
            &mut (*(f as *mut GCUnion)).gc,
            &mut (*(clp as *mut GCUnion)).gc,
        );
    } else {
    };
    return clp;
}
unsafe extern "C-unwind" fn codeclosure(mut ls: *mut LexState, mut v: *mut expdesc) {
    let mut fs: *mut FuncState = (*(*ls).fs).prev;
    init_exp(
        v,
        VRELOC,
        luaK_codeABx(fs, OP_CLOSURE, 0, ((*fs).np - 1 as i32) as u32),
    );
    luaK_exp2nextreg(fs, v);
}
unsafe extern "C-unwind" fn open_func(
    mut ls: *mut LexState,
    mut fs: *mut FuncState,
    mut bl: *mut BlockCnt,
) {
    let mut f: *mut Proto = (*fs).f;
    (*fs).prev = (*ls).fs;
    (*fs).ls = ls;
    (*ls).fs = fs;
    (*fs).pc = 0;
    (*fs).previousline = (*f).linedefined;
    (*fs).iwthabs = 0 as lu_byte;
    (*fs).lasttarget = 0;
    (*fs).freereg = 0 as lu_byte;
    (*fs).nk = 0;
    (*fs).nabslineinfo = 0;
    (*fs).np = 0;
    (*fs).nups = 0 as lu_byte;
    (*fs).ndebugvars = 0 as std::ffi::c_short;
    (*fs).nactvar = 0 as lu_byte;
    (*fs).needclose = 0 as lu_byte;
    (*fs).firstlocal = (*(*ls).dyd).actvar.n;
    (*fs).firstlabel = (*(*ls).dyd).label.n;
    (*fs).bl = 0 as *mut BlockCnt;
    (*f).source = (*ls).source;
    if (*f).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*(*f).source).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            (*ls).L,
            &mut (*(f as *mut GCUnion)).gc,
            &mut (*((*f).source as *mut GCUnion)).gc,
        );
    } else {
    };
    (*f).maxstacksize = 2 as i32 as lu_byte;
    enterblock(fs, bl, 0 as lu_byte);
}
unsafe extern "C-unwind" fn close_func(mut ls: *mut LexState) {
    let mut L: *mut lua_State = (*ls).L;
    let mut fs: *mut FuncState = (*ls).fs;
    let mut f: *mut Proto = (*fs).f;
    luaK_ret(fs, luaY_nvarstack(fs), 0);
    leaveblock(fs);
    luaK_finish(fs);
    (*f).code = luaM_shrinkvector_(
        L,
        (*f).code as *mut c_void,
        &mut (*f).sizecode,
        (*fs).pc,
        ::core::mem::size_of::<Instruction>() as usize as i32,
    ) as *mut Instruction;
    (*f).lineinfo = luaM_shrinkvector_(
        L,
        (*f).lineinfo as *mut c_void,
        &mut (*f).sizelineinfo,
        (*fs).pc,
        ::core::mem::size_of::<ls_byte>() as usize as i32,
    ) as *mut ls_byte;
    (*f).abslineinfo = luaM_shrinkvector_(
        L,
        (*f).abslineinfo as *mut c_void,
        &mut (*f).sizeabslineinfo,
        (*fs).nabslineinfo,
        ::core::mem::size_of::<AbsLineInfo>() as usize as i32,
    ) as *mut AbsLineInfo;
    (*f).k = luaM_shrinkvector_(
        L,
        (*f).k as *mut c_void,
        &mut (*f).sizek,
        (*fs).nk,
        ::core::mem::size_of::<TValue>() as usize as i32,
    ) as *mut TValue;
    (*f).p = luaM_shrinkvector_(
        L,
        (*f).p as *mut c_void,
        &mut (*f).sizep,
        (*fs).np,
        ::core::mem::size_of::<*mut Proto>() as usize as i32,
    ) as *mut *mut Proto;
    (*f).locvars = luaM_shrinkvector_(
        L,
        (*f).locvars as *mut c_void,
        &mut (*f).sizelocvars,
        (*fs).ndebugvars as i32,
        ::core::mem::size_of::<LocVar>() as usize as i32,
    ) as *mut LocVar;
    (*f).upvalues = luaM_shrinkvector_(
        L,
        (*f).upvalues as *mut c_void,
        &mut (*f).sizeupvalues,
        (*fs).nups as i32,
        ::core::mem::size_of::<Upvaldesc>() as usize as i32,
    ) as *mut Upvaldesc;
    (*ls).fs = (*fs).prev;
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
}
unsafe extern "C-unwind" fn block_follow(mut ls: *mut LexState, mut withuntil: i32) -> i32 {
    match (*ls).t.token {
        259 | 260 | 261 | 288 => return 1 as i32,
        276 => return withuntil,
        _ => return 0,
    };
}
unsafe extern "C-unwind" fn statlist(mut ls: *mut LexState) {
    while block_follow(ls, 1 as i32) == 0 {
        if (*ls).t.token == TK_RETURN as i32 {
            statement(ls);
            return;
        }
        statement(ls);
    }
}
unsafe extern "C-unwind" fn fieldsel(mut ls: *mut LexState, mut v: *mut expdesc) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut key: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    luaK_exp2anyregup(fs, v);
    luaX_next(ls);
    codename(ls, &mut key);
    luaK_indexed(fs, v, &mut key);
}
unsafe extern "C-unwind" fn yindex(mut ls: *mut LexState, mut v: *mut expdesc) {
    luaX_next(ls);
    expr(ls, v);
    luaK_exp2val((*ls).fs, v);
    checknext(ls, ']' as i32);
}
unsafe extern "C-unwind" fn recfield(mut ls: *mut LexState, mut cc: *mut ConsControl) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut reg: i32 = (*(*ls).fs).freereg as i32;
    let mut tab: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut key: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut val: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    if (*ls).t.token == TK_NAME as i32 {
        checklimit(
            fs,
            (*cc).nh,
            2147483647 as i32,
            c"items in a constructor".as_ptr(),
        );
        codename(ls, &mut key);
    } else {
        yindex(ls, &mut key);
    }
    (*cc).nh += 1;
    (*cc).nh;
    checknext(ls, '=' as i32);
    tab = *(*cc).t;
    luaK_indexed(fs, &mut tab, &mut key);
    expr(ls, &mut val);
    luaK_storevar(fs, &mut tab, &mut val);
    (*fs).freereg = reg as lu_byte;
}
unsafe extern "C-unwind" fn closelistfield(mut fs: *mut FuncState, mut cc: *mut ConsControl) {
    if (*cc).v.k as u32 == VVOID as i32 as u32 {
        return;
    }
    luaK_exp2nextreg(fs, &mut (*cc).v);
    (*cc).v.k = VVOID;
    if (*cc).tostore == 50 {
        luaK_setlist(fs, (*(*cc).t).u.info, (*cc).na, (*cc).tostore);
        (*cc).na += (*cc).tostore;
        (*cc).tostore = 0;
    }
}
unsafe extern "C-unwind" fn lastlistfield(mut fs: *mut FuncState, mut cc: *mut ConsControl) {
    if (*cc).tostore == 0 {
        return;
    }
    if (*cc).v.k as u32 == VCALL as i32 as u32 || (*cc).v.k as u32 == VVARARG as i32 as u32 {
        luaK_setreturns(fs, &mut (*cc).v, -(1 as i32));
        luaK_setlist(fs, (*(*cc).t).u.info, (*cc).na, -(1 as i32));
        (*cc).na -= 1;
        (*cc).na;
    } else {
        if (*cc).v.k as u32 != VVOID as i32 as u32 {
            luaK_exp2nextreg(fs, &mut (*cc).v);
        }
        luaK_setlist(fs, (*(*cc).t).u.info, (*cc).na, (*cc).tostore);
    }
    (*cc).na += (*cc).tostore;
}
unsafe extern "C-unwind" fn listfield(mut ls: *mut LexState, mut cc: *mut ConsControl) {
    expr(ls, &mut (*cc).v);
    (*cc).tostore += 1;
    (*cc).tostore;
}
unsafe extern "C-unwind" fn field(mut ls: *mut LexState, mut cc: *mut ConsControl) {
    match (*ls).t.token {
        291 => {
            if luaX_lookahead(ls) != '=' as i32 {
                listfield(ls, cc);
            } else {
                recfield(ls, cc);
            }
        }
        91 => {
            recfield(ls, cc);
        }
        _ => {
            listfield(ls, cc);
        }
    };
}
unsafe extern "C-unwind" fn constructor(mut ls: *mut LexState, mut t: *mut expdesc) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut line: i32 = (*ls).linenumber;
    let mut pc: i32 = luaK_codeABCk(fs, OP_NEWTABLE, 0, 0, 0, 0);
    let mut cc: ConsControl = ConsControl {
        v: expdesc {
            k: VVOID,
            u: C2RustUnnamed_11 { ival: 0 },
            t: 0,
            f: 0,
        },
        t: 0 as *mut expdesc,
        nh: 0,
        na: 0,
        tostore: 0,
    };
    luaK_code(fs, 0 as Instruction);
    cc.tostore = 0;
    cc.nh = cc.tostore;
    cc.na = cc.nh;
    cc.t = t;
    init_exp(t, VNONRELOC, (*fs).freereg as i32);
    luaK_reserveregs(fs, 1 as i32);
    init_exp(&mut cc.v, VVOID, 0);
    checknext(ls, '{' as i32);
    while !((*ls).t.token == '}' as i32) {
        closelistfield(fs, &mut cc);
        field(ls, &mut cc);
        if !(testnext(ls, ',' as i32) != 0 || testnext(ls, ';' as i32) != 0) {
            break;
        }
    }
    check_match(ls, '}' as i32, '{' as i32, line);
    lastlistfield(fs, &mut cc);
    luaK_settablesize(fs, pc, (*t).u.info, cc.na, cc.nh);
}
unsafe extern "C-unwind" fn setvararg(mut fs: *mut FuncState, mut nparams: i32) {
    (*(*fs).f).is_vararg = 1 as i32 as lu_byte;
    luaK_codeABCk(fs, OP_VARARGPREP, nparams, 0, 0, 0);
}
unsafe extern "C-unwind" fn parlist(mut ls: *mut LexState) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut f: *mut Proto = (*fs).f;
    let mut nparams: i32 = 0;
    let mut isvararg: i32 = 0;
    if (*ls).t.token != ')' as i32 {
        loop {
            match (*ls).t.token {
                291 => {
                    new_localvar(ls, str_checkname(ls));
                    nparams += 1;
                    nparams;
                }
                280 => {
                    luaX_next(ls);
                    isvararg = 1 as i32;
                }
                _ => {
                    luaX_syntaxerror(ls, c"<name> or '...' expected".as_ptr());
                }
            }
            if !(isvararg == 0 && testnext(ls, ',' as i32) != 0) {
                break;
            }
        }
    }
    adjustlocalvars(ls, nparams);
    (*f).numparams = (*fs).nactvar;
    if isvararg != 0 {
        setvararg(fs, (*f).numparams as i32);
    }
    luaK_reserveregs(fs, (*fs).nactvar as i32);
}
unsafe extern "C-unwind" fn body(
    mut ls: *mut LexState,
    mut e: *mut expdesc,
    mut ismethod: i32,
    mut line: i32,
) {
    let mut new_fs: FuncState = FuncState {
        f: 0 as *mut Proto,
        prev: 0 as *mut FuncState,
        ls: 0 as *mut LexState,
        bl: 0 as *mut BlockCnt,
        pc: 0,
        lasttarget: 0,
        previousline: 0,
        nk: 0,
        np: 0,
        nabslineinfo: 0,
        firstlocal: 0,
        firstlabel: 0,
        ndebugvars: 0,
        nactvar: 0,
        nups: 0,
        freereg: 0,
        iwthabs: 0,
        needclose: 0,
    };
    let mut bl: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    new_fs.f = addprototype(ls);
    (*new_fs.f).linedefined = line;
    open_func(ls, &mut new_fs, &mut bl);
    checknext(ls, '(' as i32);
    if ismethod != 0 {
        new_localvar(
            ls,
            luaX_newstring(
                ls,
                c"self".as_ptr(),
                (::core::mem::size_of::<[std::ffi::c_char; 5]>() as usize)
                    .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                    .wrapping_sub(1),
            ),
        );
        adjustlocalvars(ls, 1 as i32);
    }
    parlist(ls);
    checknext(ls, ')' as i32);
    statlist(ls);
    (*new_fs.f).lastlinedefined = (*ls).linenumber;
    check_match(ls, TK_END as i32, TK_FUNCTION as i32, line);
    codeclosure(ls, e);
    close_func(ls);
}
unsafe extern "C-unwind" fn explist(mut ls: *mut LexState, mut v: *mut expdesc) -> i32 {
    let mut n: i32 = 1 as i32;
    expr(ls, v);
    while testnext(ls, ',' as i32) != 0 {
        luaK_exp2nextreg((*ls).fs, v);
        expr(ls, v);
        n += 1;
        n;
    }
    return n;
}
unsafe extern "C-unwind" fn funcargs(mut ls: *mut LexState, mut f: *mut expdesc) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut args: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut base: i32 = 0;
    let mut nparams: i32 = 0;
    let mut line: i32 = (*ls).linenumber;
    match (*ls).t.token {
        40 => {
            luaX_next(ls);
            if (*ls).t.token == ')' as i32 {
                args.k = VVOID;
            } else {
                explist(ls, &mut args);
                if args.k as u32 == VCALL as i32 as u32 || args.k as u32 == VVARARG as i32 as u32 {
                    luaK_setreturns(fs, &mut args, -(1 as i32));
                }
            }
            check_match(ls, ')' as i32, '(' as i32, line);
        }
        123 => {
            constructor(ls, &mut args);
        }
        292 => {
            codestring(&mut args, (*ls).t.seminfo.ts);
            luaX_next(ls);
        }
        _ => {
            luaX_syntaxerror(ls, c"function arguments expected".as_ptr());
        }
    }
    base = (*f).u.info;
    if args.k as u32 == VCALL as i32 as u32 || args.k as u32 == VVARARG as i32 as u32 {
        nparams = -(1 as i32);
    } else {
        if args.k as u32 != VVOID as i32 as u32 {
            luaK_exp2nextreg(fs, &mut args);
        }
        nparams = (*fs).freereg as i32 - (base + 1 as i32);
    }
    init_exp(
        f,
        VCALL,
        luaK_codeABCk(fs, OP_CALL, base, nparams + 1 as i32, 2 as i32, 0),
    );
    luaK_fixline(fs, line);
    (*fs).freereg = (base + 1 as i32) as lu_byte;
}
unsafe extern "C-unwind" fn primaryexp(mut ls: *mut LexState, mut v: *mut expdesc) {
    match (*ls).t.token {
        40 => {
            let mut line: i32 = (*ls).linenumber;
            luaX_next(ls);
            expr(ls, v);
            check_match(ls, ')' as i32, '(' as i32, line);
            luaK_dischargevars((*ls).fs, v);
            return;
        }
        291 => {
            singlevar(ls, v);
            return;
        }
        _ => {
            luaX_syntaxerror(ls, c"unexpected symbol".as_ptr());
        }
    };
}
unsafe extern "C-unwind" fn suffixedexp(mut ls: *mut LexState, mut v: *mut expdesc) {
    let mut fs: *mut FuncState = (*ls).fs;
    primaryexp(ls, v);
    loop {
        match (*ls).t.token {
            46 => {
                fieldsel(ls, v);
            }
            91 => {
                let mut key: expdesc = expdesc {
                    k: VVOID,
                    u: C2RustUnnamed_11 { ival: 0 },
                    t: 0,
                    f: 0,
                };
                luaK_exp2anyregup(fs, v);
                yindex(ls, &mut key);
                luaK_indexed(fs, v, &mut key);
            }
            58 => {
                let mut key_0: expdesc = expdesc {
                    k: VVOID,
                    u: C2RustUnnamed_11 { ival: 0 },
                    t: 0,
                    f: 0,
                };
                luaX_next(ls);
                codename(ls, &mut key_0);
                luaK_self(fs, v, &mut key_0);
                funcargs(ls, v);
            }
            40 | 292 | 123 => {
                luaK_exp2nextreg(fs, v);
                funcargs(ls, v);
            }
            _ => return,
        }
    }
}
unsafe extern "C-unwind" fn simpleexp(mut ls: *mut LexState, mut v: *mut expdesc) {
    match (*ls).t.token {
        289 => {
            init_exp(v, VKFLT, 0);
            (*v).u.nval = (*ls).t.seminfo.r;
        }
        290 => {
            init_exp(v, VKINT, 0);
            (*v).u.ival = (*ls).t.seminfo.i;
        }
        292 => {
            codestring(v, (*ls).t.seminfo.ts);
        }
        269 => {
            init_exp(v, VNIL, 0);
        }
        275 => {
            init_exp(v, VTRUE, 0);
        }
        262 => {
            init_exp(v, VFALSE, 0);
        }
        280 => {
            let mut fs: *mut FuncState = (*ls).fs;
            if (*(*fs).f).is_vararg == 0 {
                luaX_syntaxerror(ls, c"cannot use '...' outside a vararg function".as_ptr());
            }
            init_exp(v, VVARARG, luaK_codeABCk(fs, OP_VARARG, 0, 0, 1 as i32, 0));
        }
        123 => {
            constructor(ls, v);
            return;
        }
        264 => {
            luaX_next(ls);
            body(ls, v, 0, (*ls).linenumber);
            return;
        }
        _ => {
            suffixedexp(ls, v);
            return;
        }
    }
    luaX_next(ls);
}
unsafe extern "C-unwind" fn getunopr(mut op: i32) -> UnOpr {
    match op {
        270 => return OPR_NOT,
        45 => return OPR_MINUS,
        126 => return OPR_BNOT,
        35 => return OPR_LEN,
        _ => return OPR_NOUNOPR,
    };
}
unsafe extern "C-unwind" fn getbinopr(mut op: i32) -> BinOpr {
    match op {
        43 => return OPR_ADD,
        45 => return OPR_SUB,
        42 => return OPR_MUL,
        37 => return OPR_MOD,
        94 => return OPR_POW,
        47 => return OPR_DIV,
        278 => return OPR_IDIV,
        38 => return OPR_BAND,
        124 => return OPR_BOR,
        126 => return OPR_BXOR,
        285 => return OPR_SHL,
        286 => return OPR_SHR,
        279 => return OPR_CONCAT,
        284 => return OPR_NE,
        281 => return OPR_EQ,
        60 => return OPR_LT,
        283 => return OPR_LE,
        62 => return OPR_GT,
        282 => return OPR_GE,
        256 => return OPR_AND,
        271 => return OPR_OR,
        _ => return OPR_NOBINOPR,
    };
}
static mut priority: [C2RustUnnamed_14; 21] = [
    {
        let mut init = C2RustUnnamed_14 {
            left: 10 as lu_byte,
            right: 10 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 10 as lu_byte,
            right: 10 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 11 as i32 as lu_byte,
            right: 11 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 11 as i32 as lu_byte,
            right: 11 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 14 as i32 as lu_byte,
            right: 13 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 11 as i32 as lu_byte,
            right: 11 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 11 as i32 as lu_byte,
            right: 11 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 6 as i32 as lu_byte,
            right: 6 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 4 as i32 as lu_byte,
            right: 4 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 5 as i32 as lu_byte,
            right: 5 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 7 as i32 as lu_byte,
            right: 7 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 7 as i32 as lu_byte,
            right: 7 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 9 as i32 as lu_byte,
            right: 8 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 3 as i32 as lu_byte,
            right: 3 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 3 as i32 as lu_byte,
            right: 3 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 3 as i32 as lu_byte,
            right: 3 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 3 as i32 as lu_byte,
            right: 3 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 3 as i32 as lu_byte,
            right: 3 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 3 as i32 as lu_byte,
            right: 3 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 2 as i32 as lu_byte,
            right: 2 as i32 as lu_byte,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_14 {
            left: 1 as i32 as lu_byte,
            right: 1 as i32 as lu_byte,
        };
        init
    },
];
unsafe extern "C-unwind" fn subexpr(
    mut ls: *mut LexState,
    mut v: *mut expdesc,
    mut limit: i32,
) -> BinOpr {
    let mut op: BinOpr = OPR_ADD;
    let mut uop: UnOpr = OPR_MINUS;
    luaE_incCstack((*ls).L);
    uop = getunopr((*ls).t.token);
    if uop as u32 != OPR_NOUNOPR as i32 as u32 {
        let mut line: i32 = (*ls).linenumber;
        luaX_next(ls);
        subexpr(ls, v, 12 as i32);
        luaK_prefix((*ls).fs, uop, v, line);
    } else {
        simpleexp(ls, v);
    }
    op = getbinopr((*ls).t.token);
    while op as u32 != OPR_NOBINOPR as i32 as u32 && priority[op as usize].left as i32 > limit {
        let mut v2: expdesc = expdesc {
            k: VVOID,
            u: C2RustUnnamed_11 { ival: 0 },
            t: 0,
            f: 0,
        };
        let mut nextop: BinOpr = OPR_ADD;
        let mut line_0: i32 = (*ls).linenumber;
        luaX_next(ls);
        luaK_infix((*ls).fs, op, v);
        nextop = subexpr(ls, &mut v2, priority[op as usize].right as i32);
        luaK_posfix((*ls).fs, op, v, &mut v2, line_0);
        op = nextop;
    }
    (*(*ls).L).nCcalls = ((*(*ls).L).nCcalls).wrapping_sub(1);
    (*(*ls).L).nCcalls;
    return op;
}
unsafe extern "C-unwind" fn expr(mut ls: *mut LexState, mut v: *mut expdesc) {
    subexpr(ls, v, 0);
}
unsafe extern "C-unwind" fn block(mut ls: *mut LexState) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut bl: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    enterblock(fs, &mut bl, 0 as lu_byte);
    statlist(ls);
    leaveblock(fs);
}
unsafe extern "C-unwind" fn check_conflict(
    mut ls: *mut LexState,
    mut lh: *mut LHS_assign,
    mut v: *mut expdesc,
) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut extra: i32 = (*fs).freereg as i32;
    let mut conflict: i32 = 0;
    while !lh.is_null() {
        if VINDEXED as i32 as u32 <= (*lh).v.k as u32 && (*lh).v.k as u32 <= VINDEXSTR as i32 as u32
        {
            if (*lh).v.k as u32 == VINDEXUP as i32 as u32 {
                if (*v).k as u32 == VUPVAL as i32 as u32 && (*lh).v.u.ind.t as i32 == (*v).u.info {
                    conflict = 1 as i32;
                    (*lh).v.k = VINDEXSTR;
                    (*lh).v.u.ind.t = extra as lu_byte;
                }
            } else {
                if (*v).k as u32 == VLOCAL as i32 as u32
                    && (*lh).v.u.ind.t as i32 == (*v).u.var.ridx as i32
                {
                    conflict = 1 as i32;
                    (*lh).v.u.ind.t = extra as lu_byte;
                }
                if (*lh).v.k as u32 == VINDEXED as i32 as u32
                    && (*v).k as u32 == VLOCAL as i32 as u32
                    && (*lh).v.u.ind.idx as i32 == (*v).u.var.ridx as i32
                {
                    conflict = 1 as i32;
                    (*lh).v.u.ind.idx = extra as std::ffi::c_short;
                }
            }
        }
        lh = (*lh).prev;
    }
    if conflict != 0 {
        if (*v).k as u32 == VLOCAL as i32 as u32 {
            luaK_codeABCk(fs, OP_MOVE, extra, (*v).u.var.ridx as i32, 0, 0);
        } else {
            luaK_codeABCk(fs, OP_GETUPVAL, extra, (*v).u.info, 0, 0);
        }
        luaK_reserveregs(fs, 1 as i32);
    }
}
unsafe extern "C-unwind" fn restassign(
    mut ls: *mut LexState,
    mut lh: *mut LHS_assign,
    mut nvars: i32,
) {
    let mut e: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    if !(VLOCAL as i32 as u32 <= (*lh).v.k as u32 && (*lh).v.k as u32 <= VINDEXSTR as i32 as u32) {
        luaX_syntaxerror(ls, c"syntax error".as_ptr());
    }
    check_readonly(ls, &mut (*lh).v);
    if testnext(ls, ',' as i32) != 0 {
        let mut nv: LHS_assign = LHS_assign {
            prev: 0 as *mut LHS_assign,
            v: expdesc {
                k: VVOID,
                u: C2RustUnnamed_11 { ival: 0 },
                t: 0,
                f: 0,
            },
        };
        nv.prev = lh;
        suffixedexp(ls, &mut nv.v);
        if !(VINDEXED as i32 as u32 <= nv.v.k as u32 && nv.v.k as u32 <= VINDEXSTR as i32 as u32) {
            check_conflict(ls, lh, &mut nv.v);
        }
        luaE_incCstack((*ls).L);
        restassign(ls, &mut nv, nvars + 1 as i32);
        (*(*ls).L).nCcalls = ((*(*ls).L).nCcalls).wrapping_sub(1);
        (*(*ls).L).nCcalls;
    } else {
        let mut nexps: i32 = 0;
        checknext(ls, '=' as i32);
        nexps = explist(ls, &mut e);
        if nexps != nvars {
            adjust_assign(ls, nvars, nexps, &mut e);
        } else {
            luaK_setoneret((*ls).fs, &mut e);
            luaK_storevar((*ls).fs, &mut (*lh).v, &mut e);
            return;
        }
    }
    init_exp(&mut e, VNONRELOC, (*(*ls).fs).freereg as i32 - 1 as i32);
    luaK_storevar((*ls).fs, &mut (*lh).v, &mut e);
}
unsafe extern "C-unwind" fn cond(mut ls: *mut LexState) -> i32 {
    let mut v: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    expr(ls, &mut v);
    if v.k as u32 == VNIL as i32 as u32 {
        v.k = VFALSE;
    }
    luaK_goiftrue((*ls).fs, &mut v);
    return v.f;
}
unsafe extern "C-unwind" fn gotostat(mut ls: *mut LexState) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut line: i32 = (*ls).linenumber;
    let mut name: *mut TString = str_checkname(ls);
    let mut lb: *mut Labeldesc = findlabel(ls, name);
    if lb.is_null() {
        newgotoentry(ls, name, line, luaK_jump(fs));
    } else {
        let mut lblevel: i32 = reglevel(fs, (*lb).nactvar as i32);
        if luaY_nvarstack(fs) > lblevel {
            luaK_codeABCk(fs, OP_CLOSE, lblevel, 0, 0, 0);
        }
        luaK_patchlist(fs, luaK_jump(fs), (*lb).pc);
    };
}
unsafe extern "C-unwind" fn breakstat(mut ls: *mut LexState) {
    let mut line: i32 = (*ls).linenumber;
    luaX_next(ls);
    newgotoentry(
        ls,
        luaS_newlstr(
            (*ls).L,
            c"break".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 6]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
        line,
        luaK_jump((*ls).fs),
    );
}
unsafe extern "C-unwind" fn checkrepeated(mut ls: *mut LexState, mut name: *mut TString) {
    let mut lb: *mut Labeldesc = findlabel(ls, name);
    if ((lb != 0 as *mut c_void as *mut Labeldesc) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        let mut msg: *const std::ffi::c_char = c"label '%s' already defined on line %d".as_ptr();
        msg = luaO_pushfstring((*ls).L, msg, ((*name).contents).as_mut_ptr(), (*lb).line);
        luaK_semerror(ls, msg);
    }
}
unsafe extern "C-unwind" fn labelstat(
    mut ls: *mut LexState,
    mut name: *mut TString,
    mut line: i32,
) {
    checknext(ls, TK_DBCOLON as i32);
    while (*ls).t.token == ';' as i32 || (*ls).t.token == TK_DBCOLON as i32 {
        statement(ls);
    }
    checkrepeated(ls, name);
    createlabel(ls, name, line, block_follow(ls, 0));
}
unsafe extern "C-unwind" fn whilestat(mut ls: *mut LexState, mut line: i32) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut whileinit: i32 = 0;
    let mut condexit: i32 = 0;
    let mut bl: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    luaX_next(ls);
    whileinit = luaK_getlabel(fs);
    condexit = cond(ls);
    enterblock(fs, &mut bl, 1 as i32 as lu_byte);
    checknext(ls, TK_DO as i32);
    block(ls);
    luaK_patchlist(fs, luaK_jump(fs), whileinit);
    check_match(ls, TK_END as i32, TK_WHILE as i32, line);
    leaveblock(fs);
    luaK_patchtohere(fs, condexit);
}
unsafe extern "C-unwind" fn repeatstat(mut ls: *mut LexState, mut line: i32) {
    let mut condexit: i32 = 0;
    let mut fs: *mut FuncState = (*ls).fs;
    let mut repeat_init: i32 = luaK_getlabel(fs);
    let mut bl1: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    let mut bl2: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    enterblock(fs, &mut bl1, 1 as i32 as lu_byte);
    enterblock(fs, &mut bl2, 0 as lu_byte);
    luaX_next(ls);
    statlist(ls);
    check_match(ls, TK_UNTIL as i32, TK_REPEAT as i32, line);
    condexit = cond(ls);
    leaveblock(fs);
    if bl2.upval != 0 {
        let mut exit_0: i32 = luaK_jump(fs);
        luaK_patchtohere(fs, condexit);
        luaK_codeABCk(fs, OP_CLOSE, reglevel(fs, bl2.nactvar as i32), 0, 0, 0);
        condexit = luaK_jump(fs);
        luaK_patchtohere(fs, exit_0);
    }
    luaK_patchlist(fs, condexit, repeat_init);
    leaveblock(fs);
}
unsafe extern "C-unwind" fn exp1(mut ls: *mut LexState) {
    let mut e: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    expr(ls, &mut e);
    luaK_exp2nextreg((*ls).fs, &mut e);
}
unsafe extern "C-unwind" fn fixforjump(
    mut fs: *mut FuncState,
    mut pc: i32,
    mut dest: i32,
    mut back: i32,
) {
    let mut jmp: *mut Instruction = &mut *((*(*fs).f).code).offset(pc as isize) as *mut Instruction;
    let mut offset: i32 = dest - (pc + 1 as i32);
    if back != 0 {
        offset = -offset;
    }
    if ((offset > ((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
    {
        luaX_syntaxerror((*fs).ls, c"control structure too long".as_ptr());
    }
    *jmp = *jmp
        & !(!(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0 + 7 as i32 + 8 as i32)
        | (offset as Instruction) << 0 + 7 as i32 + 8 as i32
            & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0 + 7 as i32 + 8 as i32;
}
unsafe extern "C-unwind" fn forbody(
    mut ls: *mut LexState,
    mut base: i32,
    mut line: i32,
    mut nvars: i32,
    mut isgen: i32,
) {
    static mut forprep_0: [OpCode; 2] = [OP_FORPREP, OP_TFORPREP];
    static mut forloop: [OpCode; 2] = [OP_FORLOOP, OP_TFORLOOP];
    let mut bl: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    let mut fs: *mut FuncState = (*ls).fs;
    let mut prep: i32 = 0;
    let mut endfor: i32 = 0;
    checknext(ls, TK_DO as i32);
    prep = luaK_codeABx(fs, forprep_0[isgen as usize], base, 0 as u32);
    enterblock(fs, &mut bl, 0 as lu_byte);
    adjustlocalvars(ls, nvars);
    luaK_reserveregs(fs, nvars);
    block(ls);
    leaveblock(fs);
    fixforjump(fs, prep, luaK_getlabel(fs), 0);
    if isgen != 0 {
        luaK_codeABCk(fs, OP_TFORCALL, base, 0, nvars, 0);
        luaK_fixline(fs, line);
    }
    endfor = luaK_codeABx(fs, forloop[isgen as usize], base, 0 as u32);
    fixforjump(fs, endfor, prep + 1 as i32, 1 as i32);
    luaK_fixline(fs, line);
}
unsafe extern "C-unwind" fn fornum(
    mut ls: *mut LexState,
    mut varname: *mut TString,
    mut line: i32,
) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut base: i32 = (*fs).freereg as i32;
    new_localvar(
        ls,
        luaX_newstring(
            ls,
            c"(for state)".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 12]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
    );
    new_localvar(
        ls,
        luaX_newstring(
            ls,
            c"(for state)".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 12]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
    );
    new_localvar(
        ls,
        luaX_newstring(
            ls,
            c"(for state)".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 12]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
    );
    new_localvar(ls, varname);
    checknext(ls, '=' as i32);
    exp1(ls);
    checknext(ls, ',' as i32);
    exp1(ls);
    if testnext(ls, ',' as i32) != 0 {
        exp1(ls);
    } else {
        luaK_int(fs, (*fs).freereg as i32, 1 as i32 as lua_Integer);
        luaK_reserveregs(fs, 1 as i32);
    }
    adjustlocalvars(ls, 3 as i32);
    forbody(ls, base, line, 1 as i32, 0);
}
unsafe extern "C-unwind" fn forlist(mut ls: *mut LexState, mut indexname: *mut TString) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut e: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut nvars: i32 = 5 as i32;
    let mut line: i32 = 0;
    let mut base: i32 = (*fs).freereg as i32;
    new_localvar(
        ls,
        luaX_newstring(
            ls,
            c"(for state)".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 12]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
    );
    new_localvar(
        ls,
        luaX_newstring(
            ls,
            c"(for state)".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 12]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
    );
    new_localvar(
        ls,
        luaX_newstring(
            ls,
            c"(for state)".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 12]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
    );
    new_localvar(
        ls,
        luaX_newstring(
            ls,
            c"(for state)".as_ptr(),
            (::core::mem::size_of::<[std::ffi::c_char; 12]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1),
        ),
    );
    new_localvar(ls, indexname);
    while testnext(ls, ',' as i32) != 0 {
        new_localvar(ls, str_checkname(ls));
        nvars += 1;
        nvars;
    }
    checknext(ls, TK_IN as i32);
    line = (*ls).linenumber;
    adjust_assign(ls, 4 as i32, explist(ls, &mut e), &mut e);
    adjustlocalvars(ls, 4 as i32);
    marktobeclosed(fs);
    luaK_checkstack(fs, 3 as i32);
    forbody(ls, base, line, nvars - 4 as i32, 1 as i32);
}
unsafe extern "C-unwind" fn forstat(mut ls: *mut LexState, mut line: i32) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut varname: *mut TString = 0 as *mut TString;
    let mut bl: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    enterblock(fs, &mut bl, 1 as i32 as lu_byte);
    luaX_next(ls);
    varname = str_checkname(ls);
    match (*ls).t.token {
        61 => {
            fornum(ls, varname, line);
        }
        44 | 267 => {
            forlist(ls, varname);
        }
        _ => {
            luaX_syntaxerror(ls, c"'=' or 'in' expected".as_ptr());
        }
    }
    check_match(ls, TK_END as i32, TK_FOR as i32, line);
    leaveblock(fs);
}
unsafe extern "C-unwind" fn test_then_block(mut ls: *mut LexState, mut escapelist: *mut i32) {
    let mut bl: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    let mut fs: *mut FuncState = (*ls).fs;
    let mut v: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut jf: i32 = 0;
    luaX_next(ls);
    expr(ls, &mut v);
    checknext(ls, TK_THEN as i32);
    if (*ls).t.token == TK_BREAK as i32 {
        let mut line: i32 = (*ls).linenumber;
        luaK_goiffalse((*ls).fs, &mut v);
        luaX_next(ls);
        enterblock(fs, &mut bl, 0 as lu_byte);
        newgotoentry(
            ls,
            luaS_newlstr(
                (*ls).L,
                c"break".as_ptr(),
                (::core::mem::size_of::<[std::ffi::c_char; 6]>() as usize)
                    .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                    .wrapping_sub(1),
            ),
            line,
            v.t,
        );
        while testnext(ls, ';' as i32) != 0 {}
        if block_follow(ls, 0) != 0 {
            leaveblock(fs);
            return;
        } else {
            jf = luaK_jump(fs);
        }
    } else {
        luaK_goiftrue((*ls).fs, &mut v);
        enterblock(fs, &mut bl, 0 as lu_byte);
        jf = v.f;
    }
    statlist(ls);
    leaveblock(fs);
    if (*ls).t.token == TK_ELSE as i32 || (*ls).t.token == TK_ELSEIF as i32 {
        luaK_concat(fs, escapelist, luaK_jump(fs));
    }
    luaK_patchtohere(fs, jf);
}
unsafe extern "C-unwind" fn ifstat(mut ls: *mut LexState, mut line: i32) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut escapelist: i32 = -(1 as i32);
    test_then_block(ls, &mut escapelist);
    while (*ls).t.token == TK_ELSEIF as i32 {
        test_then_block(ls, &mut escapelist);
    }
    if testnext(ls, TK_ELSE as i32) != 0 {
        block(ls);
    }
    check_match(ls, TK_END as i32, TK_IF as i32, line);
    luaK_patchtohere(fs, escapelist);
}
unsafe extern "C-unwind" fn localfunc(mut ls: *mut LexState) {
    let mut b: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut fs: *mut FuncState = (*ls).fs;
    let mut fvar: i32 = (*fs).nactvar as i32;
    new_localvar(ls, str_checkname(ls));
    adjustlocalvars(ls, 1 as i32);
    body(ls, &mut b, 0, (*ls).linenumber);
    (*localdebuginfo(fs, fvar)).startpc = (*fs).pc;
}
unsafe extern "C-unwind" fn getlocalattribute(mut ls: *mut LexState) -> i32 {
    if testnext(ls, '<' as i32) != 0 {
        let mut attr: *const std::ffi::c_char = ((*str_checkname(ls)).contents).as_mut_ptr();
        checknext(ls, '>' as i32);
        if strcmp(attr, c"const".as_ptr()) == 0 {
            return 1 as i32;
        } else if strcmp(attr, c"close".as_ptr()) == 0 {
            return 2 as i32;
        } else {
            luaK_semerror(
                ls,
                luaO_pushfstring((*ls).L, c"unknown attribute '%s'".as_ptr(), attr),
            );
        }
    }
    return 0;
}
unsafe extern "C-unwind" fn checktoclose(mut fs: *mut FuncState, mut level: i32) {
    if level != -(1 as i32) {
        marktobeclosed(fs);
        luaK_codeABCk(fs, OP_TBC, reglevel(fs, level), 0, 0, 0);
    }
}
unsafe extern "C-unwind" fn localstat(mut ls: *mut LexState) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut toclose: i32 = -(1 as i32);
    let mut var: *mut Vardesc = 0 as *mut Vardesc;
    let mut vidx: i32 = 0;
    let mut kind: i32 = 0;
    let mut nvars: i32 = 0;
    let mut nexps: i32 = 0;
    let mut e: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    loop {
        vidx = new_localvar(ls, str_checkname(ls));
        kind = getlocalattribute(ls);
        (*getlocalvardesc(fs, vidx)).vd.kind = kind as lu_byte;
        if kind == 2 as i32 {
            if toclose != -(1 as i32) {
                luaK_semerror(
                    ls,
                    c"multiple to-be-closed variables in local list".as_ptr(),
                );
            }
            toclose = (*fs).nactvar as i32 + nvars;
        }
        nvars += 1;
        nvars;
        if !(testnext(ls, ',' as i32) != 0) {
            break;
        }
    }
    if testnext(ls, '=' as i32) != 0 {
        nexps = explist(ls, &mut e);
    } else {
        e.k = VVOID;
        nexps = 0;
    }
    var = getlocalvardesc(fs, vidx);
    if nvars == nexps
        && (*var).vd.kind as i32 == 1 as i32
        && luaK_exp2const(fs, &mut e, &mut (*var).k) != 0
    {
        (*var).vd.kind = 3 as i32 as lu_byte;
        adjustlocalvars(ls, nvars - 1 as i32);
        (*fs).nactvar = ((*fs).nactvar).wrapping_add(1);
        (*fs).nactvar;
    } else {
        adjust_assign(ls, nvars, nexps, &mut e);
        adjustlocalvars(ls, nvars);
    }
    checktoclose(fs, toclose);
}
unsafe extern "C-unwind" fn funcname(mut ls: *mut LexState, mut v: *mut expdesc) -> i32 {
    let mut ismethod: i32 = 0;
    singlevar(ls, v);
    while (*ls).t.token == '.' as i32 {
        fieldsel(ls, v);
    }
    if (*ls).t.token == ':' as i32 {
        ismethod = 1 as i32;
        fieldsel(ls, v);
    }
    return ismethod;
}
unsafe extern "C-unwind" fn funcstat(mut ls: *mut LexState, mut line: i32) {
    let mut ismethod: i32 = 0;
    let mut v: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut b: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    luaX_next(ls);
    ismethod = funcname(ls, &mut v);
    body(ls, &mut b, ismethod, line);
    check_readonly(ls, &mut v);
    luaK_storevar((*ls).fs, &mut v, &mut b);
    luaK_fixline((*ls).fs, line);
}
unsafe extern "C-unwind" fn exprstat(mut ls: *mut LexState) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut v: LHS_assign = LHS_assign {
        prev: 0 as *mut LHS_assign,
        v: expdesc {
            k: VVOID,
            u: C2RustUnnamed_11 { ival: 0 },
            t: 0,
            f: 0,
        },
    };
    suffixedexp(ls, &mut v.v);
    if (*ls).t.token == '=' as i32 || (*ls).t.token == ',' as i32 {
        v.prev = 0 as *mut LHS_assign;
        restassign(ls, &mut v, 1 as i32);
    } else {
        let mut inst: *mut Instruction = 0 as *mut Instruction;
        if !(v.v.k as u32 == VCALL as i32 as u32) {
            luaX_syntaxerror(ls, c"syntax error".as_ptr());
        }
        inst = &mut *((*(*fs).f).code).offset(v.v.u.info as isize) as *mut Instruction;
        *inst = *inst
            & !(!(!(0 as Instruction) << 8 as i32)
                << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
            | (1 as i32 as Instruction) << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                & !(!(0 as Instruction) << 8 as i32)
                    << 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32;
    };
}
unsafe extern "C-unwind" fn retstat(mut ls: *mut LexState) {
    let mut fs: *mut FuncState = (*ls).fs;
    let mut e: expdesc = expdesc {
        k: VVOID,
        u: C2RustUnnamed_11 { ival: 0 },
        t: 0,
        f: 0,
    };
    let mut nret: i32 = 0;
    let mut first: i32 = luaY_nvarstack(fs);
    if block_follow(ls, 1 as i32) != 0 || (*ls).t.token == ';' as i32 {
        nret = 0;
    } else {
        nret = explist(ls, &mut e);
        if e.k as u32 == VCALL as i32 as u32 || e.k as u32 == VVARARG as i32 as u32 {
            luaK_setreturns(fs, &mut e, -(1 as i32));
            if e.k as u32 == VCALL as i32 as u32 && nret == 1 as i32 && (*(*fs).bl).insidetbc == 0 {
                *((*(*fs).f).code).offset(e.u.info as isize) = *((*(*fs).f).code)
                    .offset(e.u.info as isize)
                    & !(!(!(0 as Instruction) << 7 as i32) << 0)
                    | (OP_TAILCALL as i32 as Instruction) << 0
                        & !(!(0 as Instruction) << 7 as i32) << 0;
            }
            nret = -(1 as i32);
        } else if nret == 1 as i32 {
            first = luaK_exp2anyreg(fs, &mut e);
        } else {
            luaK_exp2nextreg(fs, &mut e);
        }
    }
    luaK_ret(fs, first, nret);
    testnext(ls, ';' as i32);
}
unsafe extern "C-unwind" fn statement(mut ls: *mut LexState) {
    let mut line: i32 = (*ls).linenumber;
    luaE_incCstack((*ls).L);
    match (*ls).t.token {
        59 => {
            luaX_next(ls);
        }
        266 => {
            ifstat(ls, line);
        }
        277 => {
            whilestat(ls, line);
        }
        258 => {
            luaX_next(ls);
            block(ls);
            check_match(ls, TK_END as i32, TK_DO as i32, line);
        }
        263 => {
            forstat(ls, line);
        }
        272 => {
            repeatstat(ls, line);
        }
        264 => {
            funcstat(ls, line);
        }
        268 => {
            luaX_next(ls);
            if testnext(ls, TK_FUNCTION as i32) != 0 {
                localfunc(ls);
            } else {
                localstat(ls);
            }
        }
        287 => {
            luaX_next(ls);
            labelstat(ls, str_checkname(ls), line);
        }
        273 => {
            luaX_next(ls);
            retstat(ls);
        }
        257 => {
            breakstat(ls);
        }
        265 => {
            luaX_next(ls);
            gotostat(ls);
        }
        _ => {
            exprstat(ls);
        }
    }
    (*(*ls).fs).freereg = luaY_nvarstack((*ls).fs) as lu_byte;
    (*(*ls).L).nCcalls = ((*(*ls).L).nCcalls).wrapping_sub(1);
    (*(*ls).L).nCcalls;
}
unsafe extern "C-unwind" fn mainfunc(mut ls: *mut LexState, mut fs: *mut FuncState) {
    let mut bl: BlockCnt = BlockCnt {
        previous: 0 as *mut BlockCnt,
        firstlabel: 0,
        firstgoto: 0,
        nactvar: 0,
        upval: 0,
        isloop: 0,
        insidetbc: 0,
    };
    let mut env: *mut Upvaldesc = 0 as *mut Upvaldesc;
    open_func(ls, fs, &mut bl);
    setvararg(fs, 0);
    env = allocupvalue(fs);
    (*env).instack = 1 as i32 as lu_byte;
    (*env).idx = 0 as lu_byte;
    (*env).kind = 0 as lu_byte;
    (*env).name = (*ls).envn;
    if (*(*fs).f).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*(*env).name).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            (*ls).L,
            &mut (*((*fs).f as *mut GCUnion)).gc,
            &mut (*((*env).name as *mut GCUnion)).gc,
        );
    } else {
    };
    luaX_next(ls);
    statlist(ls);
    check(ls, TK_EOS as i32);
    close_func(ls);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaY_parser(
    mut L: *mut lua_State,
    mut z: *mut ZIO,
    mut buff: *mut Mbuffer,
    mut dyd: *mut Dyndata,
    mut name: *const std::ffi::c_char,
    mut firstchar: i32,
) -> *mut LClosure {
    let mut lexstate: LexState = LexState {
        current: 0,
        linenumber: 0,
        lastline: 0,
        t: Token {
            token: 0,
            seminfo: SemInfo { r: 0. },
        },
        lookahead: Token {
            token: 0,
            seminfo: SemInfo { r: 0. },
        },
        fs: 0 as *mut FuncState,
        L: 0 as *mut lua_State,
        z: 0 as *mut ZIO,
        buff: 0 as *mut Mbuffer,
        h: 0 as *mut Table,
        dyd: 0 as *mut Dyndata,
        source: 0 as *mut TString,
        envn: 0 as *mut TString,
    };
    let mut funcstate: FuncState = FuncState {
        f: 0 as *mut Proto,
        prev: 0 as *mut FuncState,
        ls: 0 as *mut LexState,
        bl: 0 as *mut BlockCnt,
        pc: 0,
        lasttarget: 0,
        previousline: 0,
        nk: 0,
        np: 0,
        nabslineinfo: 0,
        firstlocal: 0,
        firstlabel: 0,
        ndebugvars: 0,
        nactvar: 0,
        nups: 0,
        freereg: 0,
        iwthabs: 0,
        needclose: 0,
    };
    let mut cl: *mut LClosure = luaF_newLclosure(L, 1 as i32);
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    let mut x_: *mut LClosure = cl;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (6 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    luaD_inctop(L);
    lexstate.h = luaH_new(L);
    let mut io_0: *mut TValue = &mut (*(*L).top.p).val;
    let mut x__0: *mut Table = lexstate.h;
    (*io_0).value_.gc = &mut (*(x__0 as *mut GCUnion)).gc;
    (*io_0).tt_ = (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io_0).tt_ as i32 & 0x3f as i32 == (*(*io_0).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io_0).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    luaD_inctop(L);
    (*cl).p = luaF_newproto(L);
    funcstate.f = (*cl).p;
    if (*cl).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*(*cl).p).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            L,
            &mut (*(cl as *mut GCUnion)).gc,
            &mut (*((*cl).p as *mut GCUnion)).gc,
        );
    } else {
    };
    (*funcstate.f).source = luaS_new(L, name);
    if (*funcstate.f).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (*(*funcstate.f).source).marked as i32
            & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
            != 0
    {
        luaC_barrier_(
            L,
            &mut (*(funcstate.f as *mut GCUnion)).gc,
            &mut (*((*funcstate.f).source as *mut GCUnion)).gc,
        );
    } else {
    };
    lexstate.buff = buff;
    lexstate.dyd = dyd;
    (*dyd).label.n = 0;
    (*dyd).gt.n = (*dyd).label.n;
    (*dyd).actvar.n = (*dyd).gt.n;
    luaX_setinput(L, &mut lexstate, z, (*funcstate.f).source, firstchar);
    mainfunc(&mut lexstate, &mut funcstate);
    (*L).top.p = ((*L).top.p).offset(-1);
    (*L).top.p;
    return cl;
}
unsafe extern "C-unwind" fn currentpc(mut ci: *mut CallInfo) -> i32 {
    return ((*ci).u.l.savedpc)
        .offset_from((*(*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p).code)
        as std::ffi::c_long as i32
        - 1 as i32;
}
unsafe extern "C-unwind" fn getbaseline(
    mut f: *const Proto,
    mut pc: i32,
    mut basepc: *mut i32,
) -> i32 {
    if (*f).sizeabslineinfo == 0 || pc < (*((*f).abslineinfo).offset(0 as isize)).pc {
        *basepc = -(1 as i32);
        return (*f).linedefined;
    } else {
        let mut i: i32 = (pc as u32).wrapping_div(128).wrapping_sub(1) as i32;
        while (i + 1 as i32) < (*f).sizeabslineinfo
            && pc >= (*((*f).abslineinfo).offset((i + 1 as i32) as isize)).pc
        {
            i += 1;
            i;
        }
        *basepc = (*((*f).abslineinfo).offset(i as isize)).pc;
        return (*((*f).abslineinfo).offset(i as isize)).line;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_getfuncline(mut f: *const Proto, mut pc: i32) -> i32 {
    if ((*f).lineinfo).is_null() {
        return -(1 as i32);
    } else {
        let mut basepc: i32 = 0;
        let mut baseline: i32 = getbaseline(f, pc, &mut basepc);
        loop {
            let fresh111 = basepc;
            basepc = basepc + 1;
            if !(fresh111 < pc) {
                break;
            }
            baseline += *((*f).lineinfo).offset(basepc as isize) as i32;
        }
        return baseline;
    };
}
unsafe extern "C-unwind" fn getcurrentline(mut ci: *mut CallInfo) -> i32 {
    return luaG_getfuncline(
        (*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p,
        currentpc(ci),
    );
}
unsafe extern "C-unwind" fn settraps(mut ci: *mut CallInfo) {
    while !ci.is_null() {
        if (*ci).callstatus as i32 & (1 as i32) << 1 as i32 == 0 {
            ::core::ptr::write_volatile(&mut (*ci).u.l.trap as *mut sig_atomic_t, 1 as i32);
        }
        ci = (*ci).previous;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_sethook(
    mut L: *mut lua_State,
    mut func: lua_Hook,
    mut mask: i32,
    mut count: i32,
) {
    if func.is_none() || mask == 0 {
        mask = 0;
        func = None;
    }
    ::core::ptr::write_volatile(&mut (*L).hook as *mut lua_Hook, func);
    (*L).basehookcount = count;
    (*L).hookcount = (*L).basehookcount;
    ::core::ptr::write_volatile(
        &mut (*L).hookmask as *mut sig_atomic_t,
        mask as lu_byte as sig_atomic_t,
    );
    if mask != 0 {
        settraps((*L).ci);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_gethook(mut L: *mut lua_State) -> lua_Hook {
    return (*L).hook;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_gethookmask(mut L: *mut lua_State) -> i32 {
    return (*L).hookmask;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_gethookcount(mut L: *mut lua_State) -> i32 {
    return (*L).basehookcount;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getstack(
    mut L: *mut lua_State,
    mut level: i32,
    mut ar: *mut lua_Debug,
) -> i32 {
    let mut status: i32 = 0;
    let mut ci: *mut CallInfo = 0 as *mut CallInfo;
    if level < 0 {
        return 0;
    }
    ci = (*L).ci;
    while level > 0 && ci != &mut (*L).base_ci as *mut CallInfo {
        level -= 1;
        level;
        ci = (*ci).previous;
    }
    if level == 0 && ci != &mut (*L).base_ci as *mut CallInfo {
        status = 1 as i32;
        (*ar).i_ci = ci;
    } else {
        status = 0;
    }
    return status;
}
unsafe extern "C-unwind" fn upvalname(mut p: *const Proto, mut uv: i32) -> *const std::ffi::c_char {
    let mut s: *mut TString = (*((*p).upvalues).offset(uv as isize)).name;
    if s.is_null() {
        return c"?".as_ptr();
    } else {
        return ((*s).contents).as_mut_ptr();
    };
}
unsafe extern "C-unwind" fn findvararg(
    mut ci: *mut CallInfo,
    mut n: i32,
    mut pos: *mut StkId,
) -> *const std::ffi::c_char {
    if (*(*(&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l as *mut LClosure)).p)
        .is_vararg
        != 0
    {
        let mut nextra: i32 = (*ci).u.l.nextraargs;
        if n >= -nextra {
            *pos = ((*ci).func.p)
                .offset(-(nextra as isize))
                .offset(-((n + 1 as i32) as isize));
            return c"(vararg)".as_ptr();
        }
    }
    return 0 as *const std::ffi::c_char;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_findlocal(
    mut L: *mut lua_State,
    mut ci: *mut CallInfo,
    mut n: i32,
    mut pos: *mut StkId,
) -> *const std::ffi::c_char {
    let mut base: StkId = ((*ci).func.p).offset(1);
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if (*ci).callstatus as i32 & (1 as i32) << 1 as i32 == 0 {
        if n < 0 {
            return findvararg(ci, n, pos);
        } else {
            name = luaF_getlocalname(
                (*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p,
                n,
                currentpc(ci),
            );
        }
    }
    if name.is_null() {
        let mut limit: StkId = if ci == (*L).ci {
            (*L).top.p
        } else {
            (*(*ci).next).func.p
        };
        if limit.offset_from(base) as std::ffi::c_long >= n as std::ffi::c_long && n > 0 {
            name = if (*ci).callstatus as i32 & (1 as i32) << 1 as i32 == 0 {
                c"(temporary)".as_ptr()
            } else {
                c"(C temporary)".as_ptr()
            };
        } else {
            return 0 as *const std::ffi::c_char;
        }
    }
    if !pos.is_null() {
        *pos = base.offset((n - 1 as i32) as isize);
    }
    return name;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getlocal(
    mut L: *mut lua_State,
    mut ar: *const lua_Debug,
    mut n: i32,
) -> *const std::ffi::c_char {
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if ar.is_null() {
        if !((*((*L).top.p).offset(-(1))).val.tt_ as i32
            == 6 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
        {
            name = 0 as *const std::ffi::c_char;
        } else {
            name = luaF_getlocalname(
                (*&mut (*((*((*L).top.p).offset(-(1))).val.value_.gc as *mut GCUnion))
                    .cl
                    .l)
                    .p,
                n,
                0,
            );
        }
    } else {
        let mut pos: StkId = 0 as StkId;
        name = luaG_findlocal(L, (*ar).i_ci, n, &mut pos);
        if !name.is_null() {
            let mut io1: *mut TValue = &mut (*(*L).top.p).val;
            let mut io2: *const TValue = &mut (*pos).val;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            (*L).top.p = ((*L).top.p).offset(1);
            (*L).top.p;
        }
    }
    return name;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setlocal(
    mut L: *mut lua_State,
    mut ar: *const lua_Debug,
    mut n: i32,
) -> *const std::ffi::c_char {
    let mut pos: StkId = 0 as StkId;
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    name = luaG_findlocal(L, (*ar).i_ci, n, &mut pos);
    if !name.is_null() {
        let mut io1: *mut TValue = &mut (*pos).val;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(-1);
        (*L).top.p;
    }
    return name;
}
unsafe extern "C-unwind" fn funcinfo(mut ar: *mut lua_Debug, mut cl: *mut Closure) {
    if !(!cl.is_null() && (*cl).c.tt as i32 == 6 as i32 | (0) << 4 as i32) {
        (*ar).source = c"=[C]".as_ptr();
        (*ar).srclen = (::core::mem::size_of::<[std::ffi::c_char; 5]>() as usize)
            .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
            .wrapping_sub(1);
        (*ar).linedefined = -(1 as i32);
        (*ar).lastlinedefined = -(1 as i32);
        (*ar).what = c"C".as_ptr();
    } else {
        let mut p: *const Proto = (*cl).l.p;
        if !((*p).source).is_null() {
            (*ar).source = ((*(*p).source).contents).as_mut_ptr();
            (*ar).srclen = if (*(*p).source).shrlen as i32 != 0xff as i32 {
                (*(*p).source).shrlen as size_t
            } else {
                (*(*p).source).u.lnglen
            };
        } else {
            (*ar).source = c"=?".as_ptr();
            (*ar).srclen = (::core::mem::size_of::<[std::ffi::c_char; 3]>() as usize)
                .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                .wrapping_sub(1);
        }
        (*ar).linedefined = (*p).linedefined;
        (*ar).lastlinedefined = (*p).lastlinedefined;
        (*ar).what = if (*ar).linedefined == 0 {
            c"main".as_ptr()
        } else {
            c"Lua".as_ptr()
        };
    }
    luaO_chunkid(((*ar).short_src).as_mut_ptr(), (*ar).source, (*ar).srclen);
}
unsafe extern "C-unwind" fn nextline(
    mut p: *const Proto,
    mut currentline: i32,
    mut pc: i32,
) -> i32 {
    if *((*p).lineinfo).offset(pc as isize) as i32 != -(0x80) {
        return currentline + *((*p).lineinfo).offset(pc as isize) as i32;
    } else {
        return luaG_getfuncline(p, pc);
    };
}
unsafe extern "C-unwind" fn collectvalidlines(mut L: *mut lua_State, mut f: *mut Closure) {
    if !(!f.is_null() && (*f).c.tt as i32 == 6 as i32 | (0) << 4 as i32) {
        (*(*L).top.p).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    } else {
        let mut p: *const Proto = (*f).l.p;
        let mut currentline: i32 = (*p).linedefined;
        let mut t: *mut Table = luaH_new(L);
        let mut io: *mut TValue = &mut (*(*L).top.p).val;
        let mut x_: *mut Table = t;
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
        if !((*p).lineinfo).is_null() {
            let mut i: i32 = 0;
            let mut v: TValue = TValue {
                value_: Value {
                    gc: 0 as *mut GCObject,
                },
                tt_: 0,
            };
            v.tt_ = (1 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            if (*p).is_vararg == 0 {
                i = 0;
            } else {
                currentline = nextline(p, currentline, 0);
                i = 1 as i32;
            }
            while i < (*p).sizelineinfo {
                currentline = nextline(p, currentline, i);
                luaH_setint(L, t, currentline as lua_Integer, &mut v);
                i += 1;
                i;
            }
        }
    };
}
unsafe extern "C-unwind" fn getfuncname(
    mut L: *mut lua_State,
    mut ci: *mut CallInfo,
    mut name: *mut *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    if !ci.is_null() && (*ci).callstatus as i32 & (1 as i32) << 5 as i32 == 0 {
        return funcnamefromcall(L, (*ci).previous, name);
    } else {
        return 0 as *const std::ffi::c_char;
    };
}
unsafe extern "C-unwind" fn auxgetinfo(
    mut L: *mut lua_State,
    mut what: *const std::ffi::c_char,
    mut ar: *mut lua_Debug,
    mut f: *mut Closure,
    mut ci: *mut CallInfo,
) -> i32 {
    let mut status: i32 = 1 as i32;
    while *what != 0 {
        match *what as i32 {
            83 => {
                funcinfo(ar, f);
            }
            108 => {
                (*ar).currentline =
                    if !ci.is_null() && (*ci).callstatus as i32 & (1 as i32) << 1 as i32 == 0 {
                        getcurrentline(ci)
                    } else {
                        -(1 as i32)
                    };
            }
            117 => {
                (*ar).nups = (if f.is_null() {
                    0
                } else {
                    (*f).c.nupvalues as i32
                }) as u8;
                if !(!f.is_null() && (*f).c.tt as i32 == 6 as i32 | (0) << 4 as i32) {
                    (*ar).isvararg = 1 as i32 as std::ffi::c_char;
                    (*ar).nparams = 0 as u8;
                } else {
                    (*ar).isvararg = (*(*f).l.p).is_vararg as std::ffi::c_char;
                    (*ar).nparams = (*(*f).l.p).numparams;
                }
            }
            116 => {
                (*ar).istailcall = (if !ci.is_null() {
                    (*ci).callstatus as i32 & (1 as i32) << 5 as i32
                } else {
                    0
                }) as std::ffi::c_char;
            }
            110 => {
                (*ar).namewhat = getfuncname(L, ci, &mut (*ar).name);
                if ((*ar).namewhat).is_null() {
                    (*ar).namewhat = c"".as_ptr();
                    (*ar).name = 0 as *const std::ffi::c_char;
                }
            }
            114 => {
                if ci.is_null() || (*ci).callstatus as i32 & (1 as i32) << 8 as i32 == 0 {
                    (*ar).ntransfer = 0 as u16;
                    (*ar).ftransfer = (*ar).ntransfer;
                } else {
                    (*ar).ftransfer = (*ci).u2.transferinfo.ftransfer;
                    (*ar).ntransfer = (*ci).u2.transferinfo.ntransfer;
                }
            }
            76 | 102 => {}
            _ => {
                status = 0;
            }
        }
        what = what.offset(1);
        what;
    }
    return status;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getinfo(
    mut L: *mut lua_State,
    mut what: *const std::ffi::c_char,
    mut ar: *mut lua_Debug,
) -> i32 {
    let mut status: i32 = 0;
    let mut cl: *mut Closure = 0 as *mut Closure;
    let mut ci: *mut CallInfo = 0 as *mut CallInfo;
    let mut func: *mut TValue = 0 as *mut TValue;
    if *what as i32 == '>' as i32 {
        ci = 0 as *mut CallInfo;
        func = &mut (*((*L).top.p).offset(-(1))).val;
        what = what.offset(1);
        what;
        (*L).top.p = ((*L).top.p).offset(-1);
        (*L).top.p;
    } else {
        ci = (*ar).i_ci;
        func = &mut (*(*ci).func.p).val;
    }
    cl = if (*func).tt_ as i32 == 6 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32
        || (*func).tt_ as i32 == 6 as i32 | (2 as i32) << 4 as i32 | (1 as i32) << 6 as i32
    {
        &mut (*((*func).value_.gc as *mut GCUnion)).cl
    } else {
        0 as *mut Closure
    };
    status = auxgetinfo(L, what, ar, cl, ci);
    if !(strchr(what, 'f' as i32)).is_null() {
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue = func;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    }
    if !(strchr(what, 'L' as i32)).is_null() {
        collectvalidlines(L, cl);
    }
    return status;
}
unsafe extern "C-unwind" fn filterpc(mut pc: i32, mut jmptarget: i32) -> i32 {
    if pc < jmptarget {
        return -(1 as i32);
    } else {
        return pc;
    };
}
unsafe extern "C-unwind" fn findsetreg(mut p: *const Proto, mut lastpc: i32, mut reg: i32) -> i32 {
    let mut pc: i32 = 0;
    let mut setreg: i32 = -(1 as i32);
    let mut jmptarget: i32 = 0;
    if luaP_opmodes[(*((*p).code).offset(lastpc as isize) >> 0
        & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as usize] as i32
        & (1 as i32) << 7 as i32
        != 0
    {
        lastpc -= 1;
        lastpc;
    }
    pc = 0;
    while pc < lastpc {
        let mut i: Instruction = *((*p).code).offset(pc as isize);
        let mut op: OpCode = (i >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode;
        let mut a: i32 = (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
        let mut change: i32 = 0;
        match op as u32 {
            8 => {
                let mut b: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0)
                    as i32;
                change = (a <= reg && reg <= a + b) as i32;
            }
            76 => {
                change = (reg >= a + 2 as i32) as i32;
            }
            68 | 69 => {
                change = (reg >= a) as i32;
            }
            56 => {
                let mut b_0: i32 = (i >> 0 + 7 as i32
                    & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) << 0)
                    as i32
                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) - 1 as i32
                        >> 1 as i32);
                let mut dest: i32 = pc + 1 as i32 + b_0;
                if dest <= lastpc && dest > jmptarget {
                    jmptarget = dest;
                }
                change = 0;
            }
            _ => {
                change = (luaP_opmodes[op as usize] as i32 & (1 as i32) << 3 as i32 != 0
                    && reg == a) as i32;
            }
        }
        if change != 0 {
            setreg = filterpc(pc, jmptarget);
        }
        pc += 1;
        pc;
    }
    return setreg;
}
unsafe extern "C-unwind" fn kname(
    mut p: *const Proto,
    mut index: i32,
    mut name: *mut *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut kvalue: *mut TValue = &mut *((*p).k).offset(index as isize) as *mut TValue;
    if (*kvalue).tt_ as i32 & 0xf as i32 == 4 as i32 {
        *name = ((*&mut (*((*kvalue).value_.gc as *mut GCUnion)).ts).contents).as_mut_ptr();
        return c"constant".as_ptr();
    } else {
        *name = c"?".as_ptr();
        return 0 as *const std::ffi::c_char;
    };
}
unsafe extern "C-unwind" fn basicgetobjname(
    mut p: *const Proto,
    mut ppc: *mut i32,
    mut reg: i32,
    mut name: *mut *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut pc: i32 = *ppc;
    *name = luaF_getlocalname(p, reg + 1 as i32, pc);
    if !(*name).is_null() {
        return c"local".as_ptr();
    }
    pc = findsetreg(p, pc, reg);
    *ppc = pc;
    if pc != -(1 as i32) {
        let mut i: Instruction = *((*p).code).offset(pc as isize);
        let mut op: OpCode = (i >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode;
        match op as u32 {
            0 => {
                let mut b: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0)
                    as i32;
                if b < (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32 {
                    return basicgetobjname(p, ppc, b, name);
                }
            }
            9 => {
                *name = upvalname(
                    p,
                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                        & !(!(0 as Instruction) << 8 as i32) << 0) as i32,
                );
                return c"upvalue".as_ptr();
            }
            3 => {
                return kname(
                    p,
                    (i >> 0 + 7 as i32 + 8 as i32
                        & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                        as i32,
                    name,
                );
            }
            4 => {
                return kname(
                    p,
                    (*((*p).code).offset((pc + 1 as i32) as isize) >> 0 + 7 as i32
                        & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32) << 0)
                        as i32,
                    name,
                );
            }
            _ => {}
        }
    }
    return 0 as *const std::ffi::c_char;
}
unsafe extern "C-unwind" fn rname(
    mut p: *const Proto,
    mut pc: i32,
    mut c: i32,
    mut name: *mut *const std::ffi::c_char,
) {
    let mut what: *const std::ffi::c_char = basicgetobjname(p, &mut pc, c, name);
    if !(!what.is_null() && *what as i32 == 'c' as i32) {
        *name = c"?".as_ptr();
    }
}
unsafe extern "C-unwind" fn rkname(
    mut p: *const Proto,
    mut pc: i32,
    mut i: Instruction,
    mut name: *mut *const std::ffi::c_char,
) {
    let mut c: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
        & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
    if (i >> 0 + 7 as i32 + 8 as i32 & !(!(0 as Instruction) << 1 as i32) << 0) as i32 != 0 {
        kname(p, c, name);
    } else {
        rname(p, pc, c, name);
    };
}
unsafe extern "C-unwind" fn isEnv(
    mut p: *const Proto,
    mut pc: i32,
    mut i: Instruction,
    mut isup: i32,
) -> *const std::ffi::c_char {
    let mut t: i32 =
        (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if isup != 0 {
        name = upvalname(p, t);
    } else {
        basicgetobjname(p, &mut pc, t, &mut name);
    }
    return if !name.is_null() && strcmp(name, c"_ENV".as_ptr()) == 0 {
        c"global".as_ptr()
    } else {
        c"field".as_ptr()
    };
}
unsafe extern "C-unwind" fn getobjname(
    mut p: *const Proto,
    mut lastpc: i32,
    mut reg: i32,
    mut name: *mut *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut kind: *const std::ffi::c_char = basicgetobjname(p, &mut lastpc, reg, name);
    if !kind.is_null() {
        return kind;
    } else if lastpc != -(1 as i32) {
        let mut i: Instruction = *((*p).code).offset(lastpc as isize);
        let mut op: OpCode = (i >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode;
        match op as u32 {
            11 => {
                let mut k: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0)
                    as i32;
                kname(p, k, name);
                return isEnv(p, lastpc, i, 1 as i32);
            }
            12 => {
                let mut k_0: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0)
                    as i32;
                rname(p, lastpc, k_0, name);
                return isEnv(p, lastpc, i, 0);
            }
            13 => {
                *name = c"integer index".as_ptr();
                return c"field".as_ptr();
            }
            14 => {
                let mut k_1: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0)
                    as i32;
                kname(p, k_1, name);
                return isEnv(p, lastpc, i, 0);
            }
            20 => {
                rkname(p, lastpc, i, name);
                return c"method".as_ptr();
            }
            _ => {}
        }
    }
    return 0 as *const std::ffi::c_char;
}
unsafe extern "C-unwind" fn funcnamefromcode(
    mut L: *mut lua_State,
    mut p: *const Proto,
    mut pc: i32,
    mut name: *mut *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut tm: TMS = TM_INDEX;
    let mut i: Instruction = *((*p).code).offset(pc as isize);
    match (i >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32 {
        68 | 69 => {
            return getobjname(
                p,
                pc,
                (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32,
                name,
            );
        }
        76 => {
            *name = c"for iterator".as_ptr();
            return c"for iterator".as_ptr();
        }
        20 | 11 | 12 | 13 | 14 => {
            tm = TM_INDEX;
        }
        15 | 16 | 17 | 18 => {
            tm = TM_NEWINDEX;
        }
        46 | 47 | 48 => {
            tm = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                & !(!(0 as Instruction) << 8 as i32) << 0) as i32 as TMS;
        }
        49 => {
            tm = TM_UNM;
        }
        50 => {
            tm = TM_BNOT;
        }
        52 => {
            tm = TM_LEN;
        }
        53 => {
            tm = TM_CONCAT;
        }
        57 => {
            tm = TM_EQ;
        }
        58 | 62 | 64 => {
            tm = TM_LT;
        }
        59 | 63 | 65 => {
            tm = TM_LE;
        }
        54 | 70 => {
            tm = TM_CLOSE;
        }
        _ => return 0 as *const std::ffi::c_char,
    }
    *name = ((*(*(*L).l_G).tmname[tm as usize]).contents)
        .as_mut_ptr()
        .offset(2);
    return c"metamethod".as_ptr();
}
unsafe extern "C-unwind" fn funcnamefromcall(
    mut L: *mut lua_State,
    mut ci: *mut CallInfo,
    mut name: *mut *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    if (*ci).callstatus as i32 & (1 as i32) << 3 as i32 != 0 {
        *name = c"?".as_ptr();
        return c"hook".as_ptr();
    } else if (*ci).callstatus as i32 & (1 as i32) << 7 as i32 != 0 {
        *name = c"__gc".as_ptr();
        return c"metamethod".as_ptr();
    } else if (*ci).callstatus as i32 & (1 as i32) << 1 as i32 == 0 {
        return funcnamefromcode(
            L,
            (*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p,
            currentpc(ci),
            name,
        );
    } else {
        return 0 as *const std::ffi::c_char;
    };
}
unsafe extern "C-unwind" fn instack(mut ci: *mut CallInfo, mut o: *const TValue) -> i32 {
    let mut pos: i32 = 0;
    let mut base: StkId = ((*ci).func.p).offset(1);
    pos = 0;
    while base.offset(pos as isize) < (*ci).top.p {
        if o == &mut (*base.offset(pos as isize)).val as *mut TValue as *const TValue {
            return pos;
        }
        pos += 1;
        pos;
    }
    return -(1 as i32);
}
unsafe extern "C-unwind" fn getupvalname(
    mut ci: *mut CallInfo,
    mut o: *const TValue,
    mut name: *mut *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut c: *mut LClosure = &mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l;
    let mut i: i32 = 0;
    i = 0;
    while i < (*c).nupvalues as i32 {
        if (**((*c).upvals).as_mut_ptr().offset(i as isize)).v.p == o as *mut TValue {
            *name = upvalname((*c).p, i);
            return c"upvalue".as_ptr();
        }
        i += 1;
        i;
    }
    return 0 as *const std::ffi::c_char;
}
unsafe extern "C-unwind" fn formatvarinfo(
    mut L: *mut lua_State,
    mut kind: *const std::ffi::c_char,
    mut name: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    if kind.is_null() {
        return c"".as_ptr();
    } else {
        return luaO_pushfstring(L, c" (%s '%s')".as_ptr(), kind, name);
    };
}
unsafe extern "C-unwind" fn varinfo(
    mut L: *mut lua_State,
    mut o: *const TValue,
) -> *const std::ffi::c_char {
    let mut ci: *mut CallInfo = (*L).ci;
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut kind: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if (*ci).callstatus as i32 & (1 as i32) << 1 as i32 == 0 {
        kind = getupvalname(ci, o, &mut name);
        if kind.is_null() {
            let mut reg: i32 = instack(ci, o);
            if reg >= 0 {
                kind = getobjname(
                    (*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p,
                    currentpc(ci),
                    reg,
                    &mut name,
                );
            }
        }
    }
    return formatvarinfo(L, kind, name);
}
unsafe extern "C-unwind" fn typeerror(
    mut L: *mut lua_State,
    mut o: *const TValue,
    mut op: *const std::ffi::c_char,
    mut extra: *const std::ffi::c_char,
) -> ! {
    let mut t: *const std::ffi::c_char = luaT_objtypename(L, o);
    luaG_runerror(L, c"attempt to %s a %s value%s".as_ptr(), op, t, extra);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_typeerror(
    mut L: *mut lua_State,
    mut o: *const TValue,
    mut op: *const std::ffi::c_char,
) -> ! {
    typeerror(L, o, op, varinfo(L, o));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_callerror(mut L: *mut lua_State, mut o: *const TValue) -> ! {
    let mut ci: *mut CallInfo = (*L).ci;
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut kind: *const std::ffi::c_char = funcnamefromcall(L, ci, &mut name);
    let mut extra: *const std::ffi::c_char = if !kind.is_null() {
        formatvarinfo(L, kind, name)
    } else {
        varinfo(L, o)
    };
    typeerror(L, o, c"call".as_ptr(), extra);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_forerror(
    mut L: *mut lua_State,
    mut o: *const TValue,
    mut what: *const std::ffi::c_char,
) -> ! {
    luaG_runerror(
        L,
        c"bad 'for' %s (number expected, got %s)".as_ptr(),
        what,
        luaT_objtypename(L, o),
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_concaterror(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
) -> ! {
    if (*p1).tt_ as i32 & 0xf as i32 == 4 as i32 || (*p1).tt_ as i32 & 0xf as i32 == 3 as i32 {
        p1 = p2;
    }
    luaG_typeerror(L, p1, c"concatenate".as_ptr());
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_opinterror(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
    mut msg: *const std::ffi::c_char,
) -> ! {
    if !((*p1).tt_ as i32 & 0xf as i32 == 3 as i32) {
        p2 = p1;
    }
    luaG_typeerror(L, p2, msg);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_tointerror(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
) -> ! {
    let mut temp: lua_Integer = 0;
    if luaV_tointegerns(p1, &mut temp, F2Ieq) == 0 {
        p2 = p1;
    }
    luaG_runerror(
        L,
        c"number%s has no integer representation".as_ptr(),
        varinfo(L, p2),
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_ordererror(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
) -> ! {
    let mut t1: *const std::ffi::c_char = luaT_objtypename(L, p1);
    let mut t2: *const std::ffi::c_char = luaT_objtypename(L, p2);
    if strcmp(t1, t2) == 0 {
        luaG_runerror(L, c"attempt to compare two %s values".as_ptr(), t1);
    } else {
        luaG_runerror(L, c"attempt to compare %s with %s".as_ptr(), t1, t2);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_addinfo(
    mut L: *mut lua_State,
    mut msg: *const std::ffi::c_char,
    mut src: *mut TString,
    mut line: i32,
) -> *const std::ffi::c_char {
    let mut buff: [std::ffi::c_char; 60] = [0; 60];
    if !src.is_null() {
        luaO_chunkid(
            buff.as_mut_ptr(),
            ((*src).contents).as_mut_ptr(),
            if (*src).shrlen as i32 != 0xff as i32 {
                (*src).shrlen as size_t
            } else {
                (*src).u.lnglen
            },
        );
    } else {
        buff[0 as usize] = '?' as i32 as std::ffi::c_char;
        buff[1] = '\0' as i32 as std::ffi::c_char;
    }
    return luaO_pushfstring(L, c"%s:%d: %s".as_ptr(), buff.as_mut_ptr(), line, msg);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_errormsg(mut L: *mut lua_State) -> ! {
    if (*L).errfunc != 0 as ptrdiff_t {
        let mut errfunc: StkId =
            ((*L).stack.p as *mut std::ffi::c_char).offset((*L).errfunc as isize) as StkId;
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        let mut io1_0: *mut TValue = &mut (*((*L).top.p).offset(-(1))).val;
        let mut io2_0: *const TValue = &mut (*errfunc).val;
        (*io1_0).value_ = (*io2_0).value_;
        (*io1_0).tt_ = (*io2_0).tt_;
        if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1_0).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
        luaD_callnoyield(L, ((*L).top.p).offset(-(2)), 1 as i32);
    }
    luaD_throw(L, 2 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_runerror(
    mut L: *mut lua_State,
    mut fmt: *const std::ffi::c_char,
    mut args: ...
) -> ! {
    let mut ci: *mut CallInfo = (*L).ci;
    let mut msg: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut argp: ::core::ffi::VaListImpl;
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
    argp = args.clone();
    msg = luaO_pushvfstring(L, fmt, argp.as_va_list());
    if (*ci).callstatus as i32 & (1 as i32) << 1 as i32 == 0 {
        luaG_addinfo(
            L,
            msg,
            (*(*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p).source,
            getcurrentline(ci),
        );
        let mut io1: *mut TValue = &mut (*((*L).top.p).offset(-(2))).val;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(-1);
        (*L).top.p;
    }
    luaG_errormsg(L);
}
unsafe extern "C-unwind" fn changedline(
    mut p: *const Proto,
    mut oldpc: i32,
    mut newpc: i32,
) -> i32 {
    if ((*p).lineinfo).is_null() {
        return 0;
    }
    if newpc - oldpc < 128 as i32 / 2 as i32 {
        let mut delta: i32 = 0;
        let mut pc: i32 = oldpc;
        loop {
            pc += 1;
            let mut lineinfo: i32 = *((*p).lineinfo).offset(pc as isize) as i32;
            if lineinfo == -(0x80) {
                break;
            }
            delta += lineinfo;
            if pc == newpc {
                return (delta != 0) as i32;
            }
        }
    }
    return (luaG_getfuncline(p, oldpc) != luaG_getfuncline(p, newpc)) as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_tracecall(mut L: *mut lua_State) -> i32 {
    let mut ci: *mut CallInfo = (*L).ci;
    let mut p: *mut Proto = (*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p;
    ::core::ptr::write_volatile(&mut (*ci).u.l.trap as *mut sig_atomic_t, 1 as i32);
    if (*ci).u.l.savedpc == (*p).code as *const Instruction {
        if (*p).is_vararg != 0 {
            return 0;
        } else if (*ci).callstatus as i32 & (1 as i32) << 6 as i32 == 0 {
            luaD_hookcall(L, ci);
        }
    }
    return 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaG_traceexec(
    mut L: *mut lua_State,
    mut pc: *const Instruction,
) -> i32 {
    let mut ci: *mut CallInfo = (*L).ci;
    let mut mask: lu_byte = (*L).hookmask as lu_byte;
    let mut p: *const Proto = (*&mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l).p;
    let mut counthook: i32 = 0;
    if mask as i32 & ((1 as i32) << 2 as i32 | (1 as i32) << 3 as i32) == 0 {
        ::core::ptr::write_volatile(&mut (*ci).u.l.trap as *mut sig_atomic_t, 0);
        return 0;
    }
    pc = pc.offset(1);
    pc;
    (*ci).u.l.savedpc = pc;
    counthook = (mask as i32 & (1 as i32) << 3 as i32 != 0 && {
        (*L).hookcount -= 1;
        (*L).hookcount == 0
    }) as i32;
    if counthook != 0 {
        (*L).hookcount = (*L).basehookcount;
    } else if mask as i32 & (1 as i32) << 2 as i32 == 0 {
        return 1 as i32;
    }
    if (*ci).callstatus as i32 & (1 as i32) << 6 as i32 != 0 {
        (*ci).callstatus = ((*ci).callstatus as i32 & !((1 as i32) << 6 as i32)) as u16;
        return 1 as i32;
    }
    if !(luaP_opmodes[(*((*ci).u.l.savedpc).offset(-(1)) >> 0
        & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as usize] as i32
        & (1 as i32) << 5 as i32
        != 0
        && (*((*ci).u.l.savedpc).offset(-(1)) >> 0 + 7 as i32 + 8 as i32 + 1 as i32
            & !(!(0 as Instruction) << 8 as i32) << 0) as i32
            == 0)
    {
        (*L).top.p = (*ci).top.p;
    }
    if counthook != 0 {
        luaD_hook(L, 3 as i32, -(1 as i32), 0, 0);
    }
    if mask as i32 & (1 as i32) << 2 as i32 != 0 {
        let mut oldpc: i32 = if (*L).oldpc < (*p).sizecode {
            (*L).oldpc
        } else {
            0
        };
        let mut npci: i32 = pc.offset_from((*p).code) as std::ffi::c_long as i32 - 1 as i32;
        if npci <= oldpc || changedline(p, oldpc, npci) != 0 {
            let mut newline: i32 = luaG_getfuncline(p, npci);
            luaD_hook(L, 2 as i32, newline, 0, 0);
        }
        (*L).oldpc = npci;
    }
    if (*L).status as i32 == 1 as i32 {
        if counthook != 0 {
            (*L).hookcount = 1 as i32;
        }
        (*ci).callstatus = ((*ci).callstatus as i32 | (1 as i32) << 6 as i32) as u16;
        luaD_throw(L, 1 as i32);
    }
    return 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_newCclosure(
    mut L: *mut lua_State,
    mut nupvals: i32,
) -> *mut CClosure {
    let mut o: *mut GCObject = luaC_newobj(
        L,
        6 as i32 | (2 as i32) << 4 as i32,
        (32 as usize as i32 + ::core::mem::size_of::<TValue>() as usize as i32 * nupvals) as size_t,
    );
    let mut c: *mut CClosure = &mut (*(o as *mut GCUnion)).cl.c;
    (*c).nupvalues = nupvals as lu_byte;
    return c;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_newLclosure(
    mut L: *mut lua_State,
    mut nupvals: i32,
) -> *mut LClosure {
    let mut o: *mut GCObject = luaC_newobj(
        L,
        6 as i32 | (0) << 4 as i32,
        (32 as usize as i32 + ::core::mem::size_of::<*mut TValue>() as usize as i32 * nupvals)
            as size_t,
    );
    let mut c: *mut LClosure = &mut (*(o as *mut GCUnion)).cl.l;
    (*c).p = 0 as *mut Proto;
    (*c).nupvalues = nupvals as lu_byte;
    loop {
        let fresh112 = nupvals;
        nupvals = nupvals - 1;
        if !(fresh112 != 0) {
            break;
        }
        let ref mut fresh113 = *((*c).upvals).as_mut_ptr().offset(nupvals as isize);
        *fresh113 = 0 as *mut UpVal;
    }
    return c;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_initupvals(mut L: *mut lua_State, mut cl: *mut LClosure) {
    let mut i: i32 = 0;
    i = 0;
    while i < (*cl).nupvalues as i32 {
        let mut o: *mut GCObject = luaC_newobj(
            L,
            9 as i32 | (0) << 4 as i32,
            ::core::mem::size_of::<UpVal>() as usize,
        );
        let mut uv: *mut UpVal = &mut (*(o as *mut GCUnion)).upv;
        (*uv).v.p = &mut (*uv).u.value;
        (*(*uv).v.p).tt_ = (0 | (0) << 4 as i32) as lu_byte;
        let ref mut fresh114 = *((*cl).upvals).as_mut_ptr().offset(i as isize);
        *fresh114 = uv;
        if (*cl).marked as i32 & (1 as i32) << 5 as i32 != 0
            && (*uv).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
        {
            luaC_barrier_(
                L,
                &mut (*(cl as *mut GCUnion)).gc,
                &mut (*(uv as *mut GCUnion)).gc,
            );
        } else {
        };
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn newupval(
    mut L: *mut lua_State,
    mut level: StkId,
    mut prev: *mut *mut UpVal,
) -> *mut UpVal {
    let mut o: *mut GCObject = luaC_newobj(
        L,
        9 as i32 | (0) << 4 as i32,
        ::core::mem::size_of::<UpVal>() as usize,
    );
    let mut uv: *mut UpVal = &mut (*(o as *mut GCUnion)).upv;
    let mut next: *mut UpVal = *prev;
    (*uv).v.p = &mut (*level).val;
    (*uv).u.open.next = next;
    (*uv).u.open.previous = prev;
    if !next.is_null() {
        (*next).u.open.previous = &mut (*uv).u.open.next;
    }
    *prev = uv;
    if !((*L).twups != L) {
        (*L).twups = (*(*L).l_G).twups;
        (*(*L).l_G).twups = L;
    }
    return uv;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_findupval(
    mut L: *mut lua_State,
    mut level: StkId,
) -> *mut UpVal {
    let mut pp: *mut *mut UpVal = &mut (*L).openupval;
    let mut p: *mut UpVal = 0 as *mut UpVal;
    loop {
        p = *pp;
        if !(!p.is_null() && (*p).v.p as StkId >= level) {
            break;
        }
        if (*p).v.p as StkId == level {
            return p;
        }
        pp = &mut (*p).u.open.next;
    }
    return newupval(L, level, pp);
}
unsafe extern "C-unwind" fn callclosemethod(
    mut L: *mut lua_State,
    mut obj: *mut TValue,
    mut err: *mut TValue,
    mut yy: i32,
) {
    let mut top: StkId = (*L).top.p;
    let mut tm: *const TValue = luaT_gettmbyobj(L, obj, TM_CLOSE);
    let mut io1: *mut TValue = &mut (*top).val;
    let mut io2: *const TValue = tm;
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io1_0: *mut TValue = &mut (*top.offset(1)).val;
    let mut io2_0: *const TValue = obj;
    (*io1_0).value_ = (*io2_0).value_;
    (*io1_0).tt_ = (*io2_0).tt_;
    if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_0).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io1_1: *mut TValue = &mut (*top.offset(2)).val;
    let mut io2_1: *const TValue = err;
    (*io1_1).value_ = (*io2_1).value_;
    (*io1_1).tt_ = (*io2_1).tt_;
    if (*io1_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_1).tt_ as i32 & 0x3f as i32 == (*(*io1_1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = top.offset(3);
    if yy != 0 {
        luaD_call(L, top, 0);
    } else {
        luaD_callnoyield(L, top, 0);
    };
}
unsafe extern "C-unwind" fn checkclosemth(mut L: *mut lua_State, mut level: StkId) {
    let mut tm: *const TValue = luaT_gettmbyobj(L, &mut (*level).val, TM_CLOSE);
    if (*tm).tt_ as i32 & 0xf as i32 == 0 {
        let mut idx: i32 = level.offset_from((*(*L).ci).func.p) as std::ffi::c_long as i32;
        let mut vname: *const std::ffi::c_char = luaG_findlocal(L, (*L).ci, idx, 0 as *mut StkId);
        if vname.is_null() {
            vname = c"?".as_ptr();
        }
        luaG_runerror(L, c"variable '%s' got a non-closable value".as_ptr(), vname);
    }
}
unsafe extern "C-unwind" fn prepcallclosemth(
    mut L: *mut lua_State,
    mut level: StkId,
    mut status: i32,
    mut yy: i32,
) {
    let mut uv: *mut TValue = &mut (*level).val;
    let mut errobj: *mut TValue = 0 as *mut TValue;
    if status == -(1 as i32) {
        errobj = &mut (*(*L).l_G).nilvalue;
    } else {
        errobj = &mut (*level.offset(1)).val;
        luaD_seterrorobj(L, status, level.offset(1));
    }
    callclosemethod(L, uv, errobj, yy);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_newtbcupval(mut L: *mut lua_State, mut level: StkId) {
    if (*level).val.tt_ as i32 == 1 as i32 | (0) << 4 as i32
        || (*level).val.tt_ as i32 & 0xf as i32 == 0
    {
        return;
    }
    checkclosemth(L, level);
    while level.offset_from((*L).tbclist.p) as std::ffi::c_long as u32 as usize
        > ((256 as usize)
            << (::core::mem::size_of::<u16>() as usize)
                .wrapping_sub(1)
                .wrapping_mul(8))
        .wrapping_sub(1)
    {
        (*L).tbclist.p = ((*L).tbclist.p).offset(
            ((256 as usize)
                << (::core::mem::size_of::<u16>() as usize)
                    .wrapping_sub(1)
                    .wrapping_mul(8))
            .wrapping_sub(1) as isize,
        );
        (*(*L).tbclist.p).tbclist.delta = 0 as u16;
    }
    (*level).tbclist.delta = level.offset_from((*L).tbclist.p) as std::ffi::c_long as u16;
    (*L).tbclist.p = level;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_unlinkupval(mut uv: *mut UpVal) {
    *(*uv).u.open.previous = (*uv).u.open.next;
    if !((*uv).u.open.next).is_null() {
        (*(*uv).u.open.next).u.open.previous = (*uv).u.open.previous;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_closeupval(mut L: *mut lua_State, mut level: StkId) {
    let mut uv: *mut UpVal = 0 as *mut UpVal;
    let mut upl: StkId = 0 as *mut StackValue;
    loop {
        uv = (*L).openupval;
        if !(!uv.is_null() && {
            upl = (*uv).v.p as StkId;
            upl >= level
        }) {
            break;
        }
        let mut slot: *mut TValue = &mut (*uv).u.value;
        luaF_unlinkupval(uv);
        let mut io1: *mut TValue = slot;
        let mut io2: *const TValue = (*uv).v.p;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*uv).v.p = slot;
        if (*uv).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) == 0 {
            (*uv).marked = ((*uv).marked as i32 | (1 as i32) << 5 as i32) as lu_byte;
            if (*slot).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                if (*uv).marked as i32 & (1 as i32) << 5 as i32 != 0
                    && (*(*slot).value_.gc).marked as i32
                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                        != 0
                {
                    luaC_barrier_(
                        L,
                        &mut (*(uv as *mut GCUnion)).gc,
                        &mut (*((*slot).value_.gc as *mut GCUnion)).gc,
                    );
                } else {
                };
            } else {
            };
        }
    }
}
unsafe extern "C-unwind" fn poptbclist(mut L: *mut lua_State) {
    let mut tbc: StkId = (*L).tbclist.p;
    tbc = tbc.offset(-((*tbc).tbclist.delta as i32 as isize));
    while tbc > (*L).stack.p && (*tbc).tbclist.delta as i32 == 0 {
        tbc = tbc.offset(
            -(((256 as usize)
                << (::core::mem::size_of::<u16>() as usize)
                    .wrapping_sub(1)
                    .wrapping_mul(8))
            .wrapping_sub(1) as isize),
        );
    }
    (*L).tbclist.p = tbc;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_close(
    mut L: *mut lua_State,
    mut level: StkId,
    mut status: i32,
    mut yy: i32,
) -> StkId {
    let mut levelrel: ptrdiff_t =
        (level as *mut std::ffi::c_char).offset_from((*L).stack.p as *mut std::ffi::c_char);
    luaF_closeupval(L, level);
    while (*L).tbclist.p >= level {
        let mut tbc: StkId = (*L).tbclist.p;
        poptbclist(L);
        prepcallclosemth(L, tbc, status, yy);
        level = ((*L).stack.p as *mut std::ffi::c_char).offset(levelrel as isize) as StkId;
    }
    return level;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_newproto(mut L: *mut lua_State) -> *mut Proto {
    let mut o: *mut GCObject = luaC_newobj(
        L,
        9 as i32 + 1 as i32 | (0) << 4 as i32,
        ::core::mem::size_of::<Proto>() as usize,
    );
    let mut f: *mut Proto = &mut (*(o as *mut GCUnion)).p;
    (*f).k = 0 as *mut TValue;
    (*f).sizek = 0;
    (*f).p = 0 as *mut *mut Proto;
    (*f).sizep = 0;
    (*f).code = 0 as *mut Instruction;
    (*f).sizecode = 0;
    (*f).lineinfo = 0 as *mut ls_byte;
    (*f).sizelineinfo = 0;
    (*f).abslineinfo = 0 as *mut AbsLineInfo;
    (*f).sizeabslineinfo = 0;
    (*f).upvalues = 0 as *mut Upvaldesc;
    (*f).sizeupvalues = 0;
    (*f).numparams = 0 as lu_byte;
    (*f).is_vararg = 0 as lu_byte;
    (*f).maxstacksize = 0 as lu_byte;
    (*f).locvars = 0 as *mut LocVar;
    (*f).sizelocvars = 0;
    (*f).linedefined = 0;
    (*f).lastlinedefined = 0;
    (*f).source = 0 as *mut TString;
    return f;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_freeproto(mut L: *mut lua_State, mut f: *mut Proto) {
    luaM_free_(
        L,
        (*f).code as *mut c_void,
        ((*f).sizecode as usize).wrapping_mul(::core::mem::size_of::<Instruction>() as usize),
    );
    luaM_free_(
        L,
        (*f).p as *mut c_void,
        ((*f).sizep as usize).wrapping_mul(::core::mem::size_of::<*mut Proto>() as usize),
    );
    luaM_free_(
        L,
        (*f).k as *mut c_void,
        ((*f).sizek as usize).wrapping_mul(::core::mem::size_of::<TValue>() as usize),
    );
    luaM_free_(
        L,
        (*f).lineinfo as *mut c_void,
        ((*f).sizelineinfo as usize).wrapping_mul(::core::mem::size_of::<ls_byte>() as usize),
    );
    luaM_free_(
        L,
        (*f).abslineinfo as *mut c_void,
        ((*f).sizeabslineinfo as usize)
            .wrapping_mul(::core::mem::size_of::<AbsLineInfo>() as usize),
    );
    luaM_free_(
        L,
        (*f).locvars as *mut c_void,
        ((*f).sizelocvars as usize).wrapping_mul(::core::mem::size_of::<LocVar>() as usize),
    );
    luaM_free_(
        L,
        (*f).upvalues as *mut c_void,
        ((*f).sizeupvalues as usize).wrapping_mul(::core::mem::size_of::<Upvaldesc>() as usize),
    );
    luaM_free_(
        L,
        f as *mut c_void,
        ::core::mem::size_of::<Proto>() as usize,
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaF_getlocalname(
    mut f: *const Proto,
    mut local_number: i32,
    mut pc: i32,
) -> *const std::ffi::c_char {
    let mut i: i32 = 0;
    i = 0;
    while i < (*f).sizelocvars && (*((*f).locvars).offset(i as isize)).startpc <= pc {
        if pc < (*((*f).locvars).offset(i as isize)).endpc {
            local_number -= 1;
            local_number;
            if local_number == 0 {
                return ((*(*((*f).locvars).offset(i as isize)).varname).contents).as_mut_ptr();
            }
        }
        i += 1;
        i;
    }
    return 0 as *const std::ffi::c_char;
}

static mut udatatypename: [std::ffi::c_char; 9] =
    unsafe { *::core::mem::transmute::<&[u8; 9], &[std::ffi::c_char; 9]>(b"userdata\0") };
#[unsafe(no_mangle)]
pub static mut luaT_typenames_: [*const std::ffi::c_char; 12] = unsafe {
    [
        c"no value".as_ptr(),
        c"nil".as_ptr(),
        c"boolean".as_ptr(),
        c"userdata".as_ptr(),
        c"number".as_ptr(),
        c"string".as_ptr(),
        c"table".as_ptr(),
        c"function".as_ptr(),
        c"userdata".as_ptr(),
        c"thread".as_ptr(),
        c"upvalue".as_ptr(),
        c"proto".as_ptr(),
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_init(mut L: *mut lua_State) {
    static mut luaT_eventname: [*const std::ffi::c_char; 25] = [
        c"__index".as_ptr(),
        c"__newindex".as_ptr(),
        c"__gc".as_ptr(),
        c"__mode".as_ptr(),
        c"__len".as_ptr(),
        c"__eq".as_ptr(),
        c"__add".as_ptr(),
        c"__sub".as_ptr(),
        c"__mul".as_ptr(),
        c"__mod".as_ptr(),
        c"__pow".as_ptr(),
        c"__div".as_ptr(),
        c"__idiv".as_ptr(),
        c"__band".as_ptr(),
        c"__bor".as_ptr(),
        c"__bxor".as_ptr(),
        c"__shl".as_ptr(),
        c"__shr".as_ptr(),
        c"__unm".as_ptr(),
        c"__bnot".as_ptr(),
        c"__lt".as_ptr(),
        c"__le".as_ptr(),
        c"__concat".as_ptr(),
        c"__call".as_ptr(),
        c"__close".as_ptr(),
    ];
    let mut i: i32 = 0;
    i = 0;
    while i < TM_N as i32 {
        (*(*L).l_G).tmname[i as usize] = luaS_new(L, luaT_eventname[i as usize]);
        luaC_fix(
            L,
            &mut (*(*((*(*L).l_G).tmname).as_mut_ptr().offset(i as isize) as *mut GCUnion)).gc,
        );
        i += 1;
        i;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_gettm(
    mut events: *mut Table,
    mut event: TMS,
    mut ename: *mut TString,
) -> *const TValue {
    let mut tm: *const TValue = luaH_getshortstr(events, ename);
    if (*tm).tt_ as i32 & 0xf as i32 == 0 {
        (*events).flags =
            ((*events).flags as i32 | ((1 as u32) << event as u32) as lu_byte as i32) as lu_byte;
        return 0 as *const TValue;
    } else {
        return tm;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_gettmbyobj(
    mut L: *mut lua_State,
    mut o: *const TValue,
    mut event: TMS,
) -> *const TValue {
    let mut mt: *mut Table = 0 as *mut Table;
    match (*o).tt_ as i32 & 0xf as i32 {
        5 => {
            mt = (*&mut (*((*o).value_.gc as *mut GCUnion)).h).metatable;
        }
        7 => {
            mt = (*&mut (*((*o).value_.gc as *mut GCUnion)).u).metatable;
        }
        _ => {
            mt = (*(*L).l_G).mt[((*o).tt_ as i32 & 0xf as i32) as usize];
        }
    }
    return if !mt.is_null() {
        luaH_getshortstr(mt, (*(*L).l_G).tmname[event as usize])
    } else {
        &mut (*(*L).l_G).nilvalue as *mut TValue as *const TValue
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_objtypename(
    mut L: *mut lua_State,
    mut o: *const TValue,
) -> *const std::ffi::c_char {
    let mut mt: *mut Table = 0 as *mut Table;
    if (*o).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32 && {
        mt = (*(&mut (*((*o).value_.gc as *mut GCUnion)).h as *mut Table)).metatable;
        !mt.is_null()
    } || (*o).tt_ as i32 == 7 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32 && {
        mt = (*(&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata)).metatable;
        !mt.is_null()
    } {
        let mut name: *const TValue = luaH_getshortstr(mt, luaS_new(L, c"__name".as_ptr()));
        if (*name).tt_ as i32 & 0xf as i32 == 4 as i32 {
            return ((*&mut (*((*name).value_.gc as *mut GCUnion)).ts).contents).as_mut_ptr();
        }
    }
    return luaT_typenames_[(((*o).tt_ as i32 & 0xf as i32) + 1 as i32) as usize];
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_callTM(
    mut L: *mut lua_State,
    mut f: *const TValue,
    mut p1: *const TValue,
    mut p2: *const TValue,
    mut p3: *const TValue,
) {
    let mut func: StkId = (*L).top.p;
    let mut io1: *mut TValue = &mut (*func).val;
    let mut io2: *const TValue = f;
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io1_0: *mut TValue = &mut (*func.offset(1)).val;
    let mut io2_0: *const TValue = p1;
    (*io1_0).value_ = (*io2_0).value_;
    (*io1_0).tt_ = (*io2_0).tt_;
    if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_0).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io1_1: *mut TValue = &mut (*func.offset(2)).val;
    let mut io2_1: *const TValue = p2;
    (*io1_1).value_ = (*io2_1).value_;
    (*io1_1).tt_ = (*io2_1).tt_;
    if (*io1_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_1).tt_ as i32 & 0x3f as i32 == (*(*io1_1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io1_2: *mut TValue = &mut (*func.offset(3)).val;
    let mut io2_2: *const TValue = p3;
    (*io1_2).value_ = (*io2_2).value_;
    (*io1_2).tt_ = (*io2_2).tt_;
    if (*io1_2).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_2).tt_ as i32 & 0x3f as i32 == (*(*io1_2).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_2).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = func.offset(4);
    if (*(*L).ci).callstatus as i32 & ((1 as i32) << 1 as i32 | (1 as i32) << 3 as i32) == 0 {
        luaD_call(L, func, 0);
    } else {
        luaD_callnoyield(L, func, 0);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_callTMres(
    mut L: *mut lua_State,
    mut f: *const TValue,
    mut p1: *const TValue,
    mut p2: *const TValue,
    mut res: StkId,
) {
    let mut result: ptrdiff_t =
        (res as *mut std::ffi::c_char).offset_from((*L).stack.p as *mut std::ffi::c_char);
    let mut func: StkId = (*L).top.p;
    let mut io1: *mut TValue = &mut (*func).val;
    let mut io2: *const TValue = f;
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io1_0: *mut TValue = &mut (*func.offset(1)).val;
    let mut io2_0: *const TValue = p1;
    (*io1_0).value_ = (*io2_0).value_;
    (*io1_0).tt_ = (*io2_0).tt_;
    if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_0).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    let mut io1_1: *mut TValue = &mut (*func.offset(2)).val;
    let mut io2_1: *const TValue = p2;
    (*io1_1).value_ = (*io2_1).value_;
    (*io1_1).tt_ = (*io2_1).tt_;
    if (*io1_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_1).tt_ as i32 & 0x3f as i32 == (*(*io1_1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(3);
    if (*(*L).ci).callstatus as i32 & ((1 as i32) << 1 as i32 | (1 as i32) << 3 as i32) == 0 {
        luaD_call(L, func, 1 as i32);
    } else {
        luaD_callnoyield(L, func, 1 as i32);
    }
    res = ((*L).stack.p as *mut std::ffi::c_char).offset(result as isize) as StkId;
    let mut io1_2: *mut TValue = &mut (*res).val;
    (*L).top.p = ((*L).top.p).offset(-1);
    let mut io2_2: *const TValue = &mut (*(*L).top.p).val;
    (*io1_2).value_ = (*io2_2).value_;
    (*io1_2).tt_ = (*io2_2).tt_;
    if (*io1_2).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1_2).tt_ as i32 & 0x3f as i32 == (*(*io1_2).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1_2).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
}
unsafe extern "C-unwind" fn callbinTM(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
    mut res: StkId,
    mut event: TMS,
) -> i32 {
    let mut tm: *const TValue = luaT_gettmbyobj(L, p1, event);
    if (*tm).tt_ as i32 & 0xf as i32 == 0 {
        tm = luaT_gettmbyobj(L, p2, event);
    }
    if (*tm).tt_ as i32 & 0xf as i32 == 0 {
        return 0;
    }
    luaT_callTMres(L, tm, p1, p2, res);
    return 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_trybinTM(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
    mut res: StkId,
    mut event: TMS,
) {
    if ((callbinTM(L, p1, p2, res, event) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        match event as u32 {
            13 | 14 | 15 | 16 | 17 | 19 => {
                if (*p1).tt_ as i32 & 0xf as i32 == 3 as i32
                    && (*p2).tt_ as i32 & 0xf as i32 == 3 as i32
                {
                    luaG_tointerror(L, p1, p2);
                } else {
                    luaG_opinterror(L, p1, p2, c"perform bitwise operation on".as_ptr());
                }
            }
            _ => {
                luaG_opinterror(L, p1, p2, c"perform arithmetic on".as_ptr());
            }
        }
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_tryconcatTM(mut L: *mut lua_State) {
    let mut top: StkId = (*L).top.p;
    if ((callbinTM(
        L,
        &mut (*top.offset(-(2))).val,
        &mut (*top.offset(-(1))).val,
        top.offset(-(2)),
        TM_CONCAT,
    ) == 0) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        luaG_concaterror(
            L,
            &mut (*top.offset(-(2))).val,
            &mut (*top.offset(-(1))).val,
        );
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_trybinassocTM(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
    mut flip: i32,
    mut res: StkId,
    mut event: TMS,
) {
    if flip != 0 {
        luaT_trybinTM(L, p2, p1, res, event);
    } else {
        luaT_trybinTM(L, p1, p2, res, event);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_trybiniTM(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut i2: lua_Integer,
    mut flip: i32,
    mut res: StkId,
    mut event: TMS,
) {
    let mut aux: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut io: *mut TValue = &mut aux;
    (*io).value_.i = i2;
    (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
    luaT_trybinassocTM(L, p1, &mut aux, flip, res, event);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_callorderTM(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut p2: *const TValue,
    mut event: TMS,
) -> i32 {
    if callbinTM(L, p1, p2, (*L).top.p, event) != 0 {
        return !((*(*L).top.p).val.tt_ as i32 == 1 as i32 | (0) << 4 as i32
            || (*(*L).top.p).val.tt_ as i32 & 0xf as i32 == 0) as i32;
    }
    luaG_ordererror(L, p1, p2);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_callorderiTM(
    mut L: *mut lua_State,
    mut p1: *const TValue,
    mut v2: i32,
    mut flip: i32,
    mut isfloat: i32,
    mut event: TMS,
) -> i32 {
    let mut aux: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut p2: *const TValue = 0 as *const TValue;
    if isfloat != 0 {
        let mut io: *mut TValue = &mut aux;
        (*io).value_.n = v2 as lua_Number;
        (*io).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
    } else {
        let mut io_0: *mut TValue = &mut aux;
        (*io_0).value_.i = v2 as lua_Integer;
        (*io_0).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
    }
    if flip != 0 {
        p2 = p1;
        p1 = &mut aux;
    } else {
        p2 = &mut aux;
    }
    return luaT_callorderTM(L, p1, p2, event);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_adjustvarargs(
    mut L: *mut lua_State,
    mut nfixparams: i32,
    mut ci: *mut CallInfo,
    mut p: *const Proto,
) {
    let mut i: i32 = 0;
    let mut actual: i32 =
        ((*L).top.p).offset_from((*ci).func.p) as std::ffi::c_long as i32 - 1 as i32;
    let mut nextra: i32 = actual - nfixparams;
    (*ci).u.l.nextraargs = nextra;
    if ((((*L).stack_last.p).offset_from((*L).top.p) as std::ffi::c_long
        <= ((*p).maxstacksize as i32 + 1 as i32) as std::ffi::c_long) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        luaD_growstack(L, (*p).maxstacksize as i32 + 1 as i32, 1 as i32);
    }
    let fresh118 = (*L).top.p;
    (*L).top.p = ((*L).top.p).offset(1);
    let mut io1: *mut TValue = &mut (*fresh118).val;
    let mut io2: *const TValue = &mut (*(*ci).func.p).val;
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    i = 1 as i32;
    while i <= nfixparams {
        let fresh119 = (*L).top.p;
        (*L).top.p = ((*L).top.p).offset(1);
        let mut io1_0: *mut TValue = &mut (*fresh119).val;
        let mut io2_0: *const TValue = &mut (*((*ci).func.p).offset(i as isize)).val;
        (*io1_0).value_ = (*io2_0).value_;
        (*io1_0).tt_ = (*io2_0).tt_;
        if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1_0).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*((*ci).func.p).offset(i as isize)).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
        i += 1;
        i;
    }
    (*ci).func.p = ((*ci).func.p).offset((actual + 1 as i32) as isize);
    (*ci).top.p = ((*ci).top.p).offset((actual + 1 as i32) as isize);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaT_getvarargs(
    mut L: *mut lua_State,
    mut ci: *mut CallInfo,
    mut where_0: StkId,
    mut wanted: i32,
) {
    let mut i: i32 = 0;
    let mut nextra: i32 = (*ci).u.l.nextraargs;
    if wanted < 0 {
        wanted = nextra;
        if ((((*L).stack_last.p).offset_from((*L).top.p) as std::ffi::c_long
            <= nextra as std::ffi::c_long) as i32
            != 0) as i32 as std::ffi::c_long
            != 0
        {
            let mut t__: ptrdiff_t = (where_0 as *mut std::ffi::c_char)
                .offset_from((*L).stack.p as *mut std::ffi::c_char);
            if (*(*L).l_G).GCdebt > 0 as l_mem {
                luaC_step(L);
            }
            luaD_growstack(L, nextra, 1 as i32);
            where_0 = ((*L).stack.p as *mut std::ffi::c_char).offset(t__ as isize) as StkId;
        }
        (*L).top.p = where_0.offset(nextra as isize);
    }
    i = 0;
    while i < wanted && i < nextra {
        let mut io1: *mut TValue = &mut (*where_0.offset(i as isize)).val;
        let mut io2: *const TValue =
            &mut (*((*ci).func.p).offset(-(nextra as isize)).offset(i as isize)).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        i += 1;
        i;
    }
    while i < wanted {
        (*where_0.offset(i as isize)).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
        i += 1;
        i;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_eqlngstr(mut a: *mut TString, mut b: *mut TString) -> i32 {
    let mut len: size_t = (*a).u.lnglen;
    return (a == b
        || len == (*b).u.lnglen
            && memcmp(
                ((*a).contents).as_mut_ptr() as *const c_void,
                ((*b).contents).as_mut_ptr() as *const c_void,
                len,
            ) == 0) as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_hash(
    mut str: *const std::ffi::c_char,
    mut l: size_t,
    mut seed: u32,
) -> u32 {
    let mut h: u32 = seed ^ l as u32;
    while l > 0 as size_t {
        h ^= (h << 5 as i32).wrapping_add(h >> 2 as i32).wrapping_add(
            *str.offset(l.wrapping_sub(1 as i32 as size_t) as isize) as lu_byte as u32,
        );
        l = l.wrapping_sub(1);
        l;
    }
    return h;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_hashlongstr(mut ts: *mut TString) -> u32 {
    if (*ts).extra as i32 == 0 {
        let mut len: size_t = (*ts).u.lnglen;
        (*ts).hash = luaS_hash(((*ts).contents).as_mut_ptr(), len, (*ts).hash);
        (*ts).extra = 1 as i32 as lu_byte;
    }
    return (*ts).hash;
}
unsafe extern "C-unwind" fn tablerehash(
    mut vect: *mut *mut TString,
    mut osize: i32,
    mut nsize: i32,
) {
    let mut i: i32 = 0;
    i = osize;
    while i < nsize {
        let ref mut fresh120 = *vect.offset(i as isize);
        *fresh120 = 0 as *mut TString;
        i += 1;
        i;
    }
    i = 0;
    while i < osize {
        let mut p: *mut TString = *vect.offset(i as isize);
        let ref mut fresh121 = *vect.offset(i as isize);
        *fresh121 = 0 as *mut TString;
        while !p.is_null() {
            let mut hnext: *mut TString = (*p).u.hnext;
            let mut h: u32 = ((*p).hash & (nsize - 1 as i32) as u32) as i32 as u32;
            (*p).u.hnext = *vect.offset(h as isize);
            let ref mut fresh122 = *vect.offset(h as isize);
            *fresh122 = p;
            p = hnext;
        }
        i += 1;
        i;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_resize(mut L: *mut lua_State, mut nsize: i32) {
    let mut tb: *mut stringtable = &mut (*(*L).l_G).strt;
    let mut osize: i32 = (*tb).size;
    let mut newvect: *mut *mut TString = 0 as *mut *mut TString;
    if nsize < osize {
        tablerehash((*tb).hash, osize, nsize);
    }
    newvect = luaM_realloc_(
        L,
        (*tb).hash as *mut c_void,
        (osize as size_t).wrapping_mul(::core::mem::size_of::<*mut TString>() as usize),
        (nsize as size_t).wrapping_mul(::core::mem::size_of::<*mut TString>() as usize),
    ) as *mut *mut TString;
    if ((newvect == 0 as *mut c_void as *mut *mut TString) as i32 != 0) as i32 as std::ffi::c_long
        != 0
    {
        if nsize < osize {
            tablerehash((*tb).hash, nsize, osize);
        }
    } else {
        (*tb).hash = newvect;
        (*tb).size = nsize;
        if nsize > osize {
            tablerehash(newvect, osize, nsize);
        }
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_clearcache(mut g: *mut global_State) {
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    i = 0;
    while i < 53 as i32 {
        j = 0;
        while j < 2 as i32 {
            if (*(*g).strcache[i as usize][j as usize]).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
            {
                (*g).strcache[i as usize][j as usize] = (*g).memerrmsg;
            }
            j += 1;
            j;
        }
        i += 1;
        i;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_init(mut L: *mut lua_State) {
    let mut g: *mut global_State = (*L).l_G;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut tb: *mut stringtable = &mut (*(*L).l_G).strt;
    (*tb).hash = luaM_malloc_(
        L,
        (128usize).wrapping_mul(::core::mem::size_of::<*mut TString>() as usize),
        0,
    ) as *mut *mut TString;
    tablerehash((*tb).hash, 0, 128 as i32);
    (*tb).size = 128 as i32;
    (*g).memerrmsg = luaS_newlstr(
        L,
        c"not enough memory".as_ptr(),
        (::core::mem::size_of::<[std::ffi::c_char; 18]>() as usize)
            .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
            .wrapping_sub(1),
    );
    luaC_fix(L, &mut (*((*g).memerrmsg as *mut GCUnion)).gc);
    i = 0;
    while i < 53 as i32 {
        j = 0;
        while j < 2 as i32 {
            (*g).strcache[i as usize][j as usize] = (*g).memerrmsg;
            j += 1;
            j;
        }
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn createstrobj(
    mut L: *mut lua_State,
    mut l: size_t,
    mut tag: i32,
    mut h: u32,
) -> *mut TString {
    let mut ts: *mut TString = 0 as *mut TString;
    let mut o: *mut GCObject = 0 as *mut GCObject;
    let mut totalsize: size_t = 0;
    totalsize = (24 as usize).wrapping_add(
        l.wrapping_add(1 as i32 as size_t)
            .wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
    );
    o = luaC_newobj(L, tag, totalsize);
    ts = &mut (*(o as *mut GCUnion)).ts;
    (*ts).hash = h;
    (*ts).extra = 0 as lu_byte;
    *((*ts).contents).as_mut_ptr().offset(l as isize) = '\0' as i32 as std::ffi::c_char;
    return ts;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_createlngstrobj(
    mut L: *mut lua_State,
    mut l: size_t,
) -> *mut TString {
    let mut ts: *mut TString =
        createstrobj(L, l, 4 as i32 | (1 as i32) << 4 as i32, (*(*L).l_G).seed);
    (*ts).u.lnglen = l;
    (*ts).shrlen = 0xff as i32 as lu_byte;
    return ts;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_remove(mut L: *mut lua_State, mut ts: *mut TString) {
    let mut tb: *mut stringtable = &mut (*(*L).l_G).strt;
    let mut p: *mut *mut TString = &mut *((*tb).hash)
        .offset(((*ts).hash & ((*tb).size - 1 as i32) as u32) as i32 as isize)
        as *mut *mut TString;
    while *p != ts {
        p = &mut (**p).u.hnext;
    }
    *p = (**p).u.hnext;
    (*tb).nuse -= 1;
    (*tb).nuse;
}
unsafe extern "C-unwind" fn growstrtab(mut L: *mut lua_State, mut tb: *mut stringtable) {
    if (((*tb).nuse == 2147483647 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaC_fullgc(L, 1 as i32);
        if (*tb).nuse == 2147483647 as i32 {
            luaD_throw(L, 4 as i32);
        }
    }
    if (*tb).size
        <= (if 2147483647 as i32 as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<*mut TString>() as usize)
        {
            2147483647
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<*mut TString>() as usize) as u32
        }) as i32
            / 2 as i32
    {
        luaS_resize(L, (*tb).size * 2 as i32);
    }
}
unsafe extern "C-unwind" fn internshrstr(
    mut L: *mut lua_State,
    mut str: *const std::ffi::c_char,
    mut l: size_t,
) -> *mut TString {
    let mut ts: *mut TString = 0 as *mut TString;
    let mut g: *mut global_State = (*L).l_G;
    let mut tb: *mut stringtable = &mut (*g).strt;
    let mut h: u32 = luaS_hash(str, l, (*g).seed);
    let mut list: *mut *mut TString = &mut *((*tb).hash)
        .offset((h & ((*tb).size - 1 as i32) as u32) as i32 as isize)
        as *mut *mut TString;
    ts = *list;
    while !ts.is_null() {
        if l == (*ts).shrlen as size_t
            && memcmp(
                str as *const c_void,
                ((*ts).contents).as_mut_ptr() as *const c_void,
                l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
            ) == 0
        {
            if (*ts).marked as i32
                & ((*g).currentwhite as i32 ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                != 0
            {
                (*ts).marked = ((*ts).marked as i32
                    ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    as lu_byte;
            }
            return ts;
        }
        ts = (*ts).u.hnext;
    }
    if (*tb).nuse >= (*tb).size {
        growstrtab(L, tb);
        list = &mut *((*tb).hash).offset((h & ((*tb).size - 1 as i32) as u32) as i32 as isize)
            as *mut *mut TString;
    }
    ts = createstrobj(L, l, 4 as i32 | (0) << 4 as i32, h);
    (*ts).shrlen = l as lu_byte;
    memcpy(
        ((*ts).contents).as_mut_ptr() as *mut c_void,
        str as *const c_void,
        l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
    );
    (*ts).u.hnext = *list;
    *list = ts;
    (*tb).nuse += 1;
    (*tb).nuse;
    return ts;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_newlstr(
    mut L: *mut lua_State,
    mut str: *const std::ffi::c_char,
    mut l: size_t,
) -> *mut TString {
    if l <= 40 as size_t {
        return internshrstr(L, str, l);
    } else {
        let mut ts: *mut TString = 0 as *mut TString;
        if ((l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize)
            >= (if (::core::mem::size_of::<size_t>() as usize)
                < ::core::mem::size_of::<lua_Integer>() as usize
            {
                !(0 as size_t)
            } else {
                9223372036854775807 as std::ffi::c_longlong as size_t
            })
            .wrapping_sub(::core::mem::size_of::<TString>() as usize)) as i32
            != 0) as i32 as std::ffi::c_long
            != 0
        {
            luaM_toobig(L);
        }
        ts = luaS_createlngstrobj(L, l);
        memcpy(
            ((*ts).contents).as_mut_ptr() as *mut c_void,
            str as *const c_void,
            l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
        );
        return ts;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_new(
    mut L: *mut lua_State,
    mut str: *const std::ffi::c_char,
) -> *mut TString {
    let mut i: u32 = ((str as uintptr_t
        & (2147483647u32)
            .wrapping_mul(2 as u32)
            .wrapping_add(1 as u32) as uintptr_t) as u32)
        .wrapping_rem(53);
    let mut j: i32 = 0;
    let mut p: *mut *mut TString = ((*(*L).l_G).strcache[i as usize]).as_mut_ptr();
    j = 0;
    while j < 2 as i32 {
        if strcmp(str, ((**p.offset(j as isize)).contents).as_mut_ptr()) == 0 {
            return *p.offset(j as isize);
        }
        j += 1;
        j;
    }
    j = 2 as i32 - 1 as i32;
    while j > 0 {
        let ref mut fresh123 = *p.offset(j as isize);
        *fresh123 = *p.offset((j - 1 as i32) as isize);
        j -= 1;
        j;
    }
    let ref mut fresh124 = *p.offset(0 as isize);
    *fresh124 = luaS_newlstr(L, str, strlen(str));
    return *p.offset(0 as isize);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaS_newudata(
    mut L: *mut lua_State,
    mut s: size_t,
    mut nuvalue: i32,
) -> *mut Udata {
    let mut u: *mut Udata = 0 as *mut Udata;
    let mut i: i32 = 0;
    let mut o: *mut GCObject = 0 as *mut GCObject;
    if ((s
        > (if (::core::mem::size_of::<size_t>() as usize)
            < ::core::mem::size_of::<lua_Integer>() as usize
        {
            !(0 as size_t)
        } else {
            9223372036854775807 as std::ffi::c_longlong as size_t
        })
        .wrapping_sub(
            (if nuvalue == 0 {
                32 as usize
            } else {
                (40 as usize).wrapping_add(
                    (::core::mem::size_of::<UValue>() as usize).wrapping_mul(nuvalue as usize),
                )
            }),
        )) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        luaM_toobig(L);
    }
    o = luaC_newobj(
        L,
        7 as i32 | (0) << 4 as i32,
        (if nuvalue == 0 {
            32 as usize
        } else {
            (40 as usize).wrapping_add(
                (::core::mem::size_of::<UValue>() as usize).wrapping_mul(nuvalue as usize),
            )
        })
        .wrapping_add(s),
    );
    u = &mut (*(o as *mut GCUnion)).u;
    (*u).len = s;
    (*u).nuvalue = nuvalue as u16;
    (*u).metatable = 0 as *mut Table;
    i = 0;
    while i < nuvalue {
        (*((*u).uv).as_mut_ptr().offset(i as isize)).uv.tt_ = (0 | (0) << 4 as i32) as lu_byte;
        i += 1;
        i;
    }
    return u;
}
static mut dummynode_: Node = Node {
    u: {
        let mut init = NodeKey {
            value_: Value {
                gc: 0 as *const GCObject as *mut GCObject,
            },
            tt_: (0 | (1 as i32) << 4 as i32) as lu_byte,
            key_tt: (0 | (0) << 4 as i32) as lu_byte,
            next: 0,
            key_val: Value {
                gc: 0 as *const GCObject as *mut GCObject,
            },
        };
        init
    },
};
static mut absentkey: TValue = {
    let mut init = TValue {
        value_: Value {
            gc: 0 as *const GCObject as *mut GCObject,
        },
        tt_: (0 | (2 as i32) << 4 as i32) as lu_byte,
    };
    init
};
unsafe extern "C-unwind" fn hashint(mut t: *const Table, mut i: lua_Integer) -> *mut Node {
    let mut ui: lua_Unsigned = i as lua_Unsigned;
    if ui <= 2147483647 as lua_Unsigned {
        return &mut *((*t).node).offset(
            (ui as i32 % (((1 as i32) << (*t).lsizenode as i32) - 1 as i32 | 1 as i32)) as isize,
        ) as *mut Node;
    } else {
        return &mut *((*t).node).offset(
            (ui % (((1 as i32) << (*t).lsizenode as i32) - 1 as i32 | 1 as i32) as lua_Unsigned)
                as isize,
        ) as *mut Node;
    };
}
unsafe extern "C-unwind" fn l_hashfloat(mut n: lua_Number) -> i32 {
    let mut i: i32 = 0;
    let mut ni: lua_Integer = 0;
    n = frexp(n, &mut i) * -((-(2147483647 as i32) - 1 as i32) as lua_Number);
    if !(n
        >= (-(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong)
            as std::ffi::c_double
        && n < -((-(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong)
            as std::ffi::c_double)
        && {
            ni = n as std::ffi::c_longlong;
            1 as i32 != 0
        })
    {
        return 0;
    } else {
        let mut u: u32 = (i as u32).wrapping_add(ni as u32);
        return (if u <= 2147483647 { u } else { !u }) as i32;
    };
}
unsafe extern "C-unwind" fn mainpositionTV(
    mut t: *const Table,
    mut key: *const TValue,
) -> *mut Node {
    match (*key).tt_ as i32 & 0x3f as i32 {
        3 => {
            let mut i: lua_Integer = (*key).value_.i;
            return hashint(t, i);
        }
        19 => {
            let mut n: lua_Number = (*key).value_.n;
            return &mut *((*t).node).offset(
                ((l_hashfloat as unsafe extern "C-unwind" fn(lua_Number) -> i32)(n)
                    % (((1 as i32) << (*t).lsizenode as i32) - 1 as i32 | 1 as i32))
                    as isize,
            ) as *mut Node;
        }
        4 => {
            let mut ts: *mut TString = &mut (*((*key).value_.gc as *mut GCUnion)).ts;
            return &mut *((*t).node).offset(
                ((*ts).hash & (((1 as i32) << (*t).lsizenode as i32) - 1 as i32) as u32) as i32
                    as isize,
            ) as *mut Node;
        }
        20 => {
            let mut ts_0: *mut TString = &mut (*((*key).value_.gc as *mut GCUnion)).ts;
            return &mut *((*t).node).offset(
                ((luaS_hashlongstr as unsafe extern "C-unwind" fn(*mut TString) -> u32)(ts_0)
                    & (((1 as i32) << (*t).lsizenode as i32) - 1 as i32) as u32)
                    as i32 as isize,
            ) as *mut Node;
        }
        1 => {
            return &mut *((*t).node)
                .offset((0 & ((1 as i32) << (*t).lsizenode as i32) - 1 as i32) as isize)
                as *mut Node;
        }
        17 => {
            return &mut *((*t).node)
                .offset((1 as i32 & ((1 as i32) << (*t).lsizenode as i32) - 1 as i32) as isize)
                as *mut Node;
        }
        2 => {
            let mut p: *mut c_void = (*key).value_.p;
            return &mut *((*t).node).offset(
                ((p as uintptr_t
                    & (2147483647u32)
                        .wrapping_mul(2 as u32)
                        .wrapping_add(1 as u32) as uintptr_t) as u32)
                    .wrapping_rem(
                        (((1 as i32) << (*t).lsizenode as i32) - 1 as i32 | 1 as i32) as u32,
                    ) as isize,
            ) as *mut Node;
        }
        22 => {
            let mut f: lua_CFunction = (*key).value_.f;
            return &mut *((*t).node).offset(
                ((::core::mem::transmute::<lua_CFunction, uintptr_t>(f)
                    & (2147483647u32)
                        .wrapping_mul(2 as u32)
                        .wrapping_add(1 as u32) as uintptr_t) as u32)
                    .wrapping_rem(
                        (((1 as i32) << (*t).lsizenode as i32) - 1 as i32 | 1 as i32) as u32,
                    ) as isize,
            ) as *mut Node;
        }
        _ => {
            let mut o: *mut GCObject = (*key).value_.gc;
            return &mut *((*t).node).offset(
                ((o as uintptr_t
                    & (2147483647u32)
                        .wrapping_mul(2 as u32)
                        .wrapping_add(1 as u32) as uintptr_t) as u32)
                    .wrapping_rem(
                        (((1 as i32) << (*t).lsizenode as i32) - 1 as i32 | 1 as i32) as u32,
                    ) as isize,
            ) as *mut Node;
        }
    };
}
#[inline]
unsafe extern "C-unwind" fn mainpositionfromnode(
    mut t: *const Table,
    mut nd: *mut Node,
) -> *mut Node {
    let mut key: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut io_: *mut TValue = &mut key;
    let mut n_: *const Node = nd;
    (*io_).value_ = (*n_).u.key_val;
    (*io_).tt_ = (*n_).u.key_tt;
    if (*io_).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io_).tt_ as i32 & 0x3f as i32 == (*(*io_).value_.gc).tt as i32
            && ((0 as *mut c_void as *mut lua_State).is_null()
                || (*(*io_).value_.gc).marked as i32
                    & ((*(*(0 as *mut c_void as *mut lua_State)).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    return mainpositionTV(t, &mut key);
}
unsafe extern "C-unwind" fn equalkey(
    mut k1: *const TValue,
    mut n2: *const Node,
    mut deadok: i32,
) -> i32 {
    if (*k1).tt_ as i32 != (*n2).u.key_tt as i32
        && !(deadok != 0
            && (*n2).u.key_tt as i32 == 9 as i32 + 2 as i32
            && (*k1).tt_ as i32 & (1 as i32) << 6 as i32 != 0)
    {
        return 0;
    }
    match (*n2).u.key_tt as i32 {
        0 | 1 | 17 => return 1 as i32,
        3 => return ((*k1).value_.i == (*n2).u.key_val.i) as i32,
        19 => return ((*k1).value_.n == (*n2).u.key_val.n) as i32,
        2 => return ((*k1).value_.p == (*n2).u.key_val.p) as i32,
        22 => return ((*k1).value_.f == (*n2).u.key_val.f) as i32,
        84 => {
            return luaS_eqlngstr(
                &mut (*((*k1).value_.gc as *mut GCUnion)).ts,
                &mut (*((*n2).u.key_val.gc as *mut GCUnion)).ts,
            );
        }
        _ => return ((*k1).value_.gc == (*n2).u.key_val.gc) as i32,
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_realasize(mut t: *const Table) -> u32 {
    if (*t).flags as i32 & (1 as i32) << 7 as i32 == 0
        || (*t).alimit & ((*t).alimit).wrapping_sub(1) == 0 as u32
    {
        return (*t).alimit;
    } else {
        let mut size: u32 = (*t).alimit;
        size |= size >> 1 as i32;
        size |= size >> 2 as i32;
        size |= size >> 4 as i32;
        size |= size >> 8 as i32;
        size |= size >> 16 as i32;
        size = size.wrapping_add(1);
        size;
        return size;
    };
}
unsafe extern "C-unwind" fn ispow2realasize(mut t: *const Table) -> i32 {
    return ((*t).flags as i32 & (1 as i32) << 7 as i32 != 0
        || (*t).alimit & ((*t).alimit).wrapping_sub(1) == 0 as u32) as i32;
}
unsafe extern "C-unwind" fn setlimittosize(mut t: *mut Table) -> u32 {
    (*t).alimit = luaH_realasize(t);
    (*t).flags = ((*t).flags as i32 & !((1 as i32) << 7 as i32) as lu_byte as i32) as lu_byte;
    return (*t).alimit;
}
unsafe extern "C-unwind" fn getgeneric(
    mut t: *mut Table,
    mut key: *const TValue,
    mut deadok: i32,
) -> *const TValue {
    let mut n: *mut Node = mainpositionTV(t, key);
    loop {
        if equalkey(key, n, deadok) != 0 {
            return &mut (*n).i_val;
        } else {
            let mut nx: i32 = (*n).u.next;
            if nx == 0 {
                return &raw const absentkey;
            }
            n = n.offset(nx as isize);
        }
    }
}
unsafe extern "C-unwind" fn arrayindex(mut k: lua_Integer) -> u32 {
    if (k as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned)
        < (if ((1 as u32)
            << (::core::mem::size_of::<i32>() as usize)
                .wrapping_mul(8)
                .wrapping_sub(1) as i32) as size_t
            <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<TValue>() as usize)
        {
            (1 as u32)
                << (::core::mem::size_of::<i32>() as usize)
                    .wrapping_mul(8)
                    .wrapping_sub(1) as i32
        } else {
            (!(0 as size_t)).wrapping_div(::core::mem::size_of::<TValue>() as usize) as u32
        }) as lua_Unsigned
    {
        return k as u32;
    } else {
        return 0 as u32;
    };
}
unsafe extern "C-unwind" fn findindex(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut key: *mut TValue,
    mut asize: u32,
) -> u32 {
    let mut i: u32 = 0;
    if (*key).tt_ as i32 & 0xf as i32 == 0 {
        return 0 as u32;
    }
    i = if (*key).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        arrayindex((*key).value_.i)
    } else {
        0 as u32
    };
    if i.wrapping_sub(1 as u32) < asize {
        return i;
    } else {
        let mut n: *const TValue = getgeneric(t, key, 1 as i32);
        if (((*n).tt_ as i32 == 0 | (2 as i32) << 4 as i32) as i32 != 0) as i32 as std::ffi::c_long
            != 0
        {
            luaG_runerror(L, c"invalid key to 'next'".as_ptr());
        }
        i = (n as *mut Node).offset_from(&mut *((*t).node).offset(0 as isize) as *mut Node)
            as std::ffi::c_long as i32 as u32;
        return i.wrapping_add(1).wrapping_add(asize);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_next(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut key: StkId,
) -> i32 {
    let mut asize: u32 = luaH_realasize(t);
    let mut i: u32 = findindex(L, t, &mut (*key).val, asize);
    while i < asize {
        if !((*((*t).array).offset(i as isize)).tt_ as i32 & 0xf as i32 == 0) {
            let mut io: *mut TValue = &mut (*key).val;
            (*io).value_.i = i.wrapping_add(1) as lua_Integer;
            (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
            let mut io1: *mut TValue = &mut (*key.offset(1)).val;
            let mut io2: *const TValue = &mut *((*t).array).offset(i as isize) as *mut TValue;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            return 1 as i32;
        }
        i = i.wrapping_add(1);
        i;
    }
    i = i.wrapping_sub(asize);
    while (i as i32) < (1 as i32) << (*t).lsizenode as i32 {
        if !((*((*t).node).offset(i as isize)).i_val.tt_ as i32 & 0xf as i32 == 0) {
            let mut n: *mut Node = &mut *((*t).node).offset(i as isize) as *mut Node;
            let mut io_: *mut TValue = &mut (*key).val;
            let mut n_: *const Node = n;
            (*io_).value_ = (*n_).u.key_val;
            (*io_).tt_ = (*n_).u.key_tt;
            if (*io_).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io_).tt_ as i32 & 0x3f as i32 == (*(*io_).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io_).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            let mut io1_0: *mut TValue = &mut (*key.offset(1)).val;
            let mut io2_0: *const TValue = &mut (*n).i_val;
            (*io1_0).value_ = (*io2_0).value_;
            (*io1_0).tt_ = (*io2_0).tt_;
            if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1_0).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            return 1 as i32;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0;
}
unsafe extern "C-unwind" fn freehash(mut L: *mut lua_State, mut t: *mut Table) {
    if !((*t).lastfree).is_null() {
        luaM_free_(
            L,
            (*t).node as *mut c_void,
            (((1 as i32) << (*t).lsizenode as i32) as size_t)
                .wrapping_mul(::core::mem::size_of::<Node>() as usize),
        );
    }
}
unsafe extern "C-unwind" fn computesizes(mut nums: *mut u32, mut pna: *mut u32) -> u32 {
    let mut i: i32 = 0;
    let mut twotoi: u32 = 0;
    let mut a: u32 = 0 as u32;
    let mut na: u32 = 0 as u32;
    let mut optimal: u32 = 0 as u32;
    i = 0;
    twotoi = 1;
    while twotoi > 0 as u32 && *pna > twotoi.wrapping_div(2) {
        a = a.wrapping_add(*nums.offset(i as isize));
        if a > twotoi.wrapping_div(2) {
            optimal = twotoi;
            na = a;
        }
        i += 1;
        i;
        twotoi = twotoi.wrapping_mul(2);
    }
    *pna = na;
    return optimal;
}
unsafe extern "C-unwind" fn countint(mut key: lua_Integer, mut nums: *mut u32) -> i32 {
    let mut k: u32 = arrayindex(key);
    if k != 0 as u32 {
        let ref mut fresh125 = *nums.offset(luaO_ceillog2(k) as isize);
        *fresh125 = (*fresh125).wrapping_add(1);
        *fresh125;
        return 1 as i32;
    } else {
        return 0;
    };
}
unsafe extern "C-unwind" fn numusearray(mut t: *const Table, mut nums: *mut u32) -> u32 {
    let mut lg: i32 = 0;
    let mut ttlg: u32 = 0;
    let mut ause: u32 = 0 as u32;
    let mut i: u32 = 1;
    let mut asize: u32 = (*t).alimit;
    lg = 0;
    ttlg = 1;
    while lg
        <= (::core::mem::size_of::<i32>() as usize)
            .wrapping_mul(8)
            .wrapping_sub(1) as i32
    {
        let mut lc: u32 = 0 as u32;
        let mut lim: u32 = ttlg;
        if lim > asize {
            lim = asize;
            if i > lim {
                break;
            }
        }
        while i <= lim {
            if !((*((*t).array).offset(i.wrapping_sub(1) as isize)).tt_ as i32 & 0xf as i32 == 0) {
                lc = lc.wrapping_add(1);
                lc;
            }
            i = i.wrapping_add(1);
            i;
        }
        let ref mut fresh126 = *nums.offset(lg as isize);
        *fresh126 = (*fresh126).wrapping_add(lc);
        ause = ause.wrapping_add(lc);
        lg += 1;
        lg;
        ttlg = ttlg.wrapping_mul(2);
    }
    return ause;
}
unsafe extern "C-unwind" fn numusehash(
    mut t: *const Table,
    mut nums: *mut u32,
    mut pna: *mut u32,
) -> i32 {
    let mut totaluse: i32 = 0;
    let mut ause: i32 = 0;
    let mut i: i32 = (1 as i32) << (*t).lsizenode as i32;
    loop {
        let fresh127 = i;
        i = i - 1;
        if !(fresh127 != 0) {
            break;
        }
        let mut n: *mut Node = &mut *((*t).node).offset(i as isize) as *mut Node;
        if !((*n).i_val.tt_ as i32 & 0xf as i32 == 0) {
            if (*n).u.key_tt as i32 == 3 as i32 | (0) << 4 as i32 {
                ause += countint((*n).u.key_val.i, nums);
            }
            totaluse += 1;
            totaluse;
        }
    }
    *pna = (*pna).wrapping_add(ause as u32);
    return totaluse;
}
unsafe extern "C-unwind" fn setnodevector(mut L: *mut lua_State, mut t: *mut Table, mut size: u32) {
    if size == 0 as u32 {
        (*t).node = &raw const dummynode_ as *const Node as *mut Node;
        (*t).lsizenode = 0 as lu_byte;
        (*t).lastfree = 0 as *mut Node;
    } else {
        let mut i: i32 = 0;
        let mut lsize: i32 = luaO_ceillog2(size);
        if lsize
            > (::core::mem::size_of::<i32>() as usize)
                .wrapping_mul(8)
                .wrapping_sub(1) as i32
                - 1 as i32
            || (1 as u32) << lsize
                > (if ((1 as u32)
                    << (::core::mem::size_of::<i32>() as usize)
                        .wrapping_mul(8)
                        .wrapping_sub(1) as i32
                        - 1 as i32) as size_t
                    <= (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Node>() as usize)
                {
                    (1 as u32)
                        << (::core::mem::size_of::<i32>() as usize)
                            .wrapping_mul(8)
                            .wrapping_sub(1) as i32
                            - 1 as i32
                } else {
                    (!(0 as size_t)).wrapping_div(::core::mem::size_of::<Node>() as usize) as u32
                })
        {
            luaG_runerror(L, c"table overflow".as_ptr());
        }
        size = ((1 as i32) << lsize) as u32;
        (*t).node = luaM_malloc_(
            L,
            (size as usize).wrapping_mul(::core::mem::size_of::<Node>() as usize),
            0,
        ) as *mut Node;
        i = 0;
        while i < size as i32 {
            let mut n: *mut Node = &mut *((*t).node).offset(i as isize) as *mut Node;
            (*n).u.next = 0;
            (*n).u.key_tt = 0 as lu_byte;
            (*n).i_val.tt_ = (0 | (1 as i32) << 4 as i32) as lu_byte;
            i += 1;
            i;
        }
        (*t).lsizenode = lsize as lu_byte;
        (*t).lastfree = &mut *((*t).node).offset(size as isize) as *mut Node;
    };
}
unsafe extern "C-unwind" fn reinsert(mut L: *mut lua_State, mut ot: *mut Table, mut t: *mut Table) {
    let mut j: i32 = 0;
    let mut size: i32 = (1 as i32) << (*ot).lsizenode as i32;
    j = 0;
    while j < size {
        let mut old: *mut Node = &mut *((*ot).node).offset(j as isize) as *mut Node;
        if !((*old).i_val.tt_ as i32 & 0xf as i32 == 0) {
            let mut k: TValue = TValue {
                value_: Value {
                    gc: 0 as *mut GCObject,
                },
                tt_: 0,
            };
            let mut io_: *mut TValue = &mut k;
            let mut n_: *const Node = old;
            (*io_).value_ = (*n_).u.key_val;
            (*io_).tt_ = (*n_).u.key_tt;
            if (*io_).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io_).tt_ as i32 & 0x3f as i32 == (*(*io_).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io_).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            luaH_set(L, t, &mut k, &mut (*old).i_val);
        }
        j += 1;
        j;
    }
}
unsafe extern "C-unwind" fn exchangehashpart(mut t1: *mut Table, mut t2: *mut Table) {
    let mut lsizenode: lu_byte = (*t1).lsizenode;
    let mut node: *mut Node = (*t1).node;
    let mut lastfree: *mut Node = (*t1).lastfree;
    (*t1).lsizenode = (*t2).lsizenode;
    (*t1).node = (*t2).node;
    (*t1).lastfree = (*t2).lastfree;
    (*t2).lsizenode = lsizenode;
    (*t2).node = node;
    (*t2).lastfree = lastfree;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_resize(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut newasize: u32,
    mut nhsize: u32,
) {
    let mut i: u32 = 0;
    let mut newt: Table = Table {
        next: 0 as *mut GCObject,
        tt: 0,
        marked: 0,
        flags: 0,
        lsizenode: 0,
        alimit: 0,
        array: 0 as *mut TValue,
        node: 0 as *mut Node,
        lastfree: 0 as *mut Node,
        metatable: 0 as *mut Table,
        gclist: 0 as *mut GCObject,
    };
    let mut oldasize: u32 = setlimittosize(t);
    let mut newarray: *mut TValue = 0 as *mut TValue;
    setnodevector(L, &mut newt, nhsize);
    if newasize < oldasize {
        (*t).alimit = newasize;
        exchangehashpart(t, &mut newt);
        i = newasize;
        while i < oldasize {
            if !((*((*t).array).offset(i as isize)).tt_ as i32 & 0xf as i32 == 0) {
                luaH_setint(
                    L,
                    t,
                    i.wrapping_add(1) as lua_Integer,
                    &mut *((*t).array).offset(i as isize),
                );
            }
            i = i.wrapping_add(1);
            i;
        }
        (*t).alimit = oldasize;
        exchangehashpart(t, &mut newt);
    }
    newarray = luaM_realloc_(
        L,
        (*t).array as *mut c_void,
        (oldasize as size_t).wrapping_mul(::core::mem::size_of::<TValue>() as usize),
        (newasize as size_t).wrapping_mul(::core::mem::size_of::<TValue>() as usize),
    ) as *mut TValue;
    if ((newarray.is_null() && newasize > 0 as u32) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        freehash(L, &mut newt);
        luaD_throw(L, 4 as i32);
    }
    exchangehashpart(t, &mut newt);
    (*t).array = newarray;
    (*t).alimit = newasize;
    i = oldasize;
    while i < newasize {
        (*((*t).array).offset(i as isize)).tt_ = (0 | (1 as i32) << 4 as i32) as lu_byte;
        i = i.wrapping_add(1);
        i;
    }
    reinsert(L, &mut newt, t);
    freehash(L, &mut newt);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_resizearray(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut nasize: u32,
) {
    let mut nsize: i32 = if ((*t).lastfree).is_null() {
        0
    } else {
        (1 as i32) << (*t).lsizenode as i32
    };
    luaH_resize(L, t, nasize, nsize as u32);
}
unsafe extern "C-unwind" fn rehash(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut ek: *const TValue,
) {
    let mut asize: u32 = 0;
    let mut na: u32 = 0;
    let mut nums: [u32; 32] = [0; 32];
    let mut i: i32 = 0;
    let mut totaluse: i32 = 0;
    i = 0;
    while i
        <= (::core::mem::size_of::<i32>() as usize)
            .wrapping_mul(8)
            .wrapping_sub(1) as i32
    {
        nums[i as usize] = 0 as u32;
        i += 1;
        i;
    }
    setlimittosize(t);
    na = numusearray(t, nums.as_mut_ptr());
    totaluse = na as i32;
    totaluse += numusehash(t, nums.as_mut_ptr(), &mut na);
    if (*ek).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        na = na.wrapping_add(countint((*ek).value_.i, nums.as_mut_ptr()) as u32);
    }
    totaluse += 1;
    totaluse;
    asize = computesizes(nums.as_mut_ptr(), &mut na);
    luaH_resize(L, t, asize, (totaluse as u32).wrapping_sub(na));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_new(mut L: *mut lua_State) -> *mut Table {
    let mut o: *mut GCObject = luaC_newobj(
        L,
        5 as i32 | (0) << 4 as i32,
        ::core::mem::size_of::<Table>() as usize,
    );
    let mut t: *mut Table = &mut (*(o as *mut GCUnion)).h;
    (*t).metatable = 0 as *mut Table;
    (*t).flags = !(!(0 as u32) << TM_EQ as i32 + 1 as i32) as lu_byte;
    (*t).array = 0 as *mut TValue;
    (*t).alimit = 0 as u32;
    setnodevector(L, t, 0 as u32);
    return t;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_free(mut L: *mut lua_State, mut t: *mut Table) {
    freehash(L, t);
    luaM_free_(
        L,
        (*t).array as *mut c_void,
        (luaH_realasize(t) as usize).wrapping_mul(::core::mem::size_of::<TValue>() as usize),
    );
    luaM_free_(
        L,
        t as *mut c_void,
        ::core::mem::size_of::<Table>() as usize,
    );
}
unsafe extern "C-unwind" fn getfreepos(mut t: *mut Table) -> *mut Node {
    if !((*t).lastfree).is_null() {
        while (*t).lastfree > (*t).node {
            (*t).lastfree = ((*t).lastfree).offset(-1);
            (*t).lastfree;
            if (*(*t).lastfree).u.key_tt as i32 == 0 {
                return (*t).lastfree;
            }
        }
    }
    return 0 as *mut Node;
}
unsafe extern "C-unwind" fn luaH_newkey(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut key: *const TValue,
    mut value: *mut TValue,
) {
    let mut mp: *mut Node = 0 as *mut Node;
    let mut aux: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    if (((*key).tt_ as i32 & 0xf as i32 == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaG_runerror(L, c"table index is nil".as_ptr());
    } else if (*key).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
        let mut f: lua_Number = (*key).value_.n;
        let mut k: lua_Integer = 0;
        if luaV_flttointeger(f, &mut k, F2Ieq) != 0 {
            let mut io: *mut TValue = &mut aux;
            (*io).value_.i = k;
            (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
            key = &mut aux;
        } else if (!(f == f) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            luaG_runerror(L, c"table index is NaN".as_ptr());
        }
    }
    if (*value).tt_ as i32 & 0xf as i32 == 0 {
        return;
    }
    mp = mainpositionTV(t, key);
    if !((*mp).i_val.tt_ as i32 & 0xf as i32 == 0) || ((*t).lastfree).is_null() {
        let mut othern: *mut Node = 0 as *mut Node;
        let mut f_0: *mut Node = getfreepos(t);
        if f_0.is_null() {
            rehash(L, t, key);
            luaH_set(L, t, key, value);
            return;
        }
        othern = mainpositionfromnode(t, mp);
        if othern != mp {
            while othern.offset((*othern).u.next as isize) != mp {
                othern = othern.offset((*othern).u.next as isize);
            }
            (*othern).u.next = f_0.offset_from(othern) as std::ffi::c_long as i32;
            *f_0 = *mp;
            if (*mp).u.next != 0 {
                (*f_0).u.next += mp.offset_from(f_0) as std::ffi::c_long as i32;
                (*mp).u.next = 0;
            }
            (*mp).i_val.tt_ = (0 | (1 as i32) << 4 as i32) as lu_byte;
        } else {
            if (*mp).u.next != 0 {
                (*f_0).u.next =
                    mp.offset((*mp).u.next as isize).offset_from(f_0) as std::ffi::c_long as i32;
            }
            (*mp).u.next = f_0.offset_from(mp) as std::ffi::c_long as i32;
            mp = f_0;
        }
    }
    let mut n_: *mut Node = mp;
    let mut io_: *const TValue = key;
    (*n_).u.key_val = (*io_).value_;
    (*n_).u.key_tt = (*io_).tt_;
    if (*io_).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io_).tt_ as i32 & 0x3f as i32 == (*(*io_).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io_).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    if (*key).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
        if (*(&mut (*(t as *mut GCUnion)).gc as *mut GCObject)).marked as i32
            & (1 as i32) << 5 as i32
            != 0
            && (*(*key).value_.gc).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            luaC_barrierback_(L, &mut (*(t as *mut GCUnion)).gc);
        } else {
        };
    } else {
    };
    let mut io1: *mut TValue = &mut (*mp).i_val;
    let mut io2: *const TValue = value;
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_getint(
    mut t: *mut Table,
    mut key: lua_Integer,
) -> *const TValue {
    let mut alimit: lua_Unsigned = (*t).alimit as lua_Unsigned;
    if (key as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned) < alimit {
        return &mut *((*t).array).offset((key - 1 as i32 as lua_Integer) as isize) as *mut TValue;
    } else if (*t).flags as i32 & (1 as i32) << 7 as i32 != 0
        && (key as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned)
            & !alimit.wrapping_sub(1 as u32 as lua_Unsigned)
            < alimit
    {
        (*t).alimit = key as u32;
        return &mut *((*t).array).offset((key - 1 as i32 as lua_Integer) as isize) as *mut TValue;
    } else {
        let mut n: *mut Node = hashint(t, key);
        loop {
            if (*n).u.key_tt as i32 == 3 as i32 | (0) << 4 as i32 && (*n).u.key_val.i == key {
                return &mut (*n).i_val;
            } else {
                let mut nx: i32 = (*n).u.next;
                if nx == 0 {
                    break;
                }
                n = n.offset(nx as isize);
            }
        }
        return &raw const absentkey;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_getshortstr(
    mut t: *mut Table,
    mut key: *mut TString,
) -> *const TValue {
    let mut n: *mut Node = &mut *((*t).node).offset(
        ((*key).hash & (((1 as i32) << (*t).lsizenode as i32) - 1 as i32) as u32) as i32 as isize,
    ) as *mut Node;
    loop {
        if (*n).u.key_tt as i32 == 4 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32
            && &mut (*((*n).u.key_val.gc as *mut GCUnion)).ts as *mut TString == key
        {
            return &mut (*n).i_val;
        } else {
            let mut nx: i32 = (*n).u.next;
            if nx == 0 {
                return &raw const absentkey;
            }
            n = n.offset(nx as isize);
        }
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_getstr(
    mut t: *mut Table,
    mut key: *mut TString,
) -> *const TValue {
    if (*key).tt as i32 == 4 as i32 | (0) << 4 as i32 {
        return luaH_getshortstr(t, key);
    } else {
        let mut ko: TValue = TValue {
            value_: Value {
                gc: 0 as *mut GCObject,
            },
            tt_: 0,
        };
        let mut io: *mut TValue = &mut ko;
        let mut x_: *mut TString = key;
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && ((0 as *mut c_void as *mut lua_State).is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*(0 as *mut c_void as *mut lua_State)).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        return getgeneric(t, &mut ko, 0);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_get(
    mut t: *mut Table,
    mut key: *const TValue,
) -> *const TValue {
    match (*key).tt_ as i32 & 0x3f as i32 {
        4 => return luaH_getshortstr(t, &mut (*((*key).value_.gc as *mut GCUnion)).ts),
        3 => return luaH_getint(t, (*key).value_.i),
        0 => return &raw const absentkey,
        19 => {
            let mut k: lua_Integer = 0;
            if luaV_flttointeger((*key).value_.n, &mut k, F2Ieq) != 0 {
                return luaH_getint(t, k);
            }
        }
        _ => {}
    }
    return getgeneric(t, key, 0);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_finishset(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut key: *const TValue,
    mut slot: *const TValue,
    mut value: *mut TValue,
) {
    if (*slot).tt_ as i32 == 0 | (2 as i32) << 4 as i32 {
        luaH_newkey(L, t, key, value);
    } else {
        let mut io1: *mut TValue = slot as *mut TValue;
        let mut io2: *const TValue = value;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_set(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut key: *const TValue,
    mut value: *mut TValue,
) {
    let mut slot: *const TValue = luaH_get(t, key);
    luaH_finishset(L, t, key, slot, value);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_setint(
    mut L: *mut lua_State,
    mut t: *mut Table,
    mut key: lua_Integer,
    mut value: *mut TValue,
) {
    let mut p: *const TValue = luaH_getint(t, key);
    if (*p).tt_ as i32 == 0 | (2 as i32) << 4 as i32 {
        let mut k: TValue = TValue {
            value_: Value {
                gc: 0 as *mut GCObject,
            },
            tt_: 0,
        };
        let mut io: *mut TValue = &mut k;
        (*io).value_.i = key;
        (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
        luaH_newkey(L, t, &mut k, value);
    } else {
        let mut io1: *mut TValue = p as *mut TValue;
        let mut io2: *const TValue = value;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
    };
}
unsafe extern "C-unwind" fn hash_search(mut t: *mut Table, mut j: lua_Unsigned) -> lua_Unsigned {
    let mut i: lua_Unsigned = 0;
    if j == 0 as lua_Unsigned {
        j = j.wrapping_add(1);
        j;
    }
    loop {
        i = j;
        if j <= 9223372036854775807 as std::ffi::c_longlong as lua_Unsigned
            / 2 as i32 as lua_Unsigned
        {
            j = j * 2 as i32 as lua_Unsigned;
            if (*luaH_getint(t, j as lua_Integer)).tt_ as i32 & 0xf as i32 == 0 {
                break;
            }
        } else {
            j = 9223372036854775807 as std::ffi::c_longlong as lua_Unsigned;
            if (*luaH_getint(t, j as lua_Integer)).tt_ as i32 & 0xf as i32 == 0 {
                break;
            }
            return j;
        }
    }
    while j.wrapping_sub(i) > 1 as u32 as lua_Unsigned {
        let mut m: lua_Unsigned = i.wrapping_add(j) / 2 as i32 as lua_Unsigned;
        if (*luaH_getint(t, m as lua_Integer)).tt_ as i32 & 0xf as i32 == 0 {
            j = m;
        } else {
            i = m;
        }
    }
    return i;
}
unsafe extern "C-unwind" fn binsearch(mut array: *const TValue, mut i: u32, mut j: u32) -> u32 {
    while j.wrapping_sub(i) > 1 as u32 {
        let mut m: u32 = i.wrapping_add(j).wrapping_div(2);
        if (*array.offset(m.wrapping_sub(1) as isize)).tt_ as i32 & 0xf as i32 == 0 {
            j = m;
        } else {
            i = m;
        }
    }
    return i;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaH_getn(mut t: *mut Table) -> lua_Unsigned {
    let mut limit: u32 = (*t).alimit;
    if limit > 0 as u32
        && (*((*t).array).offset(limit.wrapping_sub(1) as isize)).tt_ as i32 & 0xf as i32 == 0
    {
        if limit >= 2
            && !((*((*t).array).offset(limit.wrapping_sub(2) as isize)).tt_ as i32 & 0xf as i32
                == 0)
        {
            if ispow2realasize(t) != 0
                && !(limit.wrapping_sub(1) & limit.wrapping_sub(1).wrapping_sub(1) == 0 as u32)
            {
                (*t).alimit = limit.wrapping_sub(1);
                (*t).flags = ((*t).flags as i32 | (1 as i32) << 7 as i32) as lu_byte;
            }
            return limit.wrapping_sub(1) as lua_Unsigned;
        } else {
            let mut boundary: u32 = binsearch((*t).array, 0 as u32, limit);
            if ispow2realasize(t) != 0 && boundary > (luaH_realasize(t)).wrapping_div(2) {
                (*t).alimit = boundary;
                (*t).flags = ((*t).flags as i32 | (1 as i32) << 7 as i32) as lu_byte;
            }
            return boundary as lua_Unsigned;
        }
    }
    if !((*t).flags as i32 & (1 as i32) << 7 as i32 == 0
        || (*t).alimit & ((*t).alimit).wrapping_sub(1) == 0 as u32)
    {
        if (*((*t).array).offset(limit as isize)).tt_ as i32 & 0xf as i32 == 0 {
            return limit as lua_Unsigned;
        }
        limit = luaH_realasize(t);
        if (*((*t).array).offset(limit.wrapping_sub(1) as isize)).tt_ as i32 & 0xf as i32 == 0 {
            let mut boundary_0: u32 = binsearch((*t).array, (*t).alimit, limit);
            (*t).alimit = boundary_0;
            return boundary_0 as lua_Unsigned;
        }
    }
    if ((*t).lastfree).is_null()
        || (*luaH_getint(t, limit.wrapping_add(1) as lua_Integer)).tt_ as i32 & 0xf as i32 == 0
    {
        return limit as lua_Unsigned;
    } else {
        return hash_search(t, limit as lua_Unsigned);
    };
}

unsafe extern "C-unwind" fn l_strton(mut obj: *const TValue, mut result: *mut TValue) -> i32 {
    if !((*obj).tt_ as i32 & 0xf as i32 == 4 as i32) {
        return 0;
    } else {
        let mut st: *mut TString = &mut (*((*obj).value_.gc as *mut GCUnion)).ts;
        return (luaO_str2num(((*st).contents).as_mut_ptr(), result)
            == (if (*st).shrlen as i32 != 0xff as i32 {
                (*st).shrlen as size_t
            } else {
                (*st).u.lnglen
            })
            .wrapping_add(1 as i32 as size_t)) as i32;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_tonumber_(
    mut obj: *const TValue,
    mut n: *mut lua_Number,
) -> i32 {
    let mut v: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    if (*obj).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        *n = (*obj).value_.i as lua_Number;
        return 1 as i32;
    } else if l_strton(obj, &mut v) != 0 {
        *n = (if v.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
            v.value_.i as lua_Number
        } else {
            v.value_.n
        });
        return 1 as i32;
    } else {
        return 0;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_flttointeger(
    mut n: lua_Number,
    mut p: *mut lua_Integer,
    mut mode: F2Imod,
) -> i32 {
    let mut f: lua_Number = n.floor();
    if n != f {
        if mode as u32 == F2Ieq as i32 as u32 {
            return 0;
        } else if mode as u32 == F2Iceil as i32 as u32 {
            f += 1 as i32 as lua_Number;
        }
    }
    return (f
        >= (-(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong)
            as std::ffi::c_double
        && f < -((-(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong)
            as std::ffi::c_double)
        && {
            *p = f as std::ffi::c_longlong;
            1 as i32 != 0
        }) as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_tointegerns(
    mut obj: *const TValue,
    mut p: *mut lua_Integer,
    mut mode: F2Imod,
) -> i32 {
    if (*obj).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
        return luaV_flttointeger((*obj).value_.n, p, mode);
    } else if (*obj).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        *p = (*obj).value_.i;
        return 1 as i32;
    } else {
        return 0;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_tointeger(
    mut obj: *const TValue,
    mut p: *mut lua_Integer,
    mut mode: F2Imod,
) -> i32 {
    let mut v: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    if l_strton(obj, &mut v) != 0 {
        obj = &mut v;
    }
    return luaV_tointegerns(obj, p, mode);
}
unsafe extern "C-unwind" fn forlimit(
    mut L: *mut lua_State,
    mut init: lua_Integer,
    mut lim: *const TValue,
    mut p: *mut lua_Integer,
    mut step: lua_Integer,
) -> i32 {
    if luaV_tointeger(
        lim,
        p,
        (if step < 0 as lua_Integer {
            F2Iceil as i32
        } else {
            F2Ifloor as i32
        }) as F2Imod,
    ) == 0
    {
        let mut flim: lua_Number = 0.;
        if if (*lim).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
            flim = (*lim).value_.n;
            1 as i32
        } else {
            luaV_tonumber_(lim, &mut flim)
        } == 0
        {
            luaG_forerror(L, lim, c"limit".as_ptr());
        }
        if (0 as lua_Number) < flim {
            if step < 0 as lua_Integer {
                return 1 as i32;
            }
            *p = 9223372036854775807 as std::ffi::c_longlong;
        } else {
            if step > 0 as lua_Integer {
                return 1 as i32;
            }
            *p = -(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong;
        }
    }
    return if step > 0 as lua_Integer {
        (init > *p) as i32
    } else {
        (init < *p) as i32
    };
}
unsafe extern "C-unwind" fn forprep(mut L: *mut lua_State, mut ra: StkId) -> i32 {
    let mut pinit: *mut TValue = &mut (*ra).val;
    let mut plimit: *mut TValue = &mut (*ra.offset(1)).val;
    let mut pstep: *mut TValue = &mut (*ra.offset(2)).val;
    if (*pinit).tt_ as i32 == 3 as i32 | (0) << 4 as i32
        && (*pstep).tt_ as i32 == 3 as i32 | (0) << 4 as i32
    {
        let mut init: lua_Integer = (*pinit).value_.i;
        let mut step: lua_Integer = (*pstep).value_.i;
        let mut limit: lua_Integer = 0;
        if step == 0 as lua_Integer {
            luaG_runerror(L, c"'for' step is zero".as_ptr());
        }
        let mut io: *mut TValue = &mut (*ra.offset(3)).val;
        (*io).value_.i = init;
        (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
        if forlimit(L, init, plimit, &mut limit, step) != 0 {
            return 1 as i32;
        } else {
            let mut count: lua_Unsigned = 0;
            if step > 0 as lua_Integer {
                count = (limit as lua_Unsigned).wrapping_sub(init as lua_Unsigned);
                if step != 1 as i32 as lua_Integer {
                    count = count / step as lua_Unsigned;
                }
            } else {
                count = (init as lua_Unsigned).wrapping_sub(limit as lua_Unsigned);
                count = count
                    / (-(step + 1 as i32 as lua_Integer) as lua_Unsigned)
                        .wrapping_add(1 as u32 as lua_Unsigned);
            }
            let mut io_0: *mut TValue = plimit;
            (*io_0).value_.i = count as lua_Integer;
            (*io_0).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
        }
    } else {
        let mut init_0: lua_Number = 0.;
        let mut limit_0: lua_Number = 0.;
        let mut step_0: lua_Number = 0.;
        if (((if (*plimit).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
            limit_0 = (*plimit).value_.n;
            1 as i32
        } else {
            luaV_tonumber_(plimit, &mut limit_0)
        }) == 0) as i32
            != 0) as i32 as std::ffi::c_long
            != 0
        {
            luaG_forerror(L, plimit, c"limit".as_ptr());
        }
        if (((if (*pstep).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
            step_0 = (*pstep).value_.n;
            1 as i32
        } else {
            luaV_tonumber_(pstep, &mut step_0)
        }) == 0) as i32
            != 0) as i32 as std::ffi::c_long
            != 0
        {
            luaG_forerror(L, pstep, c"step".as_ptr());
        }
        if (((if (*pinit).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
            init_0 = (*pinit).value_.n;
            1 as i32
        } else {
            luaV_tonumber_(pinit, &mut init_0)
        }) == 0) as i32
            != 0) as i32 as std::ffi::c_long
            != 0
        {
            luaG_forerror(L, pinit, c"initial value".as_ptr());
        }
        if step_0 == 0 as lua_Number {
            luaG_runerror(L, c"'for' step is zero".as_ptr());
        }
        if if (0 as lua_Number) < step_0 {
            (limit_0 < init_0) as i32
        } else {
            (init_0 < limit_0) as i32
        } != 0
        {
            return 1 as i32;
        } else {
            let mut io_1: *mut TValue = plimit;
            (*io_1).value_.n = limit_0;
            (*io_1).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            let mut io_2: *mut TValue = pstep;
            (*io_2).value_.n = step_0;
            (*io_2).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            let mut io_3: *mut TValue = &mut (*ra).val;
            (*io_3).value_.n = init_0;
            (*io_3).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
            let mut io_4: *mut TValue = &mut (*ra.offset(3)).val;
            (*io_4).value_.n = init_0;
            (*io_4).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
        }
    }
    return 0;
}
unsafe extern "C-unwind" fn floatforloop(mut ra: StkId) -> i32 {
    let mut step: lua_Number = (*ra.offset(2)).val.value_.n;
    let mut limit: lua_Number = (*ra.offset(1)).val.value_.n;
    let mut idx: lua_Number = (*ra).val.value_.n;
    idx = idx + step;
    if if (0 as lua_Number) < step {
        (idx <= limit) as i32
    } else {
        (limit <= idx) as i32
    } != 0
    {
        let mut io: *mut TValue = &mut (*ra).val;
        (*io).value_.n = idx;
        let mut io_0: *mut TValue = &mut (*ra.offset(3)).val;
        (*io_0).value_.n = idx;
        (*io_0).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
        return 1 as i32;
    } else {
        return 0;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_finishget(
    mut L: *mut lua_State,
    mut t: *const TValue,
    mut key: *mut TValue,
    mut val: StkId,
    mut slot: *const TValue,
) {
    let mut loop_0: i32 = 0;
    let mut tm: *const TValue = 0 as *const TValue;
    loop_0 = 0;
    while loop_0 < 2000 {
        if slot.is_null() {
            tm = luaT_gettmbyobj(L, t, TM_INDEX);
            if (((*tm).tt_ as i32 & 0xf as i32 == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                luaG_typeerror(L, t, c"index".as_ptr());
            }
        } else {
            tm = if ((*(&mut (*((*t).value_.gc as *mut GCUnion)).h as *mut Table)).metatable)
                .is_null()
            {
                0 as *const TValue
            } else if (*(*(&mut (*((*t).value_.gc as *mut GCUnion)).h as *mut Table)).metatable)
                .flags as u32
                & (1 as u32) << TM_INDEX as i32
                != 0
            {
                0 as *const TValue
            } else {
                luaT_gettm(
                    (*&mut (*((*t).value_.gc as *mut GCUnion)).h).metatable,
                    TM_INDEX,
                    (*(*L).l_G).tmname[TM_INDEX as i32 as usize],
                )
            };
            if tm.is_null() {
                (*val).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
                return;
            }
        }
        if (*tm).tt_ as i32 & 0xf as i32 == 6 as i32 {
            luaT_callTMres(L, tm, t, key, val);
            return;
        }
        t = tm;
        if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
            slot = 0 as *const TValue;
            0
        } else {
            slot = luaH_get(&mut (*((*t).value_.gc as *mut GCUnion)).h, key);
            !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
        } != 0
        {
            let mut io1: *mut TValue = &mut (*val).val;
            let mut io2: *const TValue = slot;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            return;
        }
        loop_0 += 1;
        loop_0;
    }
    luaG_runerror(L, c"'__index' chain too long; possible loop".as_ptr());
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_finishset(
    mut L: *mut lua_State,
    mut t: *const TValue,
    mut key: *mut TValue,
    mut val: *mut TValue,
    mut slot: *const TValue,
) {
    let mut loop_0: i32 = 0;
    loop_0 = 0;
    while loop_0 < 2000 {
        let mut tm: *const TValue = 0 as *const TValue;
        if !slot.is_null() {
            let mut h: *mut Table = &mut (*((*t).value_.gc as *mut GCUnion)).h;
            tm = if ((*h).metatable).is_null() {
                0 as *const TValue
            } else if (*(*h).metatable).flags as u32 & (1 as u32) << TM_NEWINDEX as i32 != 0 {
                0 as *const TValue
            } else {
                luaT_gettm(
                    (*h).metatable,
                    TM_NEWINDEX,
                    (*(*L).l_G).tmname[TM_NEWINDEX as i32 as usize],
                )
            };
            if tm.is_null() {
                luaH_finishset(L, h, key, slot, val);
                (*h).flags =
                    ((*h).flags as u32 & !!(!(0 as u32) << TM_EQ as i32 + 1 as i32)) as lu_byte;
                if (*val).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                    if (*(&mut (*(h as *mut GCUnion)).gc as *mut GCObject)).marked as i32
                        & (1 as i32) << 5 as i32
                        != 0
                        && (*(*val).value_.gc).marked as i32
                            & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                            != 0
                    {
                        luaC_barrierback_(L, &mut (*(h as *mut GCUnion)).gc);
                    } else {
                    };
                } else {
                };
                return;
            }
        } else {
            tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);
            if (((*tm).tt_ as i32 & 0xf as i32 == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                luaG_typeerror(L, t, c"index".as_ptr());
            }
        }
        if (*tm).tt_ as i32 & 0xf as i32 == 6 as i32 {
            luaT_callTM(L, tm, t, key, val);
            return;
        }
        t = tm;
        if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
            slot = 0 as *const TValue;
            0
        } else {
            slot = luaH_get(&mut (*((*t).value_.gc as *mut GCUnion)).h, key);
            !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
        } != 0
        {
            let mut io1: *mut TValue = slot as *mut TValue;
            let mut io2: *const TValue = val;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            if (*val).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                if (*(*t).value_.gc).marked as i32 & (1 as i32) << 5 as i32 != 0
                    && (*(*val).value_.gc).marked as i32
                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                        != 0
                {
                    luaC_barrierback_(L, (*t).value_.gc);
                } else {
                };
            } else {
            };
            return;
        }
        loop_0 += 1;
        loop_0;
    }
    luaG_runerror(L, c"'__newindex' chain too long; possible loop".as_ptr());
}
unsafe extern "C-unwind" fn l_strcmp(mut ts1: *const TString, mut ts2: *const TString) -> i32 {
    let mut s1: *const std::ffi::c_char = ((*ts1).contents).as_ptr();
    let mut rl1: size_t = if (*ts1).shrlen as i32 != 0xff as i32 {
        (*ts1).shrlen as size_t
    } else {
        (*ts1).u.lnglen
    };
    let mut s2: *const std::ffi::c_char = ((*ts2).contents).as_ptr();
    let mut rl2: size_t = if (*ts2).shrlen as i32 != 0xff as i32 {
        (*ts2).shrlen as size_t
    } else {
        (*ts2).u.lnglen
    };
    loop {
        let mut temp: i32 = strcoll(s1, s2);
        if temp != 0 {
            return temp;
        } else {
            let mut zl1: size_t = strlen(s1);
            let mut zl2: size_t = strlen(s2);
            if zl2 == rl2 {
                return if zl1 == rl1 { 0 } else { 1 as i32 };
            } else if zl1 == rl1 {
                return -(1 as i32);
            }
            zl1 = zl1.wrapping_add(1);
            zl1;
            zl2 = zl2.wrapping_add(1);
            zl2;
            s1 = s1.offset(zl1 as isize);
            rl1 = rl1.wrapping_sub(zl1);
            s2 = s2.offset(zl2 as isize);
            rl2 = rl2.wrapping_sub(zl2);
        }
    }
}
#[inline]
unsafe extern "C-unwind" fn LTintfloat(mut i: lua_Integer, mut f: lua_Number) -> i32 {
    if ((1 as i32 as lua_Unsigned) << 53 as i32).wrapping_add(i as lua_Unsigned)
        <= 2 as i32 as lua_Unsigned * ((1 as i32 as lua_Unsigned) << 53 as i32)
    {
        return ((i as lua_Number) < f) as i32;
    } else {
        let mut fi: lua_Integer = 0;
        if luaV_flttointeger(f, &mut fi, F2Iceil) != 0 {
            return (i < fi) as i32;
        } else {
            return (f > 0 as lua_Number) as i32;
        }
    };
}
#[inline]
unsafe extern "C-unwind" fn LEintfloat(mut i: lua_Integer, mut f: lua_Number) -> i32 {
    if ((1 as i32 as lua_Unsigned) << 53 as i32).wrapping_add(i as lua_Unsigned)
        <= 2 as i32 as lua_Unsigned * ((1 as i32 as lua_Unsigned) << 53 as i32)
    {
        return (i as lua_Number <= f) as i32;
    } else {
        let mut fi: lua_Integer = 0;
        if luaV_flttointeger(f, &mut fi, F2Ifloor) != 0 {
            return (i <= fi) as i32;
        } else {
            return (f > 0 as lua_Number) as i32;
        }
    };
}
#[inline]
unsafe extern "C-unwind" fn LTfloatint(mut f: lua_Number, mut i: lua_Integer) -> i32 {
    if ((1 as i32 as lua_Unsigned) << 53 as i32).wrapping_add(i as lua_Unsigned)
        <= 2 as i32 as lua_Unsigned * ((1 as i32 as lua_Unsigned) << 53 as i32)
    {
        return (f < i as lua_Number) as i32;
    } else {
        let mut fi: lua_Integer = 0;
        if luaV_flttointeger(f, &mut fi, F2Ifloor) != 0 {
            return (fi < i) as i32;
        } else {
            return (f < 0 as lua_Number) as i32;
        }
    };
}
#[inline]
unsafe extern "C-unwind" fn LEfloatint(mut f: lua_Number, mut i: lua_Integer) -> i32 {
    if ((1 as i32 as lua_Unsigned) << 53 as i32).wrapping_add(i as lua_Unsigned)
        <= 2 as i32 as lua_Unsigned * ((1 as i32 as lua_Unsigned) << 53 as i32)
    {
        return (f <= i as lua_Number) as i32;
    } else {
        let mut fi: lua_Integer = 0;
        if luaV_flttointeger(f, &mut fi, F2Iceil) != 0 {
            return (fi <= i) as i32;
        } else {
            return (f < 0 as lua_Number) as i32;
        }
    };
}
#[inline]
unsafe extern "C-unwind" fn LTnum(mut l: *const TValue, mut r: *const TValue) -> i32 {
    if (*l).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        let mut li: lua_Integer = (*l).value_.i;
        if (*r).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
            return (li < (*r).value_.i) as i32;
        } else {
            return LTintfloat(li, (*r).value_.n);
        }
    } else {
        let mut lf: lua_Number = (*l).value_.n;
        if (*r).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
            return (lf < (*r).value_.n) as i32;
        } else {
            return LTfloatint(lf, (*r).value_.i);
        }
    };
}
#[inline]
unsafe extern "C-unwind" fn LEnum(mut l: *const TValue, mut r: *const TValue) -> i32 {
    if (*l).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
        let mut li: lua_Integer = (*l).value_.i;
        if (*r).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
            return (li <= (*r).value_.i) as i32;
        } else {
            return LEintfloat(li, (*r).value_.n);
        }
    } else {
        let mut lf: lua_Number = (*l).value_.n;
        if (*r).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
            return (lf <= (*r).value_.n) as i32;
        } else {
            return LEfloatint(lf, (*r).value_.i);
        }
    };
}
unsafe extern "C-unwind" fn lessthanothers(
    mut L: *mut lua_State,
    mut l: *const TValue,
    mut r: *const TValue,
) -> i32 {
    if (*l).tt_ as i32 & 0xf as i32 == 4 as i32 && (*r).tt_ as i32 & 0xf as i32 == 4 as i32 {
        return (l_strcmp(
            &mut (*((*l).value_.gc as *mut GCUnion)).ts,
            &mut (*((*r).value_.gc as *mut GCUnion)).ts,
        ) < 0) as i32;
    } else {
        return luaT_callorderTM(L, l, r, TM_LT);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_lessthan(
    mut L: *mut lua_State,
    mut l: *const TValue,
    mut r: *const TValue,
) -> i32 {
    if (*l).tt_ as i32 & 0xf as i32 == 3 as i32 && (*r).tt_ as i32 & 0xf as i32 == 3 as i32 {
        return LTnum(l, r);
    } else {
        return lessthanothers(L, l, r);
    };
}
unsafe extern "C-unwind" fn lessequalothers(
    mut L: *mut lua_State,
    mut l: *const TValue,
    mut r: *const TValue,
) -> i32 {
    if (*l).tt_ as i32 & 0xf as i32 == 4 as i32 && (*r).tt_ as i32 & 0xf as i32 == 4 as i32 {
        return (l_strcmp(
            &mut (*((*l).value_.gc as *mut GCUnion)).ts,
            &mut (*((*r).value_.gc as *mut GCUnion)).ts,
        ) <= 0) as i32;
    } else {
        return luaT_callorderTM(L, l, r, TM_LE);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_lessequal(
    mut L: *mut lua_State,
    mut l: *const TValue,
    mut r: *const TValue,
) -> i32 {
    if (*l).tt_ as i32 & 0xf as i32 == 3 as i32 && (*r).tt_ as i32 & 0xf as i32 == 3 as i32 {
        return LEnum(l, r);
    } else {
        return lessequalothers(L, l, r);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_equalobj(
    mut L: *mut lua_State,
    mut t1: *const TValue,
    mut t2: *const TValue,
) -> i32 {
    let mut tm: *const TValue = 0 as *const TValue;
    if (*t1).tt_ as i32 & 0x3f as i32 != (*t2).tt_ as i32 & 0x3f as i32 {
        if (*t1).tt_ as i32 & 0xf as i32 != (*t2).tt_ as i32 & 0xf as i32
            || (*t1).tt_ as i32 & 0xf as i32 != 3 as i32
        {
            return 0;
        } else {
            let mut i1: lua_Integer = 0;
            let mut i2: lua_Integer = 0;
            return (luaV_tointegerns(t1, &mut i1, F2Ieq) != 0
                && luaV_tointegerns(t2, &mut i2, F2Ieq) != 0
                && i1 == i2) as i32;
        }
    }
    match (*t1).tt_ as i32 & 0x3f as i32 {
        0 | 1 | 17 => return 1 as i32,
        3 => return ((*t1).value_.i == (*t2).value_.i) as i32,
        19 => return ((*t1).value_.n == (*t2).value_.n) as i32,
        2 => return ((*t1).value_.p == (*t2).value_.p) as i32,
        22 => return ((*t1).value_.f == (*t2).value_.f) as i32,
        4 => {
            return (&mut (*((*t1).value_.gc as *mut GCUnion)).ts as *mut TString
                == &mut (*((*t2).value_.gc as *mut GCUnion)).ts as *mut TString)
                as i32;
        }
        20 => {
            return luaS_eqlngstr(
                &mut (*((*t1).value_.gc as *mut GCUnion)).ts,
                &mut (*((*t2).value_.gc as *mut GCUnion)).ts,
            );
        }
        7 => {
            if &mut (*((*t1).value_.gc as *mut GCUnion)).u as *mut Udata
                == &mut (*((*t2).value_.gc as *mut GCUnion)).u as *mut Udata
            {
                return 1 as i32;
            } else if L.is_null() {
                return 0;
            }
            tm = if ((*(&mut (*((*t1).value_.gc as *mut GCUnion)).u as *mut Udata)).metatable)
                .is_null()
            {
                0 as *const TValue
            } else if (*(*(&mut (*((*t1).value_.gc as *mut GCUnion)).u as *mut Udata)).metatable)
                .flags as u32
                & (1 as u32) << TM_EQ as i32
                != 0
            {
                0 as *const TValue
            } else {
                luaT_gettm(
                    (*&mut (*((*t1).value_.gc as *mut GCUnion)).u).metatable,
                    TM_EQ,
                    (*(*L).l_G).tmname[TM_EQ as i32 as usize],
                )
            };
            if tm.is_null() {
                tm = if ((*(&mut (*((*t2).value_.gc as *mut GCUnion)).u as *mut Udata)).metatable)
                    .is_null()
                {
                    0 as *const TValue
                } else if (*(*(&mut (*((*t2).value_.gc as *mut GCUnion)).u as *mut Udata))
                    .metatable)
                    .flags as u32
                    & (1 as u32) << TM_EQ as i32
                    != 0
                {
                    0 as *const TValue
                } else {
                    luaT_gettm(
                        (*&mut (*((*t2).value_.gc as *mut GCUnion)).u).metatable,
                        TM_EQ,
                        (*(*L).l_G).tmname[TM_EQ as i32 as usize],
                    )
                };
            }
        }
        5 => {
            if &mut (*((*t1).value_.gc as *mut GCUnion)).h as *mut Table
                == &mut (*((*t2).value_.gc as *mut GCUnion)).h as *mut Table
            {
                return 1 as i32;
            } else if L.is_null() {
                return 0;
            }
            tm = if ((*(&mut (*((*t1).value_.gc as *mut GCUnion)).h as *mut Table)).metatable)
                .is_null()
            {
                0 as *const TValue
            } else if (*(*(&mut (*((*t1).value_.gc as *mut GCUnion)).h as *mut Table)).metatable)
                .flags as u32
                & (1 as u32) << TM_EQ as i32
                != 0
            {
                0 as *const TValue
            } else {
                luaT_gettm(
                    (*&mut (*((*t1).value_.gc as *mut GCUnion)).h).metatable,
                    TM_EQ,
                    (*(*L).l_G).tmname[TM_EQ as i32 as usize],
                )
            };
            if tm.is_null() {
                tm = if ((*(&mut (*((*t2).value_.gc as *mut GCUnion)).h as *mut Table)).metatable)
                    .is_null()
                {
                    0 as *const TValue
                } else if (*(*(&mut (*((*t2).value_.gc as *mut GCUnion)).h as *mut Table))
                    .metatable)
                    .flags as u32
                    & (1 as u32) << TM_EQ as i32
                    != 0
                {
                    0 as *const TValue
                } else {
                    luaT_gettm(
                        (*&mut (*((*t2).value_.gc as *mut GCUnion)).h).metatable,
                        TM_EQ,
                        (*(*L).l_G).tmname[TM_EQ as i32 as usize],
                    )
                };
            }
        }
        _ => return ((*t1).value_.gc == (*t2).value_.gc) as i32,
    }
    if tm.is_null() {
        return 0;
    } else {
        luaT_callTMres(L, tm, t1, t2, (*L).top.p);
        return !((*(*L).top.p).val.tt_ as i32 == 1 as i32 | (0) << 4 as i32
            || (*(*L).top.p).val.tt_ as i32 & 0xf as i32 == 0) as i32;
    };
}
unsafe extern "C-unwind" fn copy2buff(mut top: StkId, mut n: i32, mut buff: *mut std::ffi::c_char) {
    let mut tl: size_t = 0 as size_t;
    loop {
        let mut st: *mut TString =
            &mut (*((*top.offset(-(n as isize))).val.value_.gc as *mut GCUnion)).ts;
        let mut l: size_t = if (*st).shrlen as i32 != 0xff as i32 {
            (*st).shrlen as size_t
        } else {
            (*st).u.lnglen
        };
        memcpy(
            buff.offset(tl as isize) as *mut c_void,
            ((*st).contents).as_mut_ptr() as *const c_void,
            l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
        );
        tl = tl.wrapping_add(l);
        n -= 1;
        if !(n > 0) {
            break;
        }
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_concat(mut L: *mut lua_State, mut total: i32) {
    if total == 1 as i32 {
        return;
    }
    loop {
        let mut top: StkId = (*L).top.p;
        let mut n: i32 = 2 as i32;
        if !((*top.offset(-(2))).val.tt_ as i32 & 0xf as i32 == 4 as i32
            || (*top.offset(-(2))).val.tt_ as i32 & 0xf as i32 == 3 as i32)
            || !((*top.offset(-(1))).val.tt_ as i32 & 0xf as i32 == 4 as i32
                || (*top.offset(-(1))).val.tt_ as i32 & 0xf as i32 == 3 as i32 && {
                    luaO_tostring(L, &mut (*top.offset(-(1))).val);
                    1 as i32 != 0
                })
        {
            luaT_tryconcatTM(L);
        } else if (*top.offset(-(1))).val.tt_ as i32
            == 4 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32
            && (*(&mut (*((*top.offset(-(1))).val.value_.gc as *mut GCUnion)).ts as *mut TString))
                .shrlen as i32
                == 0
        {
            ((*top.offset(-(2))).val.tt_ as i32 & 0xf as i32 == 4 as i32
                || (*top.offset(-(2))).val.tt_ as i32 & 0xf as i32 == 3 as i32 && {
                    luaO_tostring(L, &mut (*top.offset(-(2))).val);
                    1 as i32 != 0
                }) as i32;
        } else if (*top.offset(-(2))).val.tt_ as i32
            == 4 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32
            && (*(&mut (*((*top.offset(-(2))).val.value_.gc as *mut GCUnion)).ts as *mut TString))
                .shrlen as i32
                == 0
        {
            let mut io1: *mut TValue = &mut (*top.offset(-(2))).val;
            let mut io2: *const TValue = &mut (*top.offset(-(1))).val;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
        } else {
            let mut tl: size_t = if (*(&mut (*((*top.offset(-(1))).val.value_.gc as *mut GCUnion))
                .ts as *mut TString))
                .shrlen as i32
                != 0xff as i32
            {
                (*&mut (*((*top.offset(-(1))).val.value_.gc as *mut GCUnion)).ts).shrlen as size_t
            } else {
                (*&mut (*((*top.offset(-(1))).val.value_.gc as *mut GCUnion)).ts)
                    .u
                    .lnglen
            };
            let mut ts: *mut TString = 0 as *mut TString;
            n = 1 as i32;
            while n < total
                && ((*top.offset(-(n as isize)).offset(-(1))).val.tt_ as i32 & 0xf as i32
                    == 4 as i32
                    || (*top.offset(-(n as isize)).offset(-(1))).val.tt_ as i32 & 0xf as i32
                        == 3 as i32
                        && {
                            luaO_tostring(L, &mut (*top.offset(-(n as isize)).offset(-(1))).val);
                            1 as i32 != 0
                        })
            {
                let mut l: size_t =
                    if (*(&mut (*((*top.offset(-(n as isize)).offset(-(1))).val.value_.gc
                        as *mut GCUnion))
                        .ts as *mut TString))
                        .shrlen as i32
                        != 0xff as i32
                    {
                        (*&mut (*((*top.offset(-(n as isize)).offset(-(1))).val.value_.gc
                            as *mut GCUnion))
                            .ts)
                            .shrlen as size_t
                    } else {
                        (*&mut (*((*top.offset(-(n as isize)).offset(-(1))).val.value_.gc
                            as *mut GCUnion))
                            .ts)
                            .u
                            .lnglen
                    };
                if ((l
                    >= (if (::core::mem::size_of::<size_t>() as usize)
                        < ::core::mem::size_of::<lua_Integer>() as usize
                    {
                        !(0 as size_t)
                    } else {
                        9223372036854775807 as std::ffi::c_longlong as size_t
                    })
                    .wrapping_sub(::core::mem::size_of::<TString>() as usize)
                    .wrapping_sub(tl)) as i32
                    != 0) as i32 as std::ffi::c_long
                    != 0
                {
                    (*L).top.p = top.offset(-(total as isize));
                    luaG_runerror(L, c"string length overflow".as_ptr());
                }
                tl = tl.wrapping_add(l);
                n += 1;
                n;
            }
            if tl <= 40 as size_t {
                let mut buff: [std::ffi::c_char; 40] = [0; 40];
                copy2buff(top, n, buff.as_mut_ptr());
                ts = luaS_newlstr(L, buff.as_mut_ptr(), tl);
            } else {
                ts = luaS_createlngstrobj(L, tl);
                copy2buff(top, n, ((*ts).contents).as_mut_ptr());
            }
            let mut io: *mut TValue = &mut (*top.offset(-(n as isize))).val;
            let mut x_: *mut TString = ts;
            (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
            (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
            if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
        }
        total -= n - 1 as i32;
        (*L).top.p = ((*L).top.p).offset(-((n - 1 as i32) as isize));
        if !(total > 1 as i32) {
            break;
        }
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_objlen(
    mut L: *mut lua_State,
    mut ra: StkId,
    mut rb: *const TValue,
) {
    let mut tm: *const TValue = 0 as *const TValue;
    match (*rb).tt_ as i32 & 0x3f as i32 {
        5 => {
            let mut h: *mut Table = &mut (*((*rb).value_.gc as *mut GCUnion)).h;
            tm = if ((*h).metatable).is_null() {
                0 as *const TValue
            } else if (*(*h).metatable).flags as u32 & (1 as u32) << TM_LEN as i32 != 0 {
                0 as *const TValue
            } else {
                luaT_gettm(
                    (*h).metatable,
                    TM_LEN,
                    (*(*L).l_G).tmname[TM_LEN as i32 as usize],
                )
            };
            if tm.is_null() {
                let mut io: *mut TValue = &mut (*ra).val;
                (*io).value_.i = luaH_getn(h) as lua_Integer;
                (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                return;
            }
        }
        4 => {
            let mut io_0: *mut TValue = &mut (*ra).val;
            (*io_0).value_.i =
                (*&mut (*((*rb).value_.gc as *mut GCUnion)).ts).shrlen as lua_Integer;
            (*io_0).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
            return;
        }
        20 => {
            let mut io_1: *mut TValue = &mut (*ra).val;
            (*io_1).value_.i =
                (*&mut (*((*rb).value_.gc as *mut GCUnion)).ts).u.lnglen as lua_Integer;
            (*io_1).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
            return;
        }
        _ => {
            tm = luaT_gettmbyobj(L, rb, TM_LEN);
            if (((*tm).tt_ as i32 & 0xf as i32 == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                luaG_typeerror(L, rb, c"get length of".as_ptr());
            }
        }
    }
    luaT_callTMres(L, tm, rb, rb, ra);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_idiv(
    mut L: *mut lua_State,
    mut m: lua_Integer,
    mut n: lua_Integer,
) -> lua_Integer {
    if (((n as lua_Unsigned).wrapping_add(1 as u32 as lua_Unsigned) <= 1 as u32 as lua_Unsigned)
        as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        if n == 0 as lua_Integer {
            luaG_runerror(L, c"attempt to divide by zero".as_ptr());
        }
        return (0 as lua_Unsigned).wrapping_sub(m as lua_Unsigned) as lua_Integer;
    } else {
        let mut q: lua_Integer = m / n;
        if m ^ n < 0 as lua_Integer && m % n != 0 as lua_Integer {
            q -= 1 as i32 as lua_Integer;
        }
        return q;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_mod(
    mut L: *mut lua_State,
    mut m: lua_Integer,
    mut n: lua_Integer,
) -> lua_Integer {
    if (((n as lua_Unsigned).wrapping_add(1 as u32 as lua_Unsigned) <= 1 as u32 as lua_Unsigned)
        as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        if n == 0 as lua_Integer {
            luaG_runerror(L, c"attempt to perform 'n%%0'".as_ptr());
        }
        return 0 as lua_Integer;
    } else {
        let mut r: lua_Integer = m % n;
        if r != 0 as lua_Integer && r ^ n < 0 as lua_Integer {
            r += n;
        }
        return r;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_modf(
    mut L: *mut lua_State,
    mut m: lua_Number,
    mut n: lua_Number,
) -> lua_Number {
    let mut r: lua_Number = 0.;
    r = fmod(m, n);
    if if r > 0 as lua_Number {
        (n < 0 as lua_Number) as i32
    } else {
        (r < 0 as lua_Number && n > 0 as lua_Number) as i32
    } != 0
    {
        r += n;
    }
    return r;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_shiftl(mut x: lua_Integer, mut y: lua_Integer) -> lua_Integer {
    if y < 0 as lua_Integer {
        if y <= -((::core::mem::size_of::<lua_Integer>() as usize).wrapping_mul(8) as i32)
            as lua_Integer
        {
            return 0 as lua_Integer;
        } else {
            return (x as lua_Unsigned >> -y as lua_Unsigned) as lua_Integer;
        }
    } else if y
        >= (::core::mem::size_of::<lua_Integer>() as usize).wrapping_mul(8) as i32 as lua_Integer
    {
        return 0 as lua_Integer;
    } else {
        return ((x as lua_Unsigned) << y as lua_Unsigned) as lua_Integer;
    };
}
unsafe extern "C-unwind" fn pushclosure(
    mut L: *mut lua_State,
    mut p: *mut Proto,
    mut encup: *mut *mut UpVal,
    mut base: StkId,
    mut ra: StkId,
) {
    let mut nup: i32 = (*p).sizeupvalues;
    let mut uv: *mut Upvaldesc = (*p).upvalues;
    let mut i: i32 = 0;
    let mut ncl: *mut LClosure = luaF_newLclosure(L, nup);
    (*ncl).p = p;
    let mut io: *mut TValue = &mut (*ra).val;
    let mut x_: *mut LClosure = ncl;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (6 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    i = 0;
    while i < nup {
        if (*uv.offset(i as isize)).instack != 0 {
            let ref mut fresh132 = *((*ncl).upvals).as_mut_ptr().offset(i as isize);
            *fresh132 =
                luaF_findupval(L, base.offset((*uv.offset(i as isize)).idx as i32 as isize));
        } else {
            let ref mut fresh133 = *((*ncl).upvals).as_mut_ptr().offset(i as isize);
            *fresh133 = *encup.offset((*uv.offset(i as isize)).idx as isize);
        }
        if (*ncl).marked as i32 & (1 as i32) << 5 as i32 != 0
            && (**((*ncl).upvals).as_mut_ptr().offset(i as isize)).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            luaC_barrier_(
                L,
                &mut (*(ncl as *mut GCUnion)).gc,
                &mut (*(*((*ncl).upvals).as_mut_ptr().offset(i as isize) as *mut GCUnion)).gc,
            );
        } else {
        };
        i += 1;
        i;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_finishOp(mut L: *mut lua_State) {
    let mut ci: *mut CallInfo = (*L).ci;
    let mut base: StkId = ((*ci).func.p).offset(1);
    let mut inst: Instruction = *((*ci).u.l.savedpc).offset(-(1));
    let mut op: OpCode = (inst >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode;
    match op as u32 {
        46 | 47 | 48 => {
            let mut io1: *mut TValue = &mut (*base.offset(
                (*((*ci).u.l.savedpc).offset(-(2)) >> 0 + 7 as i32
                    & !(!(0 as Instruction) << 8 as i32) << 0) as i32 as isize,
            ))
            .val;
            (*L).top.p = ((*L).top.p).offset(-1);
            let mut io2: *const TValue = &mut (*(*L).top.p).val;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
        }
        49 | 50 | 52 | 11 | 12 | 13 | 14 | 20 => {
            let mut io1_0: *mut TValue = &mut (*base.offset(
                (inst >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32 as isize,
            ))
            .val;
            (*L).top.p = ((*L).top.p).offset(-1);
            let mut io2_0: *const TValue = &mut (*(*L).top.p).val;
            (*io1_0).value_ = (*io2_0).value_;
            (*io1_0).tt_ = (*io2_0).tt_;
            if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1_0).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
        }
        58 | 59 | 62 | 63 | 64 | 65 | 57 => {
            let mut res: i32 = !((*((*L).top.p).offset(-(1))).val.tt_ as i32
                == 1 as i32 | (0) << 4 as i32
                || (*((*L).top.p).offset(-(1))).val.tt_ as i32 & 0xf as i32 == 0)
                as i32;
            (*L).top.p = ((*L).top.p).offset(-1);
            (*L).top.p;
            if res
                != (inst >> 0 + 7 as i32 + 8 as i32 & !(!(0 as Instruction) << 1 as i32) << 0)
                    as i32
            {
                (*ci).u.l.savedpc = ((*ci).u.l.savedpc).offset(1);
                (*ci).u.l.savedpc;
            }
        }
        53 => {
            let mut top: StkId = ((*L).top.p).offset(-(1));
            let mut a: i32 =
                (inst >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32;
            let mut total: i32 =
                top.offset(-(1)).offset_from(base.offset(a as isize)) as std::ffi::c_long as i32;
            let mut io1_1: *mut TValue = &mut (*top.offset(-(2))).val;
            let mut io2_1: *const TValue = &mut (*top).val;
            (*io1_1).value_ = (*io2_1).value_;
            (*io1_1).tt_ = (*io2_1).tt_;
            if (*io1_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1_1).tt_ as i32 & 0x3f as i32 == (*(*io1_1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1_1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            (*L).top.p = top.offset(-(1));
            luaV_concat(L, total);
        }
        54 => {
            (*ci).u.l.savedpc = ((*ci).u.l.savedpc).offset(-1);
            (*ci).u.l.savedpc;
        }
        70 => {
            let mut ra: StkId = base.offset(
                (inst >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32 as isize,
            );
            (*L).top.p = ra.offset((*ci).u2.nres as isize);
            (*ci).u.l.savedpc = ((*ci).u.l.savedpc).offset(-1);
            (*ci).u.l.savedpc;
        }
        _ => {}
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaV_execute(mut L: *mut lua_State, mut ci: *mut CallInfo) {
    let mut i: Instruction = 0;
    let mut ra_65: StkId = 0 as *mut StackValue;
    let mut newci: *mut CallInfo = 0 as *mut CallInfo;
    let mut b_4: i32 = 0;
    let mut nresults: i32 = 0;
    let mut current_block: u64;
    let mut cl: *mut LClosure = 0 as *mut LClosure;
    let mut k: *mut TValue = 0 as *mut TValue;
    let mut base: StkId = 0 as *mut StackValue;
    let mut pc: *const Instruction = 0 as *const Instruction;
    let mut trap: i32 = 0;
    '_startfunc: loop {
        trap = (*L).hookmask;
        '_returning: loop {
            cl = &mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.l;
            k = (*(*cl).p).k;
            pc = (*ci).u.l.savedpc;
            if (trap != 0) as i32 as std::ffi::c_long != 0 {
                trap = luaG_tracecall(L);
            }
            base = ((*ci).func.p).offset(1);
            loop {
                i = 0;
                if (trap != 0) as i32 as std::ffi::c_long != 0 {
                    trap = luaG_traceexec(L, pc);
                    base = ((*ci).func.p).offset(1);
                }
                let fresh134 = pc;
                pc = pc.offset(1);
                i = *fresh134;
                match (i >> 0 & !(!(0 as Instruction) << 7 as i32) << 0) as OpCode as u32 {
                    OP_MOVE => {
                        let mut ra: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut io1: *mut TValue = &mut (*ra).val;
                        let mut io2: *const TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        (*io1).value_ = (*io2).value_;
                        (*io1).tt_ = (*io2).tt_;
                        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                                && (L.is_null()
                                    || (*(*io1).value_.gc).marked as i32
                                        & ((*(*L).l_G).currentwhite as i32
                                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                        == 0)
                        {
                        } else {
                        };
                        continue;
                    }
                    OP_LOADI => {
                        let mut ra_0: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut b: lua_Integer = ((i >> 0 + 7 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32
                                >> 1 as i32))
                            as lua_Integer;
                        let mut io: *mut TValue = &mut (*ra_0).val;
                        (*io).value_.i = b;
                        (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        continue;
                    }
                    OP_LOADF => {
                        let mut ra_1: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut b_0: i32 = (i >> 0 + 7 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32) - 1 as i32
                                >> 1 as i32);
                        let mut io_0: *mut TValue = &mut (*ra_1).val;
                        (*io_0).value_.n = b_0 as lua_Number;
                        (*io_0).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        continue;
                    }
                    OP_LOADK => {
                        let mut ra_2: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut io1_0: *mut TValue = &mut (*ra_2).val;
                        let mut io2_0: *const TValue = rb;
                        (*io1_0).value_ = (*io2_0).value_;
                        (*io1_0).tt_ = (*io2_0).tt_;
                        if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                            || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
                                && (L.is_null()
                                    || (*(*io1_0).value_.gc).marked as i32
                                        & ((*(*L).l_G).currentwhite as i32
                                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                        == 0)
                        {
                        } else {
                        };
                        continue;
                    }
                    OP_LOADKX => {
                        let mut ra_3: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_0: *mut TValue = 0 as *mut TValue;
                        rb_0 = k.offset(
                            (*pc >> 0 + 7 as i32
                                & !(!(0 as Instruction)
                                    << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                    << 0) as i32 as isize,
                        );
                        pc = pc.offset(1);
                        pc;
                        let mut io1_1: *mut TValue = &mut (*ra_3).val;
                        let mut io2_1: *const TValue = rb_0;
                        (*io1_1).value_ = (*io2_1).value_;
                        (*io1_1).tt_ = (*io2_1).tt_;
                        if (*io1_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                            || (*io1_1).tt_ as i32 & 0x3f as i32 == (*(*io1_1).value_.gc).tt as i32
                                && (L.is_null()
                                    || (*(*io1_1).value_.gc).marked as i32
                                        & ((*(*L).l_G).currentwhite as i32
                                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                        == 0)
                        {
                        } else {
                        };
                        continue;
                    }
                    OP_LOADFALSE => {
                        let mut ra_4: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ra_4).val.tt_ = (1 as i32 | (0) << 4 as i32) as lu_byte;
                        continue;
                    }
                    OP_LFALSESKIP => {
                        let mut ra_5: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ra_5).val.tt_ = (1 as i32 | (0) << 4 as i32) as lu_byte;
                        pc = pc.offset(1);
                        pc;
                        continue;
                    }
                    OP_LOADTRUE => {
                        let mut ra_6: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ra_6).val.tt_ = (1 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        continue;
                    }
                    OP_LOADNIL => {
                        let mut ra_7: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut b_1: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        loop {
                            let fresh135 = ra_7;
                            ra_7 = ra_7.offset(1);
                            (*fresh135).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
                            let fresh136 = b_1;
                            b_1 = b_1 - 1;
                            if !(fresh136 != 0) {
                                break;
                            }
                        }
                        continue;
                    }
                    OP_GETUPVAL => {
                        let mut ra_8: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut b_2: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        let mut io1_2: *mut TValue = &mut (*ra_8).val;
                        let mut io2_2: *const TValue =
                            (**((*cl).upvals).as_mut_ptr().offset(b_2 as isize)).v.p;
                        (*io1_2).value_ = (*io2_2).value_;
                        (*io1_2).tt_ = (*io2_2).tt_;
                        if (*io1_2).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                            || (*io1_2).tt_ as i32 & 0x3f as i32 == (*(*io1_2).value_.gc).tt as i32
                                && (L.is_null()
                                    || (*(*io1_2).value_.gc).marked as i32
                                        & ((*(*L).l_G).currentwhite as i32
                                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                        == 0)
                        {
                        } else {
                        };
                        continue;
                    }
                    OP_SETUPVAL => {
                        let mut ra_9: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut uv: *mut UpVal = *((*cl).upvals).as_mut_ptr().offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut io1_3: *mut TValue = (*uv).v.p;
                        let mut io2_3: *const TValue = &mut (*ra_9).val;
                        (*io1_3).value_ = (*io2_3).value_;
                        (*io1_3).tt_ = (*io2_3).tt_;
                        if (*io1_3).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                            || (*io1_3).tt_ as i32 & 0x3f as i32 == (*(*io1_3).value_.gc).tt as i32
                                && (L.is_null()
                                    || (*(*io1_3).value_.gc).marked as i32
                                        & ((*(*L).l_G).currentwhite as i32
                                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                        == 0)
                        {
                        } else {
                        };
                        if (*ra_9).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                            if (*uv).marked as i32 & (1 as i32) << 5 as i32 != 0
                                && (*(*ra_9).val.value_.gc).marked as i32
                                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                                    != 0
                            {
                                luaC_barrier_(
                                    L,
                                    &mut (*(uv as *mut GCUnion)).gc,
                                    &mut (*((*ra_9).val.value_.gc as *mut GCUnion)).gc,
                                );
                            } else {
                            };
                        } else {
                        };
                        continue;
                    }
                    OP_GETTABUP => {
                        let mut ra_10: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot: *const TValue = 0 as *const TValue;
                        let mut upval: *mut TValue = (**((*cl).upvals).as_mut_ptr().offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .v
                        .p;
                        let mut rc: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut key: *mut TString = &mut (*((*rc).value_.gc as *mut GCUnion)).ts;
                        if if !((*upval).tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot = 0 as *const TValue;
                            0
                        } else {
                            slot = luaH_getshortstr(
                                &mut (*((*upval).value_.gc as *mut GCUnion)).h,
                                key,
                            );
                            !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_4: *mut TValue = &mut (*ra_10).val;
                            let mut io2_4: *const TValue = slot;
                            (*io1_4).value_ = (*io2_4).value_;
                            (*io1_4).tt_ = (*io2_4).tt_;
                            if (*io1_4).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_4).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_4).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_4).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishget(L, upval, rc, ra_10, slot);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_GETTABLE => {
                        let mut ra_11: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot_0: *const TValue = 0 as *const TValue;
                        let mut rb_1: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut rc_0: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut n: lua_Unsigned = 0;
                        if if (*rc_0).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            n = (*rc_0).value_.i as lua_Unsigned;
                            (if !((*rb_1).tt_ as i32
                                == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                            {
                                slot_0 = 0 as *const TValue;
                                0
                            } else {
                                slot_0 = (if n.wrapping_sub(1 as u32 as lua_Unsigned)
                                    < (*(&mut (*((*rb_1).value_.gc as *mut GCUnion)).h
                                        as *mut Table))
                                        .alimit
                                        as lua_Unsigned
                                {
                                    &mut *((*(&mut (*((*rb_1).value_.gc as *mut GCUnion)).h
                                        as *mut Table))
                                        .array)
                                        .offset(n.wrapping_sub(1 as i32 as lua_Unsigned) as isize)
                                        as *mut TValue
                                        as *const TValue
                                } else {
                                    luaH_getint(
                                        &mut (*((*rb_1).value_.gc as *mut GCUnion)).h,
                                        n as lua_Integer,
                                    )
                                });
                                !((*slot_0).tt_ as i32 & 0xf as i32 == 0) as i32
                            })
                        } else if !((*rb_1).tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_0 = 0 as *const TValue;
                            0
                        } else {
                            slot_0 = luaH_get(&mut (*((*rb_1).value_.gc as *mut GCUnion)).h, rc_0);
                            !((*slot_0).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_5: *mut TValue = &mut (*ra_11).val;
                            let mut io2_5: *const TValue = slot_0;
                            (*io1_5).value_ = (*io2_5).value_;
                            (*io1_5).tt_ = (*io2_5).tt_;
                            if (*io1_5).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_5).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_5).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_5).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishget(L, rb_1, rc_0, ra_11, slot_0);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_GETI => {
                        let mut ra_12: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot_1: *const TValue = 0 as *const TValue;
                        let mut rb_2: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut c: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        if if !((*rb_2).tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_1 = 0 as *const TValue;
                            0
                        } else {
                            slot_1 = (if (c as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned)
                                < (*(&mut (*((*rb_2).value_.gc as *mut GCUnion)).h as *mut Table))
                                    .alimit as lua_Unsigned
                            {
                                &mut *((*(&mut (*((*rb_2).value_.gc as *mut GCUnion)).h
                                    as *mut Table))
                                    .array)
                                    .offset((c - 1 as i32) as isize)
                                    as *mut TValue as *const TValue
                            } else {
                                luaH_getint(
                                    &mut (*((*rb_2).value_.gc as *mut GCUnion)).h,
                                    c as lua_Integer,
                                )
                            });
                            !((*slot_1).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_6: *mut TValue = &mut (*ra_12).val;
                            let mut io2_6: *const TValue = slot_1;
                            (*io1_6).value_ = (*io2_6).value_;
                            (*io1_6).tt_ = (*io2_6).tt_;
                            if (*io1_6).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_6).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_6).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_6).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                        } else {
                            let mut key_0: TValue = TValue {
                                value_: Value {
                                    gc: 0 as *mut GCObject,
                                },
                                tt_: 0,
                            };
                            let mut io_1: *mut TValue = &mut key_0;
                            (*io_1).value_.i = c as lua_Integer;
                            (*io_1).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishget(L, rb_2, &mut key_0, ra_12, slot_1);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_GETFIELD => {
                        let mut ra_13: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot_2: *const TValue = 0 as *const TValue;
                        let mut rb_3: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut rc_1: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut key_1: *mut TString =
                            &mut (*((*rc_1).value_.gc as *mut GCUnion)).ts;
                        if if !((*rb_3).tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_2 = 0 as *const TValue;
                            0
                        } else {
                            slot_2 = luaH_getshortstr(
                                &mut (*((*rb_3).value_.gc as *mut GCUnion)).h,
                                key_1,
                            );
                            !((*slot_2).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_7: *mut TValue = &mut (*ra_13).val;
                            let mut io2_7: *const TValue = slot_2;
                            (*io1_7).value_ = (*io2_7).value_;
                            (*io1_7).tt_ = (*io2_7).tt_;
                            if (*io1_7).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_7).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_7).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_7).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishget(L, rb_3, rc_1, ra_13, slot_2);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_SETTABUP => {
                        let mut slot_3: *const TValue = 0 as *const TValue;
                        let mut upval_0: *mut TValue = (**((*cl).upvals).as_mut_ptr().offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        ))
                        .v
                        .p;
                        let mut rb_4: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut rc_2: *mut TValue =
                            if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                                k.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                )
                            } else {
                                &mut (*base.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                ))
                                .val
                            };
                        let mut key_2: *mut TString =
                            &mut (*((*rb_4).value_.gc as *mut GCUnion)).ts;
                        if if !((*upval_0).tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_3 = 0 as *const TValue;
                            0
                        } else {
                            slot_3 = luaH_getshortstr(
                                &mut (*((*upval_0).value_.gc as *mut GCUnion)).h,
                                key_2,
                            );
                            !((*slot_3).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_8: *mut TValue = slot_3 as *mut TValue;
                            let mut io2_8: *const TValue = rc_2;
                            (*io1_8).value_ = (*io2_8).value_;
                            (*io1_8).tt_ = (*io2_8).tt_;
                            if (*io1_8).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_8).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_8).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_8).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                            if (*rc_2).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                                if (*(*upval_0).value_.gc).marked as i32 & (1 as i32) << 5 as i32
                                    != 0
                                    && (*(*rc_2).value_.gc).marked as i32
                                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                                        != 0
                                {
                                    luaC_barrierback_(L, (*upval_0).value_.gc);
                                } else {
                                };
                            } else {
                            };
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishset(L, upval_0, rb_4, rc_2, slot_3);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_SETTABLE => {
                        let mut ra_14: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot_4: *const TValue = 0 as *const TValue;
                        let mut rb_5: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut rc_3: *mut TValue =
                            if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                                k.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                )
                            } else {
                                &mut (*base.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                ))
                                .val
                            };
                        let mut n_0: lua_Unsigned = 0;
                        if if (*rb_5).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            n_0 = (*rb_5).value_.i as lua_Unsigned;
                            (if !((*ra_14).val.tt_ as i32
                                == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                            {
                                slot_4 = 0 as *const TValue;
                                0
                            } else {
                                slot_4 = (if n_0.wrapping_sub(1 as u32 as lua_Unsigned)
                                    < (*(&mut (*((*ra_14).val.value_.gc as *mut GCUnion)).h
                                        as *mut Table))
                                        .alimit
                                        as lua_Unsigned
                                {
                                    &mut *((*(&mut (*((*ra_14).val.value_.gc as *mut GCUnion)).h
                                        as *mut Table))
                                        .array)
                                        .offset(n_0.wrapping_sub(1 as i32 as lua_Unsigned) as isize)
                                        as *mut TValue
                                        as *const TValue
                                } else {
                                    luaH_getint(
                                        &mut (*((*ra_14).val.value_.gc as *mut GCUnion)).h,
                                        n_0 as lua_Integer,
                                    )
                                });
                                !((*slot_4).tt_ as i32 & 0xf as i32 == 0) as i32
                            })
                        } else if !((*ra_14).val.tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_4 = 0 as *const TValue;
                            0
                        } else {
                            slot_4 =
                                luaH_get(&mut (*((*ra_14).val.value_.gc as *mut GCUnion)).h, rb_5);
                            !((*slot_4).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_9: *mut TValue = slot_4 as *mut TValue;
                            let mut io2_9: *const TValue = rc_3;
                            (*io1_9).value_ = (*io2_9).value_;
                            (*io1_9).tt_ = (*io2_9).tt_;
                            if (*io1_9).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_9).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_9).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_9).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                            if (*rc_3).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                                if (*(*ra_14).val.value_.gc).marked as i32 & (1 as i32) << 5 as i32
                                    != 0
                                    && (*(*rc_3).value_.gc).marked as i32
                                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                                        != 0
                                {
                                    luaC_barrierback_(L, (*ra_14).val.value_.gc);
                                } else {
                                };
                            } else {
                            };
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishset(L, &mut (*ra_14).val, rb_5, rc_3, slot_4);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_SETI => {
                        let mut ra_15: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot_5: *const TValue = 0 as *const TValue;
                        let mut c_0: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        let mut rc_4: *mut TValue =
                            if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                                k.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                )
                            } else {
                                &mut (*base.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                ))
                                .val
                            };
                        if if !((*ra_15).val.tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_5 = 0 as *const TValue;
                            0
                        } else {
                            slot_5 = (if (c_0 as lua_Unsigned)
                                .wrapping_sub(1 as u32 as lua_Unsigned)
                                < (*(&mut (*((*ra_15).val.value_.gc as *mut GCUnion)).h
                                    as *mut Table))
                                    .alimit as lua_Unsigned
                            {
                                &mut *((*(&mut (*((*ra_15).val.value_.gc as *mut GCUnion)).h
                                    as *mut Table))
                                    .array)
                                    .offset((c_0 - 1 as i32) as isize)
                                    as *mut TValue as *const TValue
                            } else {
                                luaH_getint(
                                    &mut (*((*ra_15).val.value_.gc as *mut GCUnion)).h,
                                    c_0 as lua_Integer,
                                )
                            });
                            !((*slot_5).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_10: *mut TValue = slot_5 as *mut TValue;
                            let mut io2_10: *const TValue = rc_4;
                            (*io1_10).value_ = (*io2_10).value_;
                            (*io1_10).tt_ = (*io2_10).tt_;
                            if (*io1_10).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_10).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_10).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_10).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                            if (*rc_4).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                                if (*(*ra_15).val.value_.gc).marked as i32 & (1 as i32) << 5 as i32
                                    != 0
                                    && (*(*rc_4).value_.gc).marked as i32
                                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                                        != 0
                                {
                                    luaC_barrierback_(L, (*ra_15).val.value_.gc);
                                } else {
                                };
                            } else {
                            };
                        } else {
                            let mut key_3: TValue = TValue {
                                value_: Value {
                                    gc: 0 as *mut GCObject,
                                },
                                tt_: 0,
                            };
                            let mut io_2: *mut TValue = &mut key_3;
                            (*io_2).value_.i = c_0 as lua_Integer;
                            (*io_2).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishset(L, &mut (*ra_15).val, &mut key_3, rc_4, slot_5);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_SETFIELD => {
                        let mut ra_16: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot_6: *const TValue = 0 as *const TValue;
                        let mut rb_6: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut rc_5: *mut TValue =
                            if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                                k.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                )
                            } else {
                                &mut (*base.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                ))
                                .val
                            };
                        let mut key_4: *mut TString =
                            &mut (*((*rb_6).value_.gc as *mut GCUnion)).ts;
                        if if !((*ra_16).val.tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_6 = 0 as *const TValue;
                            0
                        } else {
                            slot_6 = luaH_getshortstr(
                                &mut (*((*ra_16).val.value_.gc as *mut GCUnion)).h,
                                key_4,
                            );
                            !((*slot_6).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_11: *mut TValue = slot_6 as *mut TValue;
                            let mut io2_11: *const TValue = rc_5;
                            (*io1_11).value_ = (*io2_11).value_;
                            (*io1_11).tt_ = (*io2_11).tt_;
                            if (*io1_11).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_11).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_11).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_11).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                            if (*rc_5).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                                if (*(*ra_16).val.value_.gc).marked as i32 & (1 as i32) << 5 as i32
                                    != 0
                                    && (*(*rc_5).value_.gc).marked as i32
                                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                                        != 0
                                {
                                    luaC_barrierback_(L, (*ra_16).val.value_.gc);
                                } else {
                                };
                            } else {
                            };
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishset(L, &mut (*ra_16).val, rb_6, rc_5, slot_6);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_NEWTABLE => {
                        let mut ra_17: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut b_3: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        let mut c_1: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        let mut t: *mut Table = 0 as *mut Table;
                        if b_3 > 0 {
                            b_3 = (1 as i32) << b_3 - 1 as i32;
                        }
                        if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                            c_1 += (*pc >> 0 + 7 as i32
                                & !(!(0 as Instruction)
                                    << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                    << 0) as i32
                                * (((1 as i32) << 8 as i32) - 1 as i32 + 1 as i32);
                        }
                        pc = pc.offset(1);
                        pc;
                        (*L).top.p = ra_17.offset(1);
                        t = luaH_new(L);
                        let mut io_3: *mut TValue = &mut (*ra_17).val;
                        let mut x_: *mut Table = t;
                        (*io_3).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
                        (*io_3).tt_ =
                            (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
                        if (*io_3).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                            || (*io_3).tt_ as i32 & 0x3f as i32 == (*(*io_3).value_.gc).tt as i32
                                && (L.is_null()
                                    || (*(*io_3).value_.gc).marked as i32
                                        & ((*(*L).l_G).currentwhite as i32
                                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                        == 0)
                        {
                        } else {
                        };
                        if b_3 != 0 || c_1 != 0 {
                            luaH_resize(L, t, c_1 as u32, b_3 as u32);
                        }
                        if (*(*L).l_G).GCdebt > 0 as l_mem {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = ra_17.offset(1);
                            luaC_step(L);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_SELF => {
                        let mut ra_18: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut slot_7: *const TValue = 0 as *const TValue;
                        let mut rb_7: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut rc_6: *mut TValue =
                            if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                                k.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                )
                            } else {
                                &mut (*base.offset(
                                    (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                ))
                                .val
                            };
                        let mut key_5: *mut TString =
                            &mut (*((*rc_6).value_.gc as *mut GCUnion)).ts;
                        let mut io1_12: *mut TValue = &mut (*ra_18.offset(1)).val;
                        let mut io2_12: *const TValue = rb_7;
                        (*io1_12).value_ = (*io2_12).value_;
                        (*io1_12).tt_ = (*io2_12).tt_;
                        if (*io1_12).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                            || (*io1_12).tt_ as i32 & 0x3f as i32
                                == (*(*io1_12).value_.gc).tt as i32
                                && (L.is_null()
                                    || (*(*io1_12).value_.gc).marked as i32
                                        & ((*(*L).l_G).currentwhite as i32
                                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                        == 0)
                        {
                        } else {
                        };
                        if if !((*rb_7).tt_ as i32
                            == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32)
                        {
                            slot_7 = 0 as *const TValue;
                            0
                        } else {
                            slot_7 =
                                luaH_getstr(&mut (*((*rb_7).value_.gc as *mut GCUnion)).h, key_5);
                            !((*slot_7).tt_ as i32 & 0xf as i32 == 0) as i32
                        } != 0
                        {
                            let mut io1_13: *mut TValue = &mut (*ra_18).val;
                            let mut io2_13: *const TValue = slot_7;
                            (*io1_13).value_ = (*io2_13).value_;
                            (*io1_13).tt_ = (*io2_13).tt_;
                            if (*io1_13).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_13).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_13).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_13).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaV_finishget(L, rb_7, rc_6, ra_18, slot_7);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_ADDI => {
                        let mut ra_19: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut imm: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        if (*v1).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            let mut iv1: lua_Integer = (*v1).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_4: *mut TValue = &mut (*ra_19).val;
                            (*io_4).value_.i = (iv1 as lua_Unsigned)
                                .wrapping_add(imm as lua_Unsigned)
                                as lua_Integer;
                            (*io_4).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else if (*v1).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            let mut nb: lua_Number = (*v1).value_.n;
                            let mut fimm: lua_Number = imm as lua_Number;
                            pc = pc.offset(1);
                            pc;
                            let mut io_5: *mut TValue = &mut (*ra_19).val;
                            (*io_5).value_.n = nb + fimm;
                            (*io_5).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_ADDK => {
                        let mut v1_0: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut ra_20: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_0).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1: lua_Integer = (*v1_0).value_.i;
                            let mut i2: lua_Integer = (*v2).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_6: *mut TValue = &mut (*ra_20).val;
                            (*io_6).value_.i = (i1 as lua_Unsigned).wrapping_add(i2 as lua_Unsigned)
                                as lua_Integer;
                            (*io_6).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1: lua_Number = 0.;
                            let mut n2: lua_Number = 0.;
                            if (if (*v1_0).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1 = (*v1_0).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_0).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1 = (*v1_0).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2 = (*v2).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2 = (*v2).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_7: *mut TValue = &mut (*ra_20).val;
                                (*io_7).value_.n = n1 + n2;
                                (*io_7).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_SUBK => {
                        let mut v1_1: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_0: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut ra_21: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_1).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_0).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_0: lua_Integer = (*v1_1).value_.i;
                            let mut i2_0: lua_Integer = (*v2_0).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_8: *mut TValue = &mut (*ra_21).val;
                            (*io_8).value_.i = (i1_0 as lua_Unsigned)
                                .wrapping_sub(i2_0 as lua_Unsigned)
                                as lua_Integer;
                            (*io_8).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_0: lua_Number = 0.;
                            let mut n2_0: lua_Number = 0.;
                            if (if (*v1_1).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_0 = (*v1_1).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_1).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_0 = (*v1_1).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_0).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_0 = (*v2_0).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_0).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_0 = (*v2_0).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_9: *mut TValue = &mut (*ra_21).val;
                                (*io_9).value_.n = n1_0 - n2_0;
                                (*io_9).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_MULK => {
                        let mut v1_2: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_1: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut ra_22: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_2).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_1).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_1: lua_Integer = (*v1_2).value_.i;
                            let mut i2_1: lua_Integer = (*v2_1).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_10: *mut TValue = &mut (*ra_22).val;
                            (*io_10).value_.i = ((i1_1 as lua_Unsigned)
                                .wrapping_mul(i2_1 as lua_Unsigned))
                                as lua_Integer;
                            (*io_10).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_1: lua_Number = 0.;
                            let mut n2_1: lua_Number = 0.;
                            if (if (*v1_2).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_1 = (*v1_2).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_2).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_1 = (*v1_2).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_1).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_1 = (*v2_1).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_1).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_1 = (*v2_1).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_11: *mut TValue = &mut (*ra_22).val;
                                (*io_11).value_.n = n1_1 * n2_1;
                                (*io_11).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_MODK => {
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        let mut v1_3: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_2: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut ra_23: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_3).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_2).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_2: lua_Integer = (*v1_3).value_.i;
                            let mut i2_2: lua_Integer = (*v2_2).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_12: *mut TValue = &mut (*ra_23).val;
                            (*io_12).value_.i = luaV_mod(L, i1_2, i2_2);
                            (*io_12).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_2: lua_Number = 0.;
                            let mut n2_2: lua_Number = 0.;
                            if (if (*v1_3).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_2 = (*v1_3).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_3).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_2 = (*v1_3).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_2).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_2 = (*v2_2).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_2).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_2 = (*v2_2).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_13: *mut TValue = &mut (*ra_23).val;
                                (*io_13).value_.n = luaV_modf(L, n1_2, n2_2);
                                (*io_13).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_POWK => {
                        let mut ra_24: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_4: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_3: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut n1_3: lua_Number = 0.;
                        let mut n2_3: lua_Number = 0.;
                        if (if (*v1_4).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            n1_3 = (*v1_4).value_.n;
                            1 as i32
                        } else {
                            (if (*v1_4).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                n1_3 = (*v1_4).value_.i as lua_Number;
                                1 as i32
                            } else {
                                0
                            })
                        }) != 0
                            && (if (*v2_3).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n2_3 = (*v2_3).value_.n;
                                1 as i32
                            } else {
                                (if (*v2_3).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n2_3 = (*v2_3).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_14: *mut TValue = &mut (*ra_24).val;
                            (*io_14).value_.n = (if n2_3 == 2 as i32 as lua_Number {
                                n1_3 * n1_3
                            } else {
                                n1_3.powf(n2_3)
                            });
                            (*io_14).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_DIVK => {
                        let mut ra_25: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_5: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_4: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut n1_4: lua_Number = 0.;
                        let mut n2_4: lua_Number = 0.;
                        if (if (*v1_5).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            n1_4 = (*v1_5).value_.n;
                            1 as i32
                        } else {
                            (if (*v1_5).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                n1_4 = (*v1_5).value_.i as lua_Number;
                                1 as i32
                            } else {
                                0
                            })
                        }) != 0
                            && (if (*v2_4).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n2_4 = (*v2_4).value_.n;
                                1 as i32
                            } else {
                                (if (*v2_4).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n2_4 = (*v2_4).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_15: *mut TValue = &mut (*ra_25).val;
                            (*io_15).value_.n = n1_4 / n2_4;
                            (*io_15).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_IDIVK => {
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        let mut v1_6: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_5: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut ra_26: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_6).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_5).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_3: lua_Integer = (*v1_6).value_.i;
                            let mut i2_3: lua_Integer = (*v2_5).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_16: *mut TValue = &mut (*ra_26).val;
                            (*io_16).value_.i = luaV_idiv(L, i1_3, i2_3);
                            (*io_16).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_5: lua_Number = 0.;
                            let mut n2_5: lua_Number = 0.;
                            if (if (*v1_6).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_5 = (*v1_6).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_6).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_5 = (*v1_6).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_5).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_5 = (*v2_5).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_5).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_5 = (*v2_5).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_17: *mut TValue = &mut (*ra_26).val;
                                (*io_17).value_.n = (n1_5 / n2_5).floor();
                                (*io_17).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_BANDK => {
                        let mut ra_27: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_7: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_6: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut i1_4: lua_Integer = 0;
                        let mut i2_4: lua_Integer = (*v2_6).value_.i;
                        if if (((*v1_7).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_4 = (*v1_7).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_7, &mut i1_4, F2Ieq)
                        } != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_18: *mut TValue = &mut (*ra_27).val;
                            (*io_18).value_.i =
                                (i1_4 as lua_Unsigned & i2_4 as lua_Unsigned) as lua_Integer;
                            (*io_18).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_BORK => {
                        let mut ra_28: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_8: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_7: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut i1_5: lua_Integer = 0;
                        let mut i2_5: lua_Integer = (*v2_7).value_.i;
                        if if (((*v1_8).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_5 = (*v1_8).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_8, &mut i1_5, F2Ieq)
                        } != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_19: *mut TValue = &mut (*ra_28).val;
                            (*io_19).value_.i =
                                (i1_5 as lua_Unsigned | i2_5 as lua_Unsigned) as lua_Integer;
                            (*io_19).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_BXORK => {
                        let mut ra_29: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_9: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_8: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut i1_6: lua_Integer = 0;
                        let mut i2_6: lua_Integer = (*v2_8).value_.i;
                        if if (((*v1_9).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_6 = (*v1_9).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_9, &mut i1_6, F2Ieq)
                        } != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_20: *mut TValue = &mut (*ra_29).val;
                            (*io_20).value_.i =
                                (i1_6 as lua_Unsigned ^ i2_6 as lua_Unsigned) as lua_Integer;
                            (*io_20).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_SHRI => {
                        let mut ra_30: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_8: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ic: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        let mut ib: lua_Integer = 0;
                        if if (((*rb_8).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            ib = (*rb_8).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(rb_8, &mut ib, F2Ieq)
                        } != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_21: *mut TValue = &mut (*ra_30).val;
                            (*io_21).value_.i = luaV_shiftl(ib, -ic as lua_Integer);
                            (*io_21).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_SHLI => {
                        let mut ra_31: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_9: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ic_0: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        let mut ib_0: lua_Integer = 0;
                        if if (((*rb_9).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            ib_0 = (*rb_9).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(rb_9, &mut ib_0, F2Ieq)
                        } != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_22: *mut TValue = &mut (*ra_31).val;
                            (*io_22).value_.i = luaV_shiftl(ic_0 as lua_Integer, ib_0);
                            (*io_22).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_ADD => {
                        let mut v1_10: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_9: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ra_32: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_10).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_9).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_7: lua_Integer = (*v1_10).value_.i;
                            let mut i2_7: lua_Integer = (*v2_9).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_23: *mut TValue = &mut (*ra_32).val;
                            (*io_23).value_.i = (i1_7 as lua_Unsigned)
                                .wrapping_add(i2_7 as lua_Unsigned)
                                as lua_Integer;
                            (*io_23).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_6: lua_Number = 0.;
                            let mut n2_6: lua_Number = 0.;
                            if (if (*v1_10).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_6 = (*v1_10).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_10).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_6 = (*v1_10).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_9).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_6 = (*v2_9).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_9).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_6 = (*v2_9).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_24: *mut TValue = &mut (*ra_32).val;
                                (*io_24).value_.n = n1_6 + n2_6;
                                (*io_24).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_SUB => {
                        let mut v1_11: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_10: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ra_33: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_11).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_10).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_8: lua_Integer = (*v1_11).value_.i;
                            let mut i2_8: lua_Integer = (*v2_10).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_25: *mut TValue = &mut (*ra_33).val;
                            (*io_25).value_.i = (i1_8 as lua_Unsigned)
                                .wrapping_sub(i2_8 as lua_Unsigned)
                                as lua_Integer;
                            (*io_25).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_7: lua_Number = 0.;
                            let mut n2_7: lua_Number = 0.;
                            if (if (*v1_11).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_7 = (*v1_11).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_11).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_7 = (*v1_11).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_10).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_7 = (*v2_10).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_10).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_7 = (*v2_10).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_26: *mut TValue = &mut (*ra_33).val;
                                (*io_26).value_.n = n1_7 - n2_7;
                                (*io_26).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_MUL => {
                        let mut v1_12: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_11: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ra_34: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_12).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_11).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_9: lua_Integer = (*v1_12).value_.i;
                            let mut i2_9: lua_Integer = (*v2_11).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_27: *mut TValue = &mut (*ra_34).val;
                            (*io_27).value_.i = ((i1_9 as lua_Unsigned)
                                .wrapping_mul(i2_9 as lua_Unsigned))
                                as lua_Integer;
                            (*io_27).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_8: lua_Number = 0.;
                            let mut n2_8: lua_Number = 0.;
                            if (if (*v1_12).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_8 = (*v1_12).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_12).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_8 = (*v1_12).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_11).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_8 = (*v2_11).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_11).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_8 = (*v2_11).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_28: *mut TValue = &mut (*ra_34).val;
                                (*io_28).value_.n = n1_8 * n2_8;
                                (*io_28).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_MOD => {
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        let mut v1_13: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_12: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ra_35: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_13).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_12).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_10: lua_Integer = (*v1_13).value_.i;
                            let mut i2_10: lua_Integer = (*v2_12).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_29: *mut TValue = &mut (*ra_35).val;
                            (*io_29).value_.i = luaV_mod(L, i1_10, i2_10);
                            (*io_29).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_9: lua_Number = 0.;
                            let mut n2_9: lua_Number = 0.;
                            if (if (*v1_13).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_9 = (*v1_13).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_13).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_9 = (*v1_13).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_12).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_9 = (*v2_12).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_12).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_9 = (*v2_12).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_30: *mut TValue = &mut (*ra_35).val;
                                (*io_30).value_.n = luaV_modf(L, n1_9, n2_9);
                                (*io_30).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_POW => {
                        let mut ra_36: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_14: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_13: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut n1_10: lua_Number = 0.;
                        let mut n2_10: lua_Number = 0.;
                        if (if (*v1_14).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            n1_10 = (*v1_14).value_.n;
                            1 as i32
                        } else {
                            (if (*v1_14).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                n1_10 = (*v1_14).value_.i as lua_Number;
                                1 as i32
                            } else {
                                0
                            })
                        }) != 0
                            && (if (*v2_13).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n2_10 = (*v2_13).value_.n;
                                1 as i32
                            } else {
                                (if (*v2_13).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n2_10 = (*v2_13).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_31: *mut TValue = &mut (*ra_36).val;
                            (*io_31).value_.n = (if n2_10 == 2 as i32 as lua_Number {
                                n1_10 * n1_10
                            } else {
                                n1_10.powf(n2_10)
                            });
                            (*io_31).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_DIV => {
                        let mut ra_37: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_15: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_14: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut n1_11: lua_Number = 0.;
                        let mut n2_11: lua_Number = 0.;
                        if (if (*v1_15).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            n1_11 = (*v1_15).value_.n;
                            1 as i32
                        } else {
                            (if (*v1_15).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                n1_11 = (*v1_15).value_.i as lua_Number;
                                1 as i32
                            } else {
                                0
                            })
                        }) != 0
                            && (if (*v2_14).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n2_11 = (*v2_14).value_.n;
                                1 as i32
                            } else {
                                (if (*v2_14).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n2_11 = (*v2_14).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_32: *mut TValue = &mut (*ra_37).val;
                            (*io_32).value_.n = n1_11 / n2_11;
                            (*io_32).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_IDIV => {
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        let mut v1_16: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_15: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ra_38: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*v1_16).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*v2_15).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut i1_11: lua_Integer = (*v1_16).value_.i;
                            let mut i2_11: lua_Integer = (*v2_15).value_.i;
                            pc = pc.offset(1);
                            pc;
                            let mut io_33: *mut TValue = &mut (*ra_38).val;
                            (*io_33).value_.i = luaV_idiv(L, i1_11, i2_11);
                            (*io_33).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            let mut n1_12: lua_Number = 0.;
                            let mut n2_12: lua_Number = 0.;
                            if (if (*v1_16).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                n1_12 = (*v1_16).value_.n;
                                1 as i32
                            } else {
                                (if (*v1_16).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                    n1_12 = (*v1_16).value_.i as lua_Number;
                                    1 as i32
                                } else {
                                    0
                                })
                            }) != 0
                                && (if (*v2_15).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                                    n2_12 = (*v2_15).value_.n;
                                    1 as i32
                                } else {
                                    (if (*v2_15).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                                        n2_12 = (*v2_15).value_.i as lua_Number;
                                        1 as i32
                                    } else {
                                        0
                                    })
                                }) != 0
                            {
                                pc = pc.offset(1);
                                pc;
                                let mut io_34: *mut TValue = &mut (*ra_38).val;
                                (*io_34).value_.n = (n1_12 / n2_12).floor();
                                (*io_34).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                            }
                        }
                        continue;
                    }
                    OP_BAND => {
                        let mut ra_39: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_17: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_16: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut i1_12: lua_Integer = 0;
                        let mut i2_12: lua_Integer = 0;
                        if (if (((*v1_17).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_12 = (*v1_17).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_17, &mut i1_12, F2Ieq)
                        }) != 0
                            && (if (((*v2_16).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                                as i32 as std::ffi::c_long
                                != 0
                            {
                                i2_12 = (*v2_16).value_.i;
                                1 as i32
                            } else {
                                luaV_tointegerns(v2_16, &mut i2_12, F2Ieq)
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_35: *mut TValue = &mut (*ra_39).val;
                            (*io_35).value_.i =
                                (i1_12 as lua_Unsigned & i2_12 as lua_Unsigned) as lua_Integer;
                            (*io_35).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_BOR => {
                        let mut ra_40: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_18: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_17: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut i1_13: lua_Integer = 0;
                        let mut i2_13: lua_Integer = 0;
                        if (if (((*v1_18).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_13 = (*v1_18).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_18, &mut i1_13, F2Ieq)
                        }) != 0
                            && (if (((*v2_17).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                                as i32 as std::ffi::c_long
                                != 0
                            {
                                i2_13 = (*v2_17).value_.i;
                                1 as i32
                            } else {
                                luaV_tointegerns(v2_17, &mut i2_13, F2Ieq)
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_36: *mut TValue = &mut (*ra_40).val;
                            (*io_36).value_.i =
                                (i1_13 as lua_Unsigned | i2_13 as lua_Unsigned) as lua_Integer;
                            (*io_36).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_BXOR => {
                        let mut ra_41: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_19: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_18: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut i1_14: lua_Integer = 0;
                        let mut i2_14: lua_Integer = 0;
                        if (if (((*v1_19).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_14 = (*v1_19).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_19, &mut i1_14, F2Ieq)
                        }) != 0
                            && (if (((*v2_18).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                                as i32 as std::ffi::c_long
                                != 0
                            {
                                i2_14 = (*v2_18).value_.i;
                                1 as i32
                            } else {
                                luaV_tointegerns(v2_18, &mut i2_14, F2Ieq)
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_37: *mut TValue = &mut (*ra_41).val;
                            (*io_37).value_.i =
                                (i1_14 as lua_Unsigned ^ i2_14 as lua_Unsigned) as lua_Integer;
                            (*io_37).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_SHR => {
                        let mut ra_42: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_20: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_19: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut i1_15: lua_Integer = 0;
                        let mut i2_15: lua_Integer = 0;
                        if (if (((*v1_20).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_15 = (*v1_20).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_20, &mut i1_15, F2Ieq)
                        }) != 0
                            && (if (((*v2_19).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                                as i32 as std::ffi::c_long
                                != 0
                            {
                                i2_15 = (*v2_19).value_.i;
                                1 as i32
                            } else {
                                luaV_tointegerns(v2_19, &mut i2_15, F2Ieq)
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_38: *mut TValue = &mut (*ra_42).val;
                            (*io_38).value_.i = luaV_shiftl(
                                i1_15,
                                (0 as lua_Unsigned).wrapping_sub(i2_15 as lua_Unsigned)
                                    as lua_Integer,
                            );
                            (*io_38).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_SHL => {
                        let mut ra_43: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut v1_21: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut v2_20: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut i1_16: lua_Integer = 0;
                        let mut i2_16: lua_Integer = 0;
                        if (if (((*v1_21).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            i1_16 = (*v1_21).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(v1_21, &mut i1_16, F2Ieq)
                        }) != 0
                            && (if (((*v2_20).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                                as i32 as std::ffi::c_long
                                != 0
                            {
                                i2_16 = (*v2_20).value_.i;
                                1 as i32
                            } else {
                                luaV_tointegerns(v2_20, &mut i2_16, F2Ieq)
                            }) != 0
                        {
                            pc = pc.offset(1);
                            pc;
                            let mut io_39: *mut TValue = &mut (*ra_43).val;
                            (*io_39).value_.i = luaV_shiftl(i1_16, i2_16);
                            (*io_39).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_MMBIN => {
                        let mut ra_44: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut pi: Instruction = *pc.offset(-(2));
                        let mut rb_10: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut tm: TMS = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32 as TMS;
                        let mut result: StkId = base.offset(
                            (pi >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaT_trybinTM(L, &mut (*ra_44).val, rb_10, result, tm);
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_MMBINI => {
                        let mut ra_45: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut pi_0: Instruction = *pc.offset(-(2));
                        let mut imm_0: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        let mut tm_0: TMS = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32 as TMS;
                        let mut flip: i32 = (i >> 0 + 7 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 1 as i32) << 0)
                            as i32;
                        let mut result_0: StkId = base.offset(
                            (pi_0 >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaT_trybiniTM(
                            L,
                            &mut (*ra_45).val,
                            imm_0 as lua_Integer,
                            flip,
                            result_0,
                            tm_0,
                        );
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_MMBINK => {
                        let mut ra_46: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut pi_1: Instruction = *pc.offset(-(2));
                        let mut imm_1: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut tm_1: TMS = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32 as TMS;
                        let mut flip_0: i32 = (i >> 0 + 7 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 1 as i32) << 0)
                            as i32;
                        let mut result_1: StkId = base.offset(
                            (pi_1 >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaT_trybinassocTM(L, &mut (*ra_46).val, imm_1, flip_0, result_1, tm_1);
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_UNM => {
                        let mut ra_47: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_11: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut nb_0: lua_Number = 0.;
                        if (*rb_11).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            let mut ib_1: lua_Integer = (*rb_11).value_.i;
                            let mut io_40: *mut TValue = &mut (*ra_47).val;
                            (*io_40).value_.i = (0 as lua_Unsigned)
                                .wrapping_sub(ib_1 as lua_Unsigned)
                                as lua_Integer;
                            (*io_40).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else if if (*rb_11).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            nb_0 = (*rb_11).value_.n;
                            1 as i32
                        } else if (*rb_11).tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            nb_0 = (*rb_11).value_.i as lua_Number;
                            1 as i32
                        } else {
                            0
                        } != 0
                        {
                            let mut io_41: *mut TValue = &mut (*ra_47).val;
                            (*io_41).value_.n = -nb_0;
                            (*io_41).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaT_trybinTM(L, rb_11, rb_11, ra_47, TM_UNM);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_BNOT => {
                        let mut ra_48: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_12: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        let mut ib_2: lua_Integer = 0;
                        if if (((*rb_12).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0)
                            as i32 as std::ffi::c_long
                            != 0
                        {
                            ib_2 = (*rb_12).value_.i;
                            1 as i32
                        } else {
                            luaV_tointegerns(rb_12, &mut ib_2, F2Ieq)
                        } != 0
                        {
                            let mut io_42: *mut TValue = &mut (*ra_48).val;
                            (*io_42).value_.i =
                                (!(0 as lua_Unsigned) ^ ib_2 as lua_Unsigned) as lua_Integer;
                            (*io_42).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            luaT_trybinTM(L, rb_12, rb_12, ra_48, TM_BNOT);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_NOT => {
                        let mut ra_49: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_13: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        if (*rb_13).tt_ as i32 == 1 as i32 | (0) << 4 as i32
                            || (*rb_13).tt_ as i32 & 0xf as i32 == 0
                        {
                            (*ra_49).val.tt_ = (1 as i32 | (1 as i32) << 4 as i32) as lu_byte;
                        } else {
                            (*ra_49).val.tt_ = (1 as i32 | (0) << 4 as i32) as lu_byte;
                        }
                        continue;
                    }
                    OP_LEN => {
                        let mut ra_50: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaV_objlen(
                            L,
                            ra_50,
                            &mut (*base.offset(
                                (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                    & !(!(0 as Instruction) << 8 as i32) << 0)
                                    as i32 as isize,
                            ))
                            .val,
                        );
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_CONCAT => {
                        let mut ra_51: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut n_1: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        (*L).top.p = ra_51.offset(n_1 as isize);
                        (*ci).u.l.savedpc = pc;
                        luaV_concat(L, n_1);
                        trap = (*ci).u.l.trap;
                        if (*(*L).l_G).GCdebt > 0 as l_mem {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*L).top.p;
                            luaC_step(L);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_CLOSE => {
                        let mut ra_52: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaF_close(L, ra_52, 0, 1 as i32);
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_TBC => {
                        let mut ra_53: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaF_newtbcupval(L, ra_53);
                        continue;
                    }
                    OP_JMP => {
                        pc = pc.offset(
                            ((i >> 0 + 7 as i32
                                & !(!(0 as Instruction)
                                    << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                    << 0) as i32
                                - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                    - 1 as i32
                                    >> 1 as i32)
                                + 0) as isize,
                        );
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_EQ => {
                        let mut ra_54: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_0: i32 = 0;
                        let mut rb_14: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        cond_0 = luaV_equalobj(L, &mut (*ra_54).val, rb_14);
                        trap = (*ci).u.l.trap;
                        if cond_0
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni: Instruction = *pc;
                            pc = pc.offset(
                                ((ni >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_LT => {
                        let mut ra_55: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_1: i32 = 0;
                        let mut rb_15: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        if (*ra_55).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*rb_15).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut ia: lua_Integer = (*ra_55).val.value_.i;
                            let mut ib_3: lua_Integer = (*rb_15).value_.i;
                            cond_1 = (ia < ib_3) as i32;
                        } else if (*ra_55).val.tt_ as i32 & 0xf as i32 == 3 as i32
                            && (*rb_15).tt_ as i32 & 0xf as i32 == 3 as i32
                        {
                            cond_1 = LTnum(&mut (*ra_55).val, rb_15);
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            cond_1 = lessthanothers(L, &mut (*ra_55).val, rb_15);
                            trap = (*ci).u.l.trap;
                        }
                        if cond_1
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_0: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_0 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_LE => {
                        let mut ra_56: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_2: i32 = 0;
                        let mut rb_16: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        if (*ra_56).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32
                            && (*rb_16).tt_ as i32 == 3 as i32 | (0) << 4 as i32
                        {
                            let mut ia_0: lua_Integer = (*ra_56).val.value_.i;
                            let mut ib_4: lua_Integer = (*rb_16).value_.i;
                            cond_2 = (ia_0 <= ib_4) as i32;
                        } else if (*ra_56).val.tt_ as i32 & 0xf as i32 == 3 as i32
                            && (*rb_16).tt_ as i32 & 0xf as i32 == 3 as i32
                        {
                            cond_2 = LEnum(&mut (*ra_56).val, rb_16);
                        } else {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            cond_2 = lessequalothers(L, &mut (*ra_56).val, rb_16);
                            trap = (*ci).u.l.trap;
                        }
                        if cond_2
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_1: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_1 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_EQK => {
                        let mut ra_57: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_17: *mut TValue = k.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        );
                        let mut cond_3: i32 =
                            luaV_equalobj(0 as *mut lua_State, &mut (*ra_57).val, rb_17);
                        if cond_3
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_2: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_2 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_EQI => {
                        let mut ra_58: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_4: i32 = 0;
                        let mut im: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        if (*ra_58).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            cond_4 = ((*ra_58).val.value_.i == im as lua_Integer) as i32;
                        } else if (*ra_58).val.tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            cond_4 = ((*ra_58).val.value_.n == im as lua_Number) as i32;
                        } else {
                            cond_4 = 0;
                        }
                        if cond_4
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_3: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_3 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_LTI => {
                        let mut ra_59: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_5: i32 = 0;
                        let mut im_0: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        if (*ra_59).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            cond_5 = ((*ra_59).val.value_.i < im_0 as lua_Integer) as i32;
                        } else if (*ra_59).val.tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            let mut fa: lua_Number = (*ra_59).val.value_.n;
                            let mut fim: lua_Number = im_0 as lua_Number;
                            cond_5 = (fa < fim) as i32;
                        } else {
                            let mut isf: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32;
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            cond_5 = luaT_callorderiTM(L, &mut (*ra_59).val, im_0, 0, isf, TM_LT);
                            trap = (*ci).u.l.trap;
                        }
                        if cond_5
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_4: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_4 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_LEI => {
                        let mut ra_60: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_6: i32 = 0;
                        let mut im_1: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        if (*ra_60).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            cond_6 = ((*ra_60).val.value_.i <= im_1 as lua_Integer) as i32;
                        } else if (*ra_60).val.tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            let mut fa_0: lua_Number = (*ra_60).val.value_.n;
                            let mut fim_0: lua_Number = im_1 as lua_Number;
                            cond_6 = (fa_0 <= fim_0) as i32;
                        } else {
                            let mut isf_0: i32 = (i
                                >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32;
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            cond_6 = luaT_callorderiTM(L, &mut (*ra_60).val, im_1, 0, isf_0, TM_LE);
                            trap = (*ci).u.l.trap;
                        }
                        if cond_6
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_5: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_5 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_GTI => {
                        let mut ra_61: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_7: i32 = 0;
                        let mut im_2: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        if (*ra_61).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            cond_7 = ((*ra_61).val.value_.i > im_2 as lua_Integer) as i32;
                        } else if (*ra_61).val.tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            let mut fa_1: lua_Number = (*ra_61).val.value_.n;
                            let mut fim_1: lua_Number = im_2 as lua_Number;
                            cond_7 = (fa_1 > fim_1) as i32;
                        } else {
                            let mut isf_1: i32 = (i
                                >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32;
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            cond_7 = luaT_callorderiTM(
                                L,
                                &mut (*ra_61).val,
                                im_2,
                                1 as i32,
                                isf_1,
                                TM_LT,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        if cond_7
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_6: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_6 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_GEI => {
                        let mut ra_62: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_8: i32 = 0;
                        let mut im_3: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - (((1 as i32) << 8 as i32) - 1 as i32 >> 1 as i32);
                        if (*ra_62).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            cond_8 = ((*ra_62).val.value_.i >= im_3 as lua_Integer) as i32;
                        } else if (*ra_62).val.tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
                            let mut fa_2: lua_Number = (*ra_62).val.value_.n;
                            let mut fim_2: lua_Number = im_3 as lua_Number;
                            cond_8 = (fa_2 >= fim_2) as i32;
                        } else {
                            let mut isf_2: i32 = (i
                                >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32;
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = (*ci).top.p;
                            cond_8 = luaT_callorderiTM(
                                L,
                                &mut (*ra_62).val,
                                im_3,
                                1 as i32,
                                isf_2,
                                TM_LE,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        if cond_8
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_7: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_7 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_TEST => {
                        let mut ra_63: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut cond_9: i32 = !((*ra_63).val.tt_ as i32
                            == 1 as i32 | (0) << 4 as i32
                            || (*ra_63).val.tt_ as i32 & 0xf as i32 == 0)
                            as i32;
                        if cond_9
                            != (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut ni_8: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_8 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_TESTSET => {
                        let mut ra_64: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut rb_18: *mut TValue = &mut (*base.offset(
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32 as isize,
                        ))
                        .val;
                        if ((*rb_18).tt_ as i32 == 1 as i32 | (0) << 4 as i32
                            || (*rb_18).tt_ as i32 & 0xf as i32 == 0)
                            as i32
                            == (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 1 as i32) << 0)
                                as i32
                        {
                            pc = pc.offset(1);
                            pc;
                        } else {
                            let mut io1_14: *mut TValue = &mut (*ra_64).val;
                            let mut io2_14: *const TValue = rb_18;
                            (*io1_14).value_ = (*io2_14).value_;
                            (*io1_14).tt_ = (*io2_14).tt_;
                            if (*io1_14).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_14).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_14).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_14).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                            let mut ni_9: Instruction = *pc;
                            pc = pc.offset(
                                ((ni_9 >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    - (((1 as i32) << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        - 1 as i32
                                        >> 1 as i32)
                                    + 1 as i32) as isize,
                            );
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_CALL => {
                        ra_65 = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        newci = 0 as *mut CallInfo;
                        b_4 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        nresults = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - 1 as i32;
                        if b_4 != 0 {
                            (*L).top.p = ra_65.offset(b_4 as isize);
                        }
                        (*ci).u.l.savedpc = pc;
                        newci = luaD_precall(L, ra_65, nresults);
                        if !newci.is_null() {
                            break '_returning;
                        }
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_TAILCALL => {
                        let mut ra_66: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut b_5: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        let mut n_2: i32 = 0;
                        let mut nparams1: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        let mut delta: i32 = if nparams1 != 0 {
                            (*ci).u.l.nextraargs + nparams1
                        } else {
                            0
                        };
                        if b_5 != 0 {
                            (*L).top.p = ra_66.offset(b_5 as isize);
                        } else {
                            b_5 = ((*L).top.p).offset_from(ra_66) as std::ffi::c_long as i32;
                        }
                        (*ci).u.l.savedpc = pc;
                        if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                            luaF_closeupval(L, base);
                        }
                        n_2 = luaD_pretailcall(L, ci, ra_66, b_5, delta);
                        if n_2 < 0 {
                            continue '_startfunc;
                        }
                        (*ci).func.p = ((*ci).func.p).offset(-(delta as isize));
                        luaD_poscall(L, ci, n_2);
                        trap = (*ci).u.l.trap;
                        break;
                    }
                    OP_RETURN => {
                        let mut ra_67: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut n_3: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - 1 as i32;
                        let mut nparams1_0: i32 = (i
                            >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        if n_3 < 0 {
                            n_3 = ((*L).top.p).offset_from(ra_67) as std::ffi::c_long as i32;
                        }
                        (*ci).u.l.savedpc = pc;
                        if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                            (*ci).u2.nres = n_3;
                            if (*L).top.p < (*ci).top.p {
                                (*L).top.p = (*ci).top.p;
                            }
                            luaF_close(L, base, -(1 as i32), 1 as i32);
                            trap = (*ci).u.l.trap;
                            if (trap != 0) as i32 as std::ffi::c_long != 0 {
                                base = ((*ci).func.p).offset(1);
                                ra_67 = base.offset(
                                    (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                );
                            }
                        }
                        if nparams1_0 != 0 {
                            (*ci).func.p = ((*ci).func.p)
                                .offset(-(((*ci).u.l.nextraargs + nparams1_0) as isize));
                        }
                        (*L).top.p = ra_67.offset(n_3 as isize);
                        luaD_poscall(L, ci, n_3);
                        trap = (*ci).u.l.trap;
                        break;
                    }
                    OP_RETURN0 => {
                        if ((*L).hookmask != 0) as i32 as std::ffi::c_long != 0 {
                            let mut ra_68: StkId = base.offset(
                                (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                    as isize,
                            );
                            (*L).top.p = ra_68;
                            (*ci).u.l.savedpc = pc;
                            luaD_poscall(L, ci, 0);
                            trap = 1 as i32;
                        } else {
                            let mut nres: i32 = 0;
                            (*L).ci = (*ci).previous;
                            (*L).top.p = base.offset(-(1));
                            nres = (*ci).nresults as i32;
                            while ((nres > 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                                let fresh137 = (*L).top.p;
                                (*L).top.p = ((*L).top.p).offset(1);
                                (*fresh137).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
                                nres -= 1;
                                nres;
                            }
                        }
                        break;
                    }
                    OP_RETURN1 => {
                        if ((*L).hookmask != 0) as i32 as std::ffi::c_long != 0 {
                            let mut ra_69: StkId = base.offset(
                                (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                    as isize,
                            );
                            (*L).top.p = ra_69.offset(1);
                            (*ci).u.l.savedpc = pc;
                            luaD_poscall(L, ci, 1 as i32);
                            trap = 1 as i32;
                        } else {
                            let mut nres_0: i32 = (*ci).nresults as i32;
                            (*L).ci = (*ci).previous;
                            if nres_0 == 0 {
                                (*L).top.p = base.offset(-(1));
                            } else {
                                let mut ra_70: StkId = base.offset(
                                    (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0)
                                        as i32 as isize,
                                );
                                let mut io1_15: *mut TValue = &mut (*base.offset(-(1))).val;
                                let mut io2_15: *const TValue = &mut (*ra_70).val;
                                (*io1_15).value_ = (*io2_15).value_;
                                (*io1_15).tt_ = (*io2_15).tt_;
                                if (*io1_15).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                    || (*io1_15).tt_ as i32 & 0x3f as i32
                                        == (*(*io1_15).value_.gc).tt as i32
                                        && (L.is_null()
                                            || (*(*io1_15).value_.gc).marked as i32
                                                & ((*(*L).l_G).currentwhite as i32
                                                    ^ ((1 as i32) << 3 as i32
                                                        | (1 as i32) << 4 as i32))
                                                == 0)
                                {
                                } else {
                                };
                                (*L).top.p = base;
                                while ((nres_0 > 1 as i32) as i32 != 0) as i32 as std::ffi::c_long
                                    != 0
                                {
                                    let fresh138 = (*L).top.p;
                                    (*L).top.p = ((*L).top.p).offset(1);
                                    (*fresh138).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
                                    nres_0 -= 1;
                                    nres_0;
                                }
                            }
                        }
                        break;
                    }
                    OP_FORLOOP => {
                        let mut ra_71: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        if (*ra_71.offset(2)).val.tt_ as i32 == 3 as i32 | (0) << 4 as i32 {
                            let mut count: lua_Unsigned =
                                (*ra_71.offset(1)).val.value_.i as lua_Unsigned;
                            if count > 0 as lua_Unsigned {
                                let mut step: lua_Integer = (*ra_71.offset(2)).val.value_.i;
                                let mut idx: lua_Integer = (*ra_71).val.value_.i;
                                let mut io_43: *mut TValue = &mut (*ra_71.offset(1)).val;
                                (*io_43).value_.i =
                                    count.wrapping_sub(1 as i32 as lua_Unsigned) as lua_Integer;
                                idx = (idx as lua_Unsigned).wrapping_add(step as lua_Unsigned)
                                    as lua_Integer;
                                let mut io_44: *mut TValue = &mut (*ra_71).val;
                                (*io_44).value_.i = idx;
                                let mut io_45: *mut TValue = &mut (*ra_71.offset(3)).val;
                                (*io_45).value_.i = idx;
                                (*io_45).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
                                pc = pc.offset(
                                    -((i >> 0 + 7 as i32 + 8 as i32
                                        & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32)
                                            << 0) as i32
                                        as isize),
                                );
                            }
                        } else if floatforloop(ra_71) != 0 {
                            pc = pc.offset(
                                -((i >> 0 + 7 as i32 + 8 as i32
                                    & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                                    as i32 as isize),
                            );
                        }
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_FORPREP => {
                        let mut ra_72: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        if forprep(L, ra_72) != 0 {
                            pc = pc.offset(
                                ((i >> 0 + 7 as i32 + 8 as i32
                                    & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                                    as i32
                                    + 1 as i32) as isize,
                            );
                        }
                        continue;
                    }
                    OP_TFORPREP => {
                        let mut ra_73: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaF_newtbcupval(L, ra_73.offset(3));
                        pc = pc.offset(
                            (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                                as i32 as isize,
                        );
                        let fresh139 = pc;
                        pc = pc.offset(1);
                        i = *fresh139;
                        current_block = 13973394567113199817;
                    }
                    OP_TFORCALL => {
                        current_block = 13973394567113199817;
                    }
                    OP_TFORLOOP => {
                        current_block = 15611964311717037170;
                    }
                    OP_SETLIST => {
                        let mut ra_76: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut n_4: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32;
                        let mut last: u32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32 as u32;
                        let mut h: *mut Table = &mut (*((*ra_76).val.value_.gc as *mut GCUnion)).h;
                        if n_4 == 0 {
                            n_4 = ((*L).top.p).offset_from(ra_76) as std::ffi::c_long as i32
                                - 1 as i32;
                        } else {
                            (*L).top.p = (*ci).top.p;
                        }
                        last = last.wrapping_add(n_4 as u32);
                        if (i & (1 as u32) << 0 + 7 as i32 + 8 as i32) as i32 != 0 {
                            last = last.wrapping_add(
                                ((*pc >> 0 + 7 as i32
                                    & !(!(0 as Instruction)
                                        << 8 as i32 + 8 as i32 + 1 as i32 + 8 as i32)
                                        << 0) as i32
                                    * (((1 as i32) << 8 as i32) - 1 as i32 + 1 as i32))
                                    as u32,
                            );
                            pc = pc.offset(1);
                            pc;
                        }
                        if last > luaH_realasize(h) {
                            luaH_resizearray(L, h, last);
                        }
                        while n_4 > 0 {
                            let mut val: *mut TValue = &mut (*ra_76.offset(n_4 as isize)).val;
                            let mut io1_17: *mut TValue = &mut *((*h).array)
                                .offset(last.wrapping_sub(1) as isize)
                                as *mut TValue;
                            let mut io2_17: *const TValue = val;
                            (*io1_17).value_ = (*io2_17).value_;
                            (*io1_17).tt_ = (*io2_17).tt_;
                            if (*io1_17).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                                || (*io1_17).tt_ as i32 & 0x3f as i32
                                    == (*(*io1_17).value_.gc).tt as i32
                                    && (L.is_null()
                                        || (*(*io1_17).value_.gc).marked as i32
                                            & ((*(*L).l_G).currentwhite as i32
                                                ^ ((1 as i32) << 3 as i32
                                                    | (1 as i32) << 4 as i32))
                                            == 0)
                            {
                            } else {
                            };
                            last = last.wrapping_sub(1);
                            last;
                            if (*val).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                                if (*(&mut (*(h as *mut GCUnion)).gc as *mut GCObject)).marked
                                    as i32
                                    & (1 as i32) << 5 as i32
                                    != 0
                                    && (*(*val).value_.gc).marked as i32
                                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                                        != 0
                                {
                                    luaC_barrierback_(L, &mut (*(h as *mut GCUnion)).gc);
                                } else {
                                };
                            } else {
                            };
                            n_4 -= 1;
                            n_4;
                        }
                        continue;
                    }
                    OP_CLOSURE => {
                        let mut ra_77: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut p: *mut Proto = *((*(*cl).p).p).offset(
                            (i >> 0 + 7 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                                as i32 as isize,
                        );
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        pushclosure(L, p, ((*cl).upvals).as_mut_ptr(), base, ra_77);
                        if (*(*L).l_G).GCdebt > 0 as l_mem {
                            (*ci).u.l.savedpc = pc;
                            (*L).top.p = ra_77.offset(1);
                            luaC_step(L);
                            trap = (*ci).u.l.trap;
                        }
                        continue;
                    }
                    OP_VARARG => {
                        let mut ra_78: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        let mut n_5: i32 = (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32) << 0)
                            as i32
                            - 1 as i32;
                        (*ci).u.l.savedpc = pc;
                        (*L).top.p = (*ci).top.p;
                        luaT_getvarargs(L, ci, ra_78, n_5);
                        trap = (*ci).u.l.trap;
                        continue;
                    }
                    OP_VARARGPREP => {
                        (*ci).u.l.savedpc = pc;
                        luaT_adjustvarargs(
                            L,
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32,
                            ci,
                            (*cl).p,
                        );
                        trap = (*ci).u.l.trap;
                        if (trap != 0) as i32 as std::ffi::c_long != 0 {
                            luaD_hookcall(L, ci);
                            (*L).oldpc = 1 as i32;
                        }
                        base = ((*ci).func.p).offset(1);
                        continue;
                    }
                    OP_EXTRAARG | _ => {
                        continue;
                    }
                }
                match current_block {
                    13973394567113199817 => {
                        let mut ra_74: StkId = base.offset(
                            (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                as isize,
                        );
                        memcpy(
                            ra_74.offset(4) as *mut c_void,
                            ra_74 as *const c_void,
                            (3usize).wrapping_mul(::core::mem::size_of::<StackValue>() as usize),
                        );
                        (*L).top.p = ra_74.offset(4).offset(3);
                        (*ci).u.l.savedpc = pc;
                        luaD_call(
                            L,
                            ra_74.offset(4),
                            (i >> 0 + 7 as i32 + 8 as i32 + 1 as i32 + 8 as i32
                                & !(!(0 as Instruction) << 8 as i32) << 0)
                                as i32,
                        );
                        trap = (*ci).u.l.trap;
                        if (trap != 0) as i32 as std::ffi::c_long != 0 {
                            base = ((*ci).func.p).offset(1);
                            ra_74 = base.offset(
                                (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32
                                    as isize,
                            );
                        }
                        let fresh140 = pc;
                        pc = pc.offset(1);
                        i = *fresh140;
                    }
                    _ => {}
                }
                let mut ra_75: StkId = base.offset(
                    (i >> 0 + 7 as i32 & !(!(0 as Instruction) << 8 as i32) << 0) as i32 as isize,
                );
                if !((*ra_75.offset(4)).val.tt_ as i32 & 0xf as i32 == 0) {
                    let mut io1_16: *mut TValue = &mut (*ra_75.offset(2)).val;
                    let mut io2_16: *const TValue = &mut (*ra_75.offset(4)).val;
                    (*io1_16).value_ = (*io2_16).value_;
                    (*io1_16).tt_ = (*io2_16).tt_;
                    if (*io1_16).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                        || (*io1_16).tt_ as i32 & 0x3f as i32 == (*(*io1_16).value_.gc).tt as i32
                            && (L.is_null()
                                || (*(*io1_16).value_.gc).marked as i32
                                    & ((*(*L).l_G).currentwhite as i32
                                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                                    == 0)
                    {
                    } else {
                    };
                    pc = pc.offset(
                        -((i >> 0 + 7 as i32 + 8 as i32
                            & !(!(0 as Instruction) << 8 as i32 + 8 as i32 + 1 as i32) << 0)
                            as i32 as isize),
                    );
                }
            }
            if (*ci).callstatus as i32 & (1 as i32) << 2 as i32 != 0 {
                break '_startfunc;
            }
            ci = (*ci).previous;
        }
        ci = newci;
    }
}
#[unsafe(no_mangle)]
pub static mut lua_ident: [std::ffi::c_char; 129] = unsafe {
    *::core::mem::transmute::<
        &[u8; 129],
        &[std::ffi::c_char; 129],
    >(
        b"$LuaVersion: Lua 5.4.7  Copyright (C) 1994-2024 Lua.org, PUC-Rio $$LuaAuthors: R. Ierusalimschy, L. H. de Figueiredo, W. Celes $\0",
    )
};
unsafe extern "C-unwind" fn index2value(mut L: *mut lua_State, mut idx: i32) -> *mut TValue {
    let mut ci: *mut CallInfo = (*L).ci;
    if idx > 0 {
        let mut o: StkId = ((*ci).func.p).offset(idx as isize);
        if o >= (*L).top.p {
            return &mut (*(*L).l_G).nilvalue;
        } else {
            return &mut (*o).val;
        }
    } else if !(idx <= -(1000000) - 1000) {
        return &mut (*((*L).top.p).offset(idx as isize)).val;
    } else if idx == -(1000000) - 1000 {
        return &mut (*(*L).l_G).l_registry;
    } else {
        idx = -(1000000) - 1000 - idx;
        if (*(*ci).func.p).val.tt_ as i32
            == 6 as i32 | (2 as i32) << 4 as i32 | (1 as i32) << 6 as i32
        {
            let mut func: *mut CClosure =
                &mut (*((*(*ci).func.p).val.value_.gc as *mut GCUnion)).cl.c;
            return if idx <= (*func).nupvalues as i32 {
                &mut *((*func).upvalue)
                    .as_mut_ptr()
                    .offset((idx - 1 as i32) as isize) as *mut TValue
            } else {
                &mut (*(*L).l_G).nilvalue
            };
        } else {
            return &mut (*(*L).l_G).nilvalue;
        }
    };
}
#[inline]
unsafe extern "C-unwind" fn index2stack(mut L: *mut lua_State, mut idx: i32) -> StkId {
    let mut ci: *mut CallInfo = (*L).ci;
    if idx > 0 {
        let mut o: StkId = ((*ci).func.p).offset(idx as isize);
        return o;
    } else {
        return ((*L).top.p).offset(idx as isize);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_checkstack(mut L: *mut lua_State, mut n: i32) -> i32 {
    let mut res: i32 = 0;
    let mut ci: *mut CallInfo = 0 as *mut CallInfo;
    ci = (*L).ci;
    if ((*L).stack_last.p).offset_from((*L).top.p) as std::ffi::c_long > n as std::ffi::c_long {
        res = 1 as i32;
    } else {
        res = luaD_growstack(L, n, 0);
    }
    if res != 0 && (*ci).top.p < ((*L).top.p).offset(n as isize) {
        (*ci).top.p = ((*L).top.p).offset(n as isize);
    }
    return res;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_xmove(
    mut from: *mut lua_State,
    mut to: *mut lua_State,
    mut n: i32,
) {
    let mut i: i32 = 0;
    if from == to {
        return;
    }
    (*from).top.p = ((*from).top.p).offset(-(n as isize));
    i = 0;
    while i < n {
        let mut io1: *mut TValue = &mut (*(*to).top.p).val;
        let mut io2: *const TValue = &mut (*((*from).top.p).offset(i as isize)).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (to.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*to).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*to).top.p = ((*to).top.p).offset(1);
        (*to).top.p;
        i += 1;
        i;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_atpanic(
    mut L: *mut lua_State,
    mut panicf: lua_CFunction,
) -> lua_CFunction {
    let mut old: lua_CFunction = None;
    old = (*(*L).l_G).panic;
    (*(*L).l_G).panic = panicf;
    return old;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_version(mut L: *mut lua_State) -> lua_Number {
    return 504 as i32 as lua_Number;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_absindex(mut L: *mut lua_State, mut idx: i32) -> i32 {
    return if idx > 0 || idx <= -(1000000) - 1000 {
        idx
    } else {
        ((*L).top.p).offset_from((*(*L).ci).func.p) as std::ffi::c_long as i32 + idx
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_gettop(mut L: *mut lua_State) -> i32 {
    return ((*L).top.p).offset_from(((*(*L).ci).func.p).offset(1)) as std::ffi::c_long as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_settop(mut L: *mut lua_State, mut idx: i32) {
    let mut ci: *mut CallInfo = 0 as *mut CallInfo;
    let mut func: StkId = 0 as *mut StackValue;
    let mut newtop: StkId = 0 as *mut StackValue;
    let mut diff: ptrdiff_t = 0;
    ci = (*L).ci;
    func = (*ci).func.p;
    if idx >= 0 {
        diff = func.offset(1).offset(idx as isize).offset_from((*L).top.p);
        while diff > 0 as ptrdiff_t {
            let fresh141 = (*L).top.p;
            (*L).top.p = ((*L).top.p).offset(1);
            (*fresh141).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
            diff -= 1;
            diff;
        }
    } else {
        diff = (idx + 1 as i32) as ptrdiff_t;
    }
    newtop = ((*L).top.p).offset(diff as isize);
    if diff < 0 as ptrdiff_t && (*L).tbclist.p >= newtop {
        newtop = luaF_close(L, newtop, -(1 as i32), 0);
    }
    (*L).top.p = newtop;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_closeslot(mut L: *mut lua_State, mut idx: i32) {
    let mut level: StkId = 0 as *mut StackValue;
    level = index2stack(L, idx);
    level = luaF_close(L, level, -(1 as i32), 0);
    (*level).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
}
#[inline]
unsafe extern "C-unwind" fn reverse(mut L: *mut lua_State, mut from: StkId, mut to: StkId) {
    while from < to {
        let mut temp: TValue = TValue {
            value_: Value {
                gc: 0 as *mut GCObject,
            },
            tt_: 0,
        };
        let mut io1: *mut TValue = &mut temp;
        let mut io2: *const TValue = &mut (*from).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        let mut io1_0: *mut TValue = &mut (*from).val;
        let mut io2_0: *const TValue = &mut (*to).val;
        (*io1_0).value_ = (*io2_0).value_;
        (*io1_0).tt_ = (*io2_0).tt_;
        if (*io1_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1_0).tt_ as i32 & 0x3f as i32 == (*(*io1_0).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1_0).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        let mut io1_1: *mut TValue = &mut (*to).val;
        let mut io2_1: *const TValue = &mut temp;
        (*io1_1).value_ = (*io2_1).value_;
        (*io1_1).tt_ = (*io2_1).tt_;
        if (*io1_1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1_1).tt_ as i32 & 0x3f as i32 == (*(*io1_1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1_1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        from = from.offset(1);
        from;
        to = to.offset(-1);
        to;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rotate(mut L: *mut lua_State, mut idx: i32, mut n: i32) {
    let mut p: StkId = 0 as *mut StackValue;
    let mut t: StkId = 0 as *mut StackValue;
    let mut m: StkId = 0 as *mut StackValue;
    t = ((*L).top.p).offset(-(1));
    p = index2stack(L, idx);
    m = if n >= 0 {
        t.offset(-(n as isize))
    } else {
        p.offset(-(n as isize)).offset(-(1))
    };
    reverse(L, p, m);
    reverse(L, m.offset(1), t);
    reverse(L, p, t);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_copy(mut L: *mut lua_State, mut fromidx: i32, mut toidx: i32) {
    let mut fr: *mut TValue = 0 as *mut TValue;
    let mut to: *mut TValue = 0 as *mut TValue;
    fr = index2value(L, fromidx);
    to = index2value(L, toidx);
    let mut io1: *mut TValue = to;
    let mut io2: *const TValue = fr;
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    if toidx < -(1000000) - 1000 {
        if (*fr).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
            if (*(&mut (*((*(*(*L).ci).func.p).val.value_.gc as *mut GCUnion)).cl.c
                as *mut CClosure))
                .marked as i32
                & (1 as i32) << 5 as i32
                != 0
                && (*(*fr).value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                luaC_barrier_(
                    L,
                    &mut (*(&mut (*((*(*(*L).ci).func.p).val.value_.gc as *mut GCUnion)).cl.c
                        as *mut CClosure as *mut GCUnion))
                        .gc,
                    &mut (*((*fr).value_.gc as *mut GCUnion)).gc,
                );
            } else {
            };
        } else {
        };
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushvalue(mut L: *mut lua_State, mut idx: i32) {
    let mut io1: *mut TValue = &mut (*(*L).top.p).val;
    let mut io2: *const TValue = index2value(L, idx);
    (*io1).value_ = (*io2).value_;
    (*io1).tt_ = (*io2).tt_;
    if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io1).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_type(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut o: *const TValue = index2value(L, idx);
    return if !((*o).tt_ as i32 & 0xf as i32 == 0)
        || o != &mut (*(*L).l_G).nilvalue as *mut TValue as *const TValue
    {
        (*o).tt_ as i32 & 0xf as i32
    } else {
        -(1 as i32)
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_typename(
    mut L: *mut lua_State,
    mut t: i32,
) -> *const std::ffi::c_char {
    return luaT_typenames_[(t + 1 as i32) as usize];
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_iscfunction(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut o: *const TValue = index2value(L, idx);
    return ((*o).tt_ as i32 == 6 as i32 | (1 as i32) << 4 as i32
        || (*o).tt_ as i32 == 6 as i32 | (2 as i32) << 4 as i32 | (1 as i32) << 6 as i32)
        as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_isinteger(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut o: *const TValue = index2value(L, idx);
    return ((*o).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_isnumber(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut n: lua_Number = 0.;
    let mut o: *const TValue = index2value(L, idx);
    return if (*o).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
        n = (*o).value_.n;
        1 as i32
    } else {
        luaV_tonumber_(o, &mut n)
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_isstring(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut o: *const TValue = index2value(L, idx);
    return ((*o).tt_ as i32 & 0xf as i32 == 4 as i32 || (*o).tt_ as i32 & 0xf as i32 == 3 as i32)
        as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_isuserdata(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut o: *const TValue = index2value(L, idx);
    return ((*o).tt_ as i32 == 7 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32
        || (*o).tt_ as i32 == 2 as i32 | (0) << 4 as i32) as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawequal(
    mut L: *mut lua_State,
    mut index1: i32,
    mut index2: i32,
) -> i32 {
    let mut o1: *const TValue = index2value(L, index1);
    let mut o2: *const TValue = index2value(L, index2);
    return if (!((*o1).tt_ as i32 & 0xf as i32 == 0)
        || o1 != &mut (*(*L).l_G).nilvalue as *mut TValue as *const TValue)
        && (!((*o2).tt_ as i32 & 0xf as i32 == 0)
            || o2 != &mut (*(*L).l_G).nilvalue as *mut TValue as *const TValue)
    {
        luaV_equalobj(0 as *mut lua_State, o1, o2)
    } else {
        0
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_arith(mut L: *mut lua_State, mut op: i32) {
    if !(op != 12 as i32 && op != 13 as i32) {
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    }
    luaO_arith(
        L,
        op,
        &mut (*((*L).top.p).offset(-(2))).val,
        &mut (*((*L).top.p).offset(-(1))).val,
        ((*L).top.p).offset(-(2)),
    );
    (*L).top.p = ((*L).top.p).offset(-1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_compare(
    mut L: *mut lua_State,
    mut index1: i32,
    mut index2: i32,
    mut op: i32,
) -> i32 {
    let mut o1: *const TValue = 0 as *const TValue;
    let mut o2: *const TValue = 0 as *const TValue;
    let mut i: i32 = 0;
    o1 = index2value(L, index1);
    o2 = index2value(L, index2);
    if (!((*o1).tt_ as i32 & 0xf as i32 == 0)
        || o1 != &mut (*(*L).l_G).nilvalue as *mut TValue as *const TValue)
        && (!((*o2).tt_ as i32 & 0xf as i32 == 0)
            || o2 != &mut (*(*L).l_G).nilvalue as *mut TValue as *const TValue)
    {
        match op {
            0 => {
                i = luaV_equalobj(L, o1, o2);
            }
            1 => {
                i = luaV_lessthan(L, o1, o2);
            }
            2 => {
                i = luaV_lessequal(L, o1, o2);
            }
            _ => {}
        }
    }
    return i;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_stringtonumber(
    mut L: *mut lua_State,
    mut s: *const std::ffi::c_char,
) -> size_t {
    let mut sz: size_t = luaO_str2num(s, &mut (*(*L).top.p).val);
    if sz != 0 as size_t {
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    }
    return sz;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_tonumberx(
    mut L: *mut lua_State,
    mut idx: i32,
    mut pisnum: *mut i32,
) -> lua_Number {
    let mut n: lua_Number = 0 as lua_Number;
    let mut o: *const TValue = index2value(L, idx);
    let mut isnum: i32 = if (*o).tt_ as i32 == 3 as i32 | (1 as i32) << 4 as i32 {
        n = (*o).value_.n;
        1 as i32
    } else {
        luaV_tonumber_(o, &mut n)
    };
    if !pisnum.is_null() {
        *pisnum = isnum;
    }
    return n;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_tointegerx(
    mut L: *mut lua_State,
    mut idx: i32,
    mut pisnum: *mut i32,
) -> lua_Integer {
    let mut res: lua_Integer = 0 as lua_Integer;
    let mut o: *const TValue = index2value(L, idx);
    let mut isnum: i32 = if (((*o).tt_ as i32 == 3 as i32 | (0) << 4 as i32) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
    {
        res = (*o).value_.i;
        1 as i32
    } else {
        luaV_tointeger(o, &mut res, F2Ieq)
    };
    if !pisnum.is_null() {
        *pisnum = isnum;
    }
    return res;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_toboolean(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut o: *const TValue = index2value(L, idx);
    return !((*o).tt_ as i32 == 1 as i32 | (0) << 4 as i32 || (*o).tt_ as i32 & 0xf as i32 == 0)
        as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_tolstring(
    mut L: *mut lua_State,
    mut idx: i32,
    mut len: *mut size_t,
) -> *const std::ffi::c_char {
    let mut o: *mut TValue = 0 as *mut TValue;
    o = index2value(L, idx);
    if !((*o).tt_ as i32 & 0xf as i32 == 4 as i32) {
        if !((*o).tt_ as i32 & 0xf as i32 == 3 as i32) {
            if !len.is_null() {
                *len = 0 as size_t;
            }
            return 0 as *const std::ffi::c_char;
        }
        luaO_tostring(L, o);
        if (*(*L).l_G).GCdebt > 0 as l_mem {
            luaC_step(L);
        }
        o = index2value(L, idx);
    }
    if !len.is_null() {
        *len = if (*(&mut (*((*o).value_.gc as *mut GCUnion)).ts as *mut TString)).shrlen as i32
            != 0xff as i32
        {
            (*&mut (*((*o).value_.gc as *mut GCUnion)).ts).shrlen as size_t
        } else {
            (*&mut (*((*o).value_.gc as *mut GCUnion)).ts).u.lnglen
        };
    }
    return ((*&mut (*((*o).value_.gc as *mut GCUnion)).ts).contents).as_mut_ptr();
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawlen(mut L: *mut lua_State, mut idx: i32) -> lua_Unsigned {
    let mut o: *const TValue = index2value(L, idx);
    match (*o).tt_ as i32 & 0x3f as i32 {
        4 => return (*&mut (*((*o).value_.gc as *mut GCUnion)).ts).shrlen as lua_Unsigned,
        20 => {
            return (*&mut (*((*o).value_.gc as *mut GCUnion)).ts).u.lnglen as lua_Unsigned;
        }
        7 => return (*&mut (*((*o).value_.gc as *mut GCUnion)).u).len as lua_Unsigned,
        5 => return luaH_getn(&mut (*((*o).value_.gc as *mut GCUnion)).h),
        _ => return 0 as lua_Unsigned,
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_tocfunction(
    mut L: *mut lua_State,
    mut idx: i32,
) -> lua_CFunction {
    let mut o: *const TValue = index2value(L, idx);
    if (*o).tt_ as i32 == 6 as i32 | (1 as i32) << 4 as i32 {
        return (*o).value_.f;
    } else if (*o).tt_ as i32 == 6 as i32 | (2 as i32) << 4 as i32 | (1 as i32) << 6 as i32 {
        return (*&mut (*((*o).value_.gc as *mut GCUnion)).cl.c).f;
    } else {
        return None;
    };
}
#[inline]
unsafe extern "C-unwind" fn touserdata(mut o: *const TValue) -> *mut c_void {
    match (*o).tt_ as i32 & 0xf as i32 {
        7 => {
            return (&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata
                as *mut std::ffi::c_char)
                .offset(
                    (if (*(&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata)).nuvalue as i32
                        == 0
                    {
                        32 as usize
                    } else {
                        (40 as usize).wrapping_add(
                            (::core::mem::size_of::<UValue>() as usize).wrapping_mul(
                                (*(&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata))
                                    .nuvalue as usize,
                            ),
                        )
                    }) as isize,
                ) as *mut c_void;
        }
        2 => return (*o).value_.p,
        _ => return 0 as *mut c_void,
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_touserdata(mut L: *mut lua_State, mut idx: i32) -> *mut c_void {
    let mut o: *const TValue = index2value(L, idx);
    return touserdata(o);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_tothread(
    mut L: *mut lua_State,
    mut idx: i32,
) -> *mut lua_State {
    let mut o: *const TValue = index2value(L, idx);
    return if !((*o).tt_ as i32 == 8 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
        0 as *mut lua_State
    } else {
        &mut (*((*o).value_.gc as *mut GCUnion)).th
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_topointer(
    mut L: *mut lua_State,
    mut idx: i32,
) -> *const c_void {
    let mut o: *const TValue = index2value(L, idx);
    match (*o).tt_ as i32 & 0x3f as i32 {
        22 => {
            return ::core::mem::transmute::<lua_CFunction, size_t>((*o).value_.f) as *mut c_void;
        }
        7 | 2 => return touserdata(o),
        _ => {
            if (*o).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                return (*o).value_.gc as *const c_void;
            } else {
                return 0 as *const c_void;
            }
        }
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushnil(mut L: *mut lua_State) {
    (*(*L).top.p).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushnumber(mut L: *mut lua_State, mut n: lua_Number) {
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    (*io).value_.n = n;
    (*io).tt_ = (3 as i32 | (1 as i32) << 4 as i32) as lu_byte;
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushinteger(mut L: *mut lua_State, mut n: lua_Integer) {
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    (*io).value_.i = n;
    (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushlstring(
    mut L: *mut lua_State,
    mut s: *const std::ffi::c_char,
    mut len: size_t,
) -> *const std::ffi::c_char {
    let mut ts: *mut TString = 0 as *mut TString;
    ts = if len == 0 as size_t {
        luaS_new(L, c"".as_ptr())
    } else {
        luaS_newlstr(L, s, len)
    };
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    let mut x_: *mut TString = ts;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
    return ((*ts).contents).as_mut_ptr();
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushstring(
    mut L: *mut lua_State,
    mut s: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    if s.is_null() {
        (*(*L).top.p).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
    } else {
        let mut ts: *mut TString = 0 as *mut TString;
        ts = luaS_new(L, s);
        let mut io: *mut TValue = &mut (*(*L).top.p).val;
        let mut x_: *mut TString = ts;
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        s = ((*ts).contents).as_mut_ptr();
    }
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
    return s;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushvfstring(
    mut L: *mut lua_State,
    mut fmt: *const std::ffi::c_char,
    mut argp: ::core::ffi::VaList,
) -> *const std::ffi::c_char {
    let mut ret: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    ret = luaO_pushvfstring(L, fmt, argp.as_va_list());
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
    return ret;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushfstring(
    mut L: *mut lua_State,
    mut fmt: *const std::ffi::c_char,
    mut args: ...
) -> *const std::ffi::c_char {
    let mut ret: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut argp: ::core::ffi::VaListImpl;
    argp = args.clone();
    ret = luaO_pushvfstring(L, fmt, argp.as_va_list());
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
    return ret;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushcclosure(
    mut L: *mut lua_State,
    mut fn_0: lua_CFunction,
    mut n: i32,
) {
    if n == 0 {
        let mut io: *mut TValue = &mut (*(*L).top.p).val;
        (*io).value_.f = fn_0;
        (*io).tt_ = (6 as i32 | (1 as i32) << 4 as i32) as lu_byte;
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    } else {
        let mut cl: *mut CClosure = 0 as *mut CClosure;
        cl = luaF_newCclosure(L, n);
        (*cl).f = fn_0;
        (*L).top.p = ((*L).top.p).offset(-(n as isize));
        loop {
            let fresh142 = n;
            n = n - 1;
            if !(fresh142 != 0) {
                break;
            }
            let mut io1: *mut TValue =
                &mut *((*cl).upvalue).as_mut_ptr().offset(n as isize) as *mut TValue;
            let mut io2: *const TValue = &mut (*((*L).top.p).offset(n as isize)).val;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
        }
        let mut io_0: *mut TValue = &mut (*(*L).top.p).val;
        let mut x_: *mut CClosure = cl;
        (*io_0).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io_0).tt_ = (6 as i32 | (2 as i32) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io_0).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io_0).tt_ as i32 & 0x3f as i32 == (*(*io_0).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io_0).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
        if (*(*L).l_G).GCdebt > 0 as l_mem {
            luaC_step(L);
        }
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushboolean(mut L: *mut lua_State, mut b: i32) {
    if b != 0 {
        (*(*L).top.p).val.tt_ = (1 as i32 | (1 as i32) << 4 as i32) as lu_byte;
    } else {
        (*(*L).top.p).val.tt_ = (1 as i32 | (0) << 4 as i32) as lu_byte;
    }
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushlightuserdata(mut L: *mut lua_State, mut p: *mut c_void) {
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    (*io).value_.p = p;
    (*io).tt_ = (2 as i32 | (0) << 4 as i32) as lu_byte;
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pushthread(mut L: *mut lua_State) -> i32 {
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    let mut x_: *mut lua_State = L;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (8 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    return ((*(*L).l_G).mainthread == L) as i32;
}
#[inline]
unsafe extern "C-unwind" fn auxgetstr(
    mut L: *mut lua_State,
    mut t: *const TValue,
    mut k: *const std::ffi::c_char,
) -> i32 {
    let mut slot: *const TValue = 0 as *const TValue;
    let mut str: *mut TString = luaS_new(L, k);
    if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
        slot = 0 as *const TValue;
        0
    } else {
        slot = luaH_getstr(&mut (*((*t).value_.gc as *mut GCUnion)).h, str);
        !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
    } != 0
    {
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue = slot;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    } else {
        let mut io: *mut TValue = &mut (*(*L).top.p).val;
        let mut x_: *mut TString = str;
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
        luaV_finishget(
            L,
            t,
            &mut (*((*L).top.p).offset(-(1))).val,
            ((*L).top.p).offset(-(1)),
            slot,
        );
    }
    return (*((*L).top.p).offset(-(1))).val.tt_ as i32 & 0xf as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getglobal(
    mut L: *mut lua_State,
    mut name: *const std::ffi::c_char,
) -> i32 {
    let mut G: *const TValue = 0 as *const TValue;
    G = &mut *((*(&mut (*((*(*L).l_G).l_registry.value_.gc as *mut GCUnion)).h as *mut Table))
        .array)
        .offset((2 as i32 - 1 as i32) as isize) as *mut TValue;
    return auxgetstr(L, G, name);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_gettable(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut slot: *const TValue = 0 as *const TValue;
    let mut t: *mut TValue = 0 as *mut TValue;
    t = index2value(L, idx);
    if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
        slot = 0 as *const TValue;
        0
    } else {
        slot = luaH_get(
            &mut (*((*t).value_.gc as *mut GCUnion)).h,
            &mut (*((*L).top.p).offset(-(1))).val,
        );
        !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
    } != 0
    {
        let mut io1: *mut TValue = &mut (*((*L).top.p).offset(-(1))).val;
        let mut io2: *const TValue = slot;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
    } else {
        luaV_finishget(
            L,
            t,
            &mut (*((*L).top.p).offset(-(1))).val,
            ((*L).top.p).offset(-(1)),
            slot,
        );
    }
    return (*((*L).top.p).offset(-(1))).val.tt_ as i32 & 0xf as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getfield(
    mut L: *mut lua_State,
    mut idx: i32,
    mut k: *const std::ffi::c_char,
) -> i32 {
    return auxgetstr(L, index2value(L, idx), k);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_geti(
    mut L: *mut lua_State,
    mut idx: i32,
    mut n: lua_Integer,
) -> i32 {
    let mut t: *mut TValue = 0 as *mut TValue;
    let mut slot: *const TValue = 0 as *const TValue;
    t = index2value(L, idx);
    if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
        slot = 0 as *const TValue;
        0
    } else {
        slot = (if (n as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned)
            < (*(&mut (*((*t).value_.gc as *mut GCUnion)).h as *mut Table)).alimit as lua_Unsigned
        {
            &mut *((*(&mut (*((*t).value_.gc as *mut GCUnion)).h as *mut Table)).array)
                .offset((n - 1 as i32 as lua_Integer) as isize) as *mut TValue
                as *const TValue
        } else {
            luaH_getint(&mut (*((*t).value_.gc as *mut GCUnion)).h, n)
        });
        !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
    } != 0
    {
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue = slot;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
    } else {
        let mut aux: TValue = TValue {
            value_: Value {
                gc: 0 as *mut GCObject,
            },
            tt_: 0,
        };
        let mut io: *mut TValue = &mut aux;
        (*io).value_.i = n;
        (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
        luaV_finishget(L, t, &mut aux, (*L).top.p, slot);
    }
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    return (*((*L).top.p).offset(-(1))).val.tt_ as i32 & 0xf as i32;
}
#[inline]
unsafe extern "C-unwind" fn finishrawget(mut L: *mut lua_State, mut val: *const TValue) -> i32 {
    if (*val).tt_ as i32 & 0xf as i32 == 0 {
        (*(*L).top.p).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
    } else {
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue = val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
    }
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    return (*((*L).top.p).offset(-(1))).val.tt_ as i32 & 0xf as i32;
}
unsafe extern "C-unwind" fn gettable(mut L: *mut lua_State, mut idx: i32) -> *mut Table {
    let mut t: *mut TValue = index2value(L, idx);
    return &mut (*((*t).value_.gc as *mut GCUnion)).h;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawget(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut t: *mut Table = 0 as *mut Table;
    let mut val: *const TValue = 0 as *const TValue;
    t = gettable(L, idx);
    val = luaH_get(t, &mut (*((*L).top.p).offset(-(1))).val);
    (*L).top.p = ((*L).top.p).offset(-1);
    (*L).top.p;
    return finishrawget(L, val);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawgeti(
    mut L: *mut lua_State,
    mut idx: i32,
    mut n: lua_Integer,
) -> i32 {
    let mut t: *mut Table = 0 as *mut Table;
    t = gettable(L, idx);
    return finishrawget(L, luaH_getint(t, n));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawgetp(
    mut L: *mut lua_State,
    mut idx: i32,
    mut p: *const c_void,
) -> i32 {
    let mut t: *mut Table = 0 as *mut Table;
    let mut k: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    t = gettable(L, idx);
    let mut io: *mut TValue = &mut k;
    (*io).value_.p = p as *mut c_void;
    (*io).tt_ = (2 as i32 | (0) << 4 as i32) as lu_byte;
    return finishrawget(L, luaH_get(t, &mut k));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_createtable(
    mut L: *mut lua_State,
    mut narray: i32,
    mut nrec: i32,
) {
    let mut t: *mut Table = 0 as *mut Table;
    t = luaH_new(L);
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    let mut x_: *mut Table = t;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    if narray > 0 || nrec > 0 {
        luaH_resize(L, t, narray as u32, nrec as u32);
    }
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getmetatable(mut L: *mut lua_State, mut objindex: i32) -> i32 {
    let mut obj: *const TValue = 0 as *const TValue;
    let mut mt: *mut Table = 0 as *mut Table;
    let mut res: i32 = 0;
    obj = index2value(L, objindex);
    match (*obj).tt_ as i32 & 0xf as i32 {
        5 => {
            mt = (*&mut (*((*obj).value_.gc as *mut GCUnion)).h).metatable;
        }
        7 => {
            mt = (*&mut (*((*obj).value_.gc as *mut GCUnion)).u).metatable;
        }
        _ => {
            mt = (*(*L).l_G).mt[((*obj).tt_ as i32 & 0xf as i32) as usize];
        }
    }
    if !mt.is_null() {
        let mut io: *mut TValue = &mut (*(*L).top.p).val;
        let mut x_: *mut Table = mt;
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = (5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
        res = 1 as i32;
    }
    return res;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getiuservalue(
    mut L: *mut lua_State,
    mut idx: i32,
    mut n: i32,
) -> i32 {
    let mut o: *mut TValue = 0 as *mut TValue;
    let mut t: i32 = 0;
    o = index2value(L, idx);
    if n <= 0 || n > (*(&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata)).nuvalue as i32 {
        (*(*L).top.p).val.tt_ = (0 | (0) << 4 as i32) as lu_byte;
        t = -(1 as i32);
    } else {
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue =
            &mut (*((*(&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata)).uv)
                .as_mut_ptr()
                .offset((n - 1 as i32) as isize))
            .uv;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        t = (*(*L).top.p).val.tt_ as i32 & 0xf as i32;
    }
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    return t;
}
unsafe extern "C-unwind" fn auxsetstr(
    mut L: *mut lua_State,
    mut t: *const TValue,
    mut k: *const std::ffi::c_char,
) {
    let mut slot: *const TValue = 0 as *const TValue;
    let mut str: *mut TString = luaS_new(L, k);
    if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
        slot = 0 as *const TValue;
        0
    } else {
        slot = luaH_getstr(&mut (*((*t).value_.gc as *mut GCUnion)).h, str);
        !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
    } != 0
    {
        let mut io1: *mut TValue = slot as *mut TValue;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*L).top.p).offset(-(1))).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
            if (*(*t).value_.gc).marked as i32 & (1 as i32) << 5 as i32 != 0
                && (*(*((*L).top.p).offset(-(1))).val.value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                luaC_barrierback_(L, (*t).value_.gc);
            } else {
            };
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(-1);
        (*L).top.p;
    } else {
        let mut io: *mut TValue = &mut (*(*L).top.p).val;
        let mut x_: *mut TString = str;
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
        luaV_finishset(
            L,
            t,
            &mut (*((*L).top.p).offset(-(1))).val,
            &mut (*((*L).top.p).offset(-(2))).val,
            slot,
        );
        (*L).top.p = ((*L).top.p).offset(-(2));
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setglobal(
    mut L: *mut lua_State,
    mut name: *const std::ffi::c_char,
) {
    let mut G: *const TValue = 0 as *const TValue;
    G = &mut *((*(&mut (*((*(*L).l_G).l_registry.value_.gc as *mut GCUnion)).h as *mut Table))
        .array)
        .offset((2 as i32 - 1 as i32) as isize) as *mut TValue;
    auxsetstr(L, G, name);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_settable(mut L: *mut lua_State, mut idx: i32) {
    let mut t: *mut TValue = 0 as *mut TValue;
    let mut slot: *const TValue = 0 as *const TValue;
    t = index2value(L, idx);
    if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
        slot = 0 as *const TValue;
        0
    } else {
        slot = luaH_get(
            &mut (*((*t).value_.gc as *mut GCUnion)).h,
            &mut (*((*L).top.p).offset(-(2))).val,
        );
        !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
    } != 0
    {
        let mut io1: *mut TValue = slot as *mut TValue;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*L).top.p).offset(-(1))).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
            if (*(*t).value_.gc).marked as i32 & (1 as i32) << 5 as i32 != 0
                && (*(*((*L).top.p).offset(-(1))).val.value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                luaC_barrierback_(L, (*t).value_.gc);
            } else {
            };
        } else {
        };
    } else {
        luaV_finishset(
            L,
            t,
            &mut (*((*L).top.p).offset(-(2))).val,
            &mut (*((*L).top.p).offset(-(1))).val,
            slot,
        );
    }
    (*L).top.p = ((*L).top.p).offset(-(2));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setfield(
    mut L: *mut lua_State,
    mut idx: i32,
    mut k: *const std::ffi::c_char,
) {
    auxsetstr(L, index2value(L, idx), k);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_seti(mut L: *mut lua_State, mut idx: i32, mut n: lua_Integer) {
    let mut t: *mut TValue = 0 as *mut TValue;
    let mut slot: *const TValue = 0 as *const TValue;
    t = index2value(L, idx);
    if if !((*t).tt_ as i32 == 5 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) {
        slot = 0 as *const TValue;
        0
    } else {
        slot = (if (n as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned)
            < (*(&mut (*((*t).value_.gc as *mut GCUnion)).h as *mut Table)).alimit as lua_Unsigned
        {
            &mut *((*(&mut (*((*t).value_.gc as *mut GCUnion)).h as *mut Table)).array)
                .offset((n - 1 as i32 as lua_Integer) as isize) as *mut TValue
                as *const TValue
        } else {
            luaH_getint(&mut (*((*t).value_.gc as *mut GCUnion)).h, n)
        });
        !((*slot).tt_ as i32 & 0xf as i32 == 0) as i32
    } != 0
    {
        let mut io1: *mut TValue = slot as *mut TValue;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*L).top.p).offset(-(1))).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
            if (*(*t).value_.gc).marked as i32 & (1 as i32) << 5 as i32 != 0
                && (*(*((*L).top.p).offset(-(1))).val.value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                luaC_barrierback_(L, (*t).value_.gc);
            } else {
            };
        } else {
        };
    } else {
        let mut aux: TValue = TValue {
            value_: Value {
                gc: 0 as *mut GCObject,
            },
            tt_: 0,
        };
        let mut io: *mut TValue = &mut aux;
        (*io).value_.i = n;
        (*io).tt_ = (3 as i32 | (0) << 4 as i32) as lu_byte;
        luaV_finishset(L, t, &mut aux, &mut (*((*L).top.p).offset(-(1))).val, slot);
    }
    (*L).top.p = ((*L).top.p).offset(-1);
    (*L).top.p;
}
unsafe extern "C-unwind" fn aux_rawset(
    mut L: *mut lua_State,
    mut idx: i32,
    mut key: *mut TValue,
    mut n: i32,
) {
    let mut t: *mut Table = 0 as *mut Table;
    t = gettable(L, idx);
    luaH_set(L, t, key, &mut (*((*L).top.p).offset(-(1))).val);
    (*t).flags = ((*t).flags as u32 & !!(!(0 as u32) << TM_EQ as i32 + 1 as i32)) as lu_byte;
    if (*((*L).top.p).offset(-(1))).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
        if (*(&mut (*(t as *mut GCUnion)).gc as *mut GCObject)).marked as i32
            & (1 as i32) << 5 as i32
            != 0
            && (*(*((*L).top.p).offset(-(1))).val.value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            luaC_barrierback_(L, &mut (*(t as *mut GCUnion)).gc);
        } else {
        };
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(-(n as isize));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawset(mut L: *mut lua_State, mut idx: i32) {
    aux_rawset(L, idx, &mut (*((*L).top.p).offset(-(2))).val, 2 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawsetp(
    mut L: *mut lua_State,
    mut idx: i32,
    mut p: *const c_void,
) {
    let mut k: TValue = TValue {
        value_: Value {
            gc: 0 as *mut GCObject,
        },
        tt_: 0,
    };
    let mut io: *mut TValue = &mut k;
    (*io).value_.p = p as *mut c_void;
    (*io).tt_ = (2 as i32 | (0) << 4 as i32) as lu_byte;
    aux_rawset(L, idx, &mut k, 1 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_rawseti(
    mut L: *mut lua_State,
    mut idx: i32,
    mut n: lua_Integer,
) {
    let mut t: *mut Table = 0 as *mut Table;
    t = gettable(L, idx);
    luaH_setint(L, t, n, &mut (*((*L).top.p).offset(-(1))).val);
    if (*((*L).top.p).offset(-(1))).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
        if (*(&mut (*(t as *mut GCUnion)).gc as *mut GCObject)).marked as i32
            & (1 as i32) << 5 as i32
            != 0
            && (*(*((*L).top.p).offset(-(1))).val.value_.gc).marked as i32
                & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                != 0
        {
            luaC_barrierback_(L, &mut (*(t as *mut GCUnion)).gc);
        } else {
        };
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(-1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setmetatable(mut L: *mut lua_State, mut objindex: i32) -> i32 {
    let mut obj: *mut TValue = 0 as *mut TValue;
    let mut mt: *mut Table = 0 as *mut Table;
    obj = index2value(L, objindex);
    if (*((*L).top.p).offset(-(1))).val.tt_ as i32 & 0xf as i32 == 0 {
        mt = 0 as *mut Table;
    } else {
        mt = &mut (*((*((*L).top.p).offset(-(1))).val.value_.gc as *mut GCUnion)).h;
    }
    match (*obj).tt_ as i32 & 0xf as i32 {
        5 => {
            let ref mut fresh143 = (*&mut (*((*obj).value_.gc as *mut GCUnion)).h).metatable;
            *fresh143 = mt;
            if !mt.is_null() {
                if (*(*obj).value_.gc).marked as i32 & (1 as i32) << 5 as i32 != 0
                    && (*mt).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
                {
                    luaC_barrier_(
                        L,
                        &mut (*((*obj).value_.gc as *mut GCUnion)).gc,
                        &mut (*(mt as *mut GCUnion)).gc,
                    );
                } else {
                };
                luaC_checkfinalizer(L, (*obj).value_.gc, mt);
            }
        }
        7 => {
            let ref mut fresh144 = (*&mut (*((*obj).value_.gc as *mut GCUnion)).u).metatable;
            *fresh144 = mt;
            if !mt.is_null() {
                if (*(&mut (*((*obj).value_.gc as *mut GCUnion)).u as *mut Udata)).marked as i32
                    & (1 as i32) << 5 as i32
                    != 0
                    && (*mt).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
                {
                    luaC_barrier_(
                        L,
                        &mut (*(&mut (*((*obj).value_.gc as *mut GCUnion)).u as *mut Udata
                            as *mut GCUnion))
                            .gc,
                        &mut (*(mt as *mut GCUnion)).gc,
                    );
                } else {
                };
                luaC_checkfinalizer(L, (*obj).value_.gc, mt);
            }
        }
        _ => {
            (*(*L).l_G).mt[((*obj).tt_ as i32 & 0xf as i32) as usize] = mt;
        }
    }
    (*L).top.p = ((*L).top.p).offset(-1);
    (*L).top.p;
    return 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setiuservalue(
    mut L: *mut lua_State,
    mut idx: i32,
    mut n: i32,
) -> i32 {
    let mut o: *mut TValue = 0 as *mut TValue;
    let mut res: i32 = 0;
    o = index2value(L, idx);
    if !((n as u32).wrapping_sub(1 as u32)
        < (*(&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata)).nuvalue as u32)
    {
        res = 0;
    } else {
        let mut io1: *mut TValue =
            &mut (*((*(&mut (*((*o).value_.gc as *mut GCUnion)).u as *mut Udata)).uv)
                .as_mut_ptr()
                .offset((n - 1 as i32) as isize))
            .uv;
        let mut io2: *const TValue = &mut (*((*L).top.p).offset(-(1))).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*((*L).top.p).offset(-(1))).val.tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
            if (*(*o).value_.gc).marked as i32 & (1 as i32) << 5 as i32 != 0
                && (*(*((*L).top.p).offset(-(1))).val.value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                luaC_barrierback_(L, (*o).value_.gc);
            } else {
            };
        } else {
        };
        res = 1 as i32;
    }
    (*L).top.p = ((*L).top.p).offset(-1);
    (*L).top.p;
    return res;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_callk(
    mut L: *mut lua_State,
    mut nargs: i32,
    mut nresults: i32,
    mut ctx: lua_KContext,
    mut k: lua_KFunction,
) {
    let mut func: StkId = 0 as *mut StackValue;
    func = ((*L).top.p).offset(-((nargs + 1 as i32) as isize));
    if k.is_some() && (*L).nCcalls & 0xffff0000 as u32 == 0 as u32 {
        (*(*L).ci).u.c.k = k;
        (*(*L).ci).u.c.ctx = ctx;
        luaD_call(L, func, nresults);
    } else {
        luaD_callnoyield(L, func, nresults);
    }
    if nresults <= -(1 as i32) && (*(*L).ci).top.p < (*L).top.p {
        (*(*L).ci).top.p = (*L).top.p;
    }
}
unsafe extern "C-unwind" fn f_call(mut L: *mut lua_State, mut ud: *mut c_void) {
    let mut c: *mut CallS = ud as *mut CallS;
    luaD_callnoyield(L, (*c).func, (*c).nresults);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_pcallk(
    mut L: *mut lua_State,
    mut nargs: i32,
    mut nresults: i32,
    mut errfunc: i32,
    mut ctx: lua_KContext,
    mut k: lua_KFunction,
) -> i32 {
    let mut c: CallS = CallS {
        func: 0 as *mut StackValue,
        nresults: 0,
    };
    let mut status: i32 = 0;
    let mut func: ptrdiff_t = 0;
    if errfunc == 0 {
        func = 0 as ptrdiff_t;
    } else {
        let mut o: StkId = index2stack(L, errfunc);
        func = (o as *mut std::ffi::c_char).offset_from((*L).stack.p as *mut std::ffi::c_char);
    }
    c.func = ((*L).top.p).offset(-((nargs + 1 as i32) as isize));
    if k.is_none() || !((*L).nCcalls & 0xffff0000 as u32 == 0 as u32) {
        c.nresults = nresults;
        status = luaD_pcall(
            L,
            Some(f_call as unsafe extern "C-unwind" fn(*mut lua_State, *mut c_void) -> ()),
            &mut c as *mut CallS as *mut c_void,
            (c.func as *mut std::ffi::c_char).offset_from((*L).stack.p as *mut std::ffi::c_char),
            func,
        );
    } else {
        let mut ci: *mut CallInfo = (*L).ci;
        (*ci).u.c.k = k;
        (*ci).u.c.ctx = ctx;
        (*ci).u2.funcidx = (c.func as *mut std::ffi::c_char)
            .offset_from((*L).stack.p as *mut std::ffi::c_char)
            as std::ffi::c_long as i32;
        (*ci).u.c.old_errfunc = (*L).errfunc;
        (*L).errfunc = func;
        (*ci).callstatus =
            ((*ci).callstatus as i32 & !((1 as i32) << 0) | (*L).allowhook as i32) as u16;
        (*ci).callstatus = ((*ci).callstatus as i32 | (1 as i32) << 4 as i32) as u16;
        luaD_call(L, c.func, nresults);
        (*ci).callstatus = ((*ci).callstatus as i32 & !((1 as i32) << 4 as i32)) as u16;
        (*L).errfunc = (*ci).u.c.old_errfunc;
        status = 0;
    }
    if nresults <= -(1 as i32) && (*(*L).ci).top.p < (*L).top.p {
        (*(*L).ci).top.p = (*L).top.p;
    }
    return status;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_load(
    mut L: *mut lua_State,
    mut reader: lua_Reader,
    mut data: *mut c_void,
    mut chunkname: *const std::ffi::c_char,
    mut mode: *const std::ffi::c_char,
) -> i32 {
    let mut z: ZIO = Zio {
        n: 0,
        p: 0 as *const std::ffi::c_char,
        reader: None,
        data: 0 as *mut c_void,
        L: 0 as *mut lua_State,
    };
    let mut status: i32 = 0;
    if chunkname.is_null() {
        chunkname = c"?".as_ptr();
    }
    luaZ_init(L, &mut z, reader, data);
    status = luaD_protectedparser(L, &mut z, chunkname, mode);
    if status == 0 {
        let mut f: *mut LClosure = &mut (*((*((*L).top.p).offset(-(1))).val.value_.gc
            as *mut GCUnion))
            .cl
            .l;
        if (*f).nupvalues as i32 >= 1 as i32 {
            let mut gt: *const TValue =
                &mut *((*(&mut (*((*(*L).l_G).l_registry.value_.gc as *mut GCUnion)).h
                    as *mut Table))
                    .array)
                    .offset((2 as i32 - 1 as i32) as isize) as *mut TValue;
            let mut io1: *mut TValue = (**((*f).upvals).as_mut_ptr().offset(0 as isize)).v.p;
            let mut io2: *const TValue = gt;
            (*io1).value_ = (*io2).value_;
            (*io1).tt_ = (*io2).tt_;
            if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
                || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                    && (L.is_null()
                        || (*(*io1).value_.gc).marked as i32
                            & ((*(*L).l_G).currentwhite as i32
                                ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                            == 0)
            {
            } else {
            };
            if (*gt).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
                if (**((*f).upvals).as_mut_ptr().offset(0 as isize)).marked as i32
                    & (1 as i32) << 5 as i32
                    != 0
                    && (*(*gt).value_.gc).marked as i32
                        & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                        != 0
                {
                    luaC_barrier_(
                        L,
                        &mut (*(*((*f).upvals).as_mut_ptr().offset(0 as isize) as *mut GCUnion)).gc,
                        &mut (*((*gt).value_.gc as *mut GCUnion)).gc,
                    );
                } else {
                };
            } else {
            };
        }
    }
    return status;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_dump(
    mut L: *mut lua_State,
    mut writer_0: lua_Writer,
    mut data: *mut c_void,
    mut strip: i32,
) -> i32 {
    let mut status: i32 = 0;
    let mut o: *mut TValue = 0 as *mut TValue;
    o = &mut (*((*L).top.p).offset(-(1))).val;
    if (*o).tt_ as i32 == 6 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32 {
        status = luaU_dump(
            L,
            (*&mut (*((*o).value_.gc as *mut GCUnion)).cl.l).p,
            writer_0,
            data,
            strip,
        );
    } else {
        status = 1 as i32;
    }
    return status;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_status(mut L: *mut lua_State) -> i32 {
    return (*L).status as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_gc(mut L: *mut lua_State, mut what: i32, mut args: ...) -> i32 {
    let mut argp: ::core::ffi::VaListImpl;
    let mut res: i32 = 0;
    let mut g: *mut global_State = (*L).l_G;
    if (*g).gcstp as i32 & 2 as i32 != 0 {
        return -(1 as i32);
    }
    argp = args.clone();
    match what {
        0 => {
            (*g).gcstp = 1 as i32 as lu_byte;
        }
        1 => {
            luaE_setdebt(g, 0 as l_mem);
            (*g).gcstp = 0 as lu_byte;
        }
        2 => {
            luaC_fullgc(L, 0);
        }
        3 => {
            res = (((*g).totalbytes + (*g).GCdebt) as lu_mem >> 10) as i32;
        }
        4 => {
            res = (((*g).totalbytes + (*g).GCdebt) as lu_mem & 0x3ff as i32 as lu_mem) as i32;
        }
        5 => {
            let mut data: i32 = argp.arg::<i32>();
            let mut debt: l_mem = 1 as i32 as l_mem;
            let mut oldstp: lu_byte = (*g).gcstp;
            (*g).gcstp = 0 as lu_byte;
            if data == 0 {
                luaE_setdebt(g, 0 as l_mem);
                luaC_step(L);
            } else {
                debt = data as l_mem * 1024 as i32 as l_mem + (*g).GCdebt;
                luaE_setdebt(g, debt);
                if (*(*L).l_G).GCdebt > 0 as l_mem {
                    luaC_step(L);
                }
            }
            (*g).gcstp = oldstp;
            if debt > 0 as l_mem && (*g).gcstate as i32 == 8 as i32 {
                res = 1 as i32;
            }
        }
        6 => {
            let mut data_0: i32 = argp.arg::<i32>();
            res = (*g).gcpause as i32 * 4 as i32;
            (*g).gcpause = (data_0 / 4 as i32) as lu_byte;
        }
        7 => {
            let mut data_1: i32 = argp.arg::<i32>();
            res = (*g).gcstepmul as i32 * 4 as i32;
            (*g).gcstepmul = (data_1 / 4 as i32) as lu_byte;
        }
        9 => {
            res = ((*g).gcstp as i32 == 0) as i32;
        }
        10 => {
            let mut minormul: i32 = argp.arg::<i32>();
            let mut majormul: i32 = argp.arg::<i32>();
            res = if (*g).gckind as i32 == 1 as i32 || (*g).lastatomic != 0 as lu_mem {
                10
            } else {
                11 as i32
            };
            if minormul != 0 {
                (*g).genminormul = minormul as lu_byte;
            }
            if majormul != 0 {
                (*g).genmajormul = (majormul / 4 as i32) as lu_byte;
            }
            luaC_changemode(L, 1 as i32);
        }
        11 => {
            let mut pause: i32 = argp.arg::<i32>();
            let mut stepmul: i32 = argp.arg::<i32>();
            let mut stepsize: i32 = argp.arg::<i32>();
            res = if (*g).gckind as i32 == 1 as i32 || (*g).lastatomic != 0 as lu_mem {
                10
            } else {
                11 as i32
            };
            if pause != 0 {
                (*g).gcpause = (pause / 4 as i32) as lu_byte;
            }
            if stepmul != 0 {
                (*g).gcstepmul = (stepmul / 4 as i32) as lu_byte;
            }
            if stepsize != 0 {
                (*g).gcstepsize = stepsize as lu_byte;
            }
            luaC_changemode(L, 0);
        }
        _ => {
            res = -(1 as i32);
        }
    }
    return res;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_error(mut L: *mut lua_State) -> i32 {
    let mut errobj: *mut TValue = 0 as *mut TValue;
    errobj = &mut (*((*L).top.p).offset(-(1))).val;
    if (*errobj).tt_ as i32 == 4 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32
        && &mut (*((*errobj).value_.gc as *mut GCUnion)).ts as *mut TString == (*(*L).l_G).memerrmsg
    {
        luaD_throw(L, 4 as i32);
    } else {
        luaG_errormsg(L);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_next(mut L: *mut lua_State, mut idx: i32) -> i32 {
    let mut t: *mut Table = 0 as *mut Table;
    let mut more: i32 = 0;
    t = gettable(L, idx);
    more = luaH_next(L, t, ((*L).top.p).offset(-(1)));
    if more != 0 {
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    } else {
        (*L).top.p = ((*L).top.p).offset(-(1));
    }
    return more;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_toclose(mut L: *mut lua_State, mut idx: i32) {
    let mut nresults: i32 = 0;
    let mut o: StkId = 0 as *mut StackValue;
    o = index2stack(L, idx);
    nresults = (*(*L).ci).nresults as i32;
    luaF_newtbcupval(L, o);
    if !(nresults < -(1 as i32)) {
        (*(*L).ci).nresults = (-nresults - 3 as i32) as std::ffi::c_short;
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_concat(mut L: *mut lua_State, mut n: i32) {
    if n > 0 {
        luaV_concat(L, n);
    } else {
        let mut io: *mut TValue = &mut (*(*L).top.p).val;
        let mut x_: *mut TString = luaS_newlstr(L, c"".as_ptr(), 0 as size_t);
        (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
        (*io).tt_ = ((*x_).tt as i32 | (1 as i32) << 6 as i32) as lu_byte;
        if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    }
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_len(mut L: *mut lua_State, mut idx: i32) {
    let mut t: *mut TValue = 0 as *mut TValue;
    t = index2value(L, idx);
    luaV_objlen(L, (*L).top.p, t);
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getallocf(
    mut L: *mut lua_State,
    mut ud: *mut *mut c_void,
) -> lua_Alloc {
    let mut f: lua_Alloc = None;
    if !ud.is_null() {
        *ud = (*(*L).l_G).ud;
    }
    f = (*(*L).l_G).frealloc;
    return f;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setallocf(
    mut L: *mut lua_State,
    mut f: lua_Alloc,
    mut ud: *mut c_void,
) {
    (*(*L).l_G).ud = ud;
    (*(*L).l_G).frealloc = f;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setwarnf(
    mut L: *mut lua_State,
    mut f: lua_WarnFunction,
    mut ud: *mut c_void,
) {
    (*(*L).l_G).ud_warn = ud;
    (*(*L).l_G).warnf = f;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_warning(
    mut L: *mut lua_State,
    mut msg: *const std::ffi::c_char,
    mut tocont: i32,
) {
    luaE_warning(L, msg, tocont);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_newuserdatauv(
    mut L: *mut lua_State,
    mut size: size_t,
    mut nuvalue: i32,
) -> *mut c_void {
    let mut u: *mut Udata = 0 as *mut Udata;
    u = luaS_newudata(L, size, nuvalue);
    let mut io: *mut TValue = &mut (*(*L).top.p).val;
    let mut x_: *mut Udata = u;
    (*io).value_.gc = &mut (*(x_ as *mut GCUnion)).gc;
    (*io).tt_ = (7 as i32 | (0) << 4 as i32 | (1 as i32) << 6 as i32) as lu_byte;
    if (*io).tt_ as i32 & (1 as i32) << 6 as i32 == 0
        || (*io).tt_ as i32 & 0x3f as i32 == (*(*io).value_.gc).tt as i32
            && (L.is_null()
                || (*(*io).value_.gc).marked as i32
                    & ((*(*L).l_G).currentwhite as i32
                        ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                    == 0)
    {
    } else {
    };
    (*L).top.p = ((*L).top.p).offset(1);
    (*L).top.p;
    if (*(*L).l_G).GCdebt > 0 as l_mem {
        luaC_step(L);
    }
    return (u as *mut std::ffi::c_char).offset(
        (if (*u).nuvalue as i32 == 0 {
            32 as usize
        } else {
            (40 as usize).wrapping_add(
                (::core::mem::size_of::<UValue>() as usize).wrapping_mul((*u).nuvalue as usize),
            )
        }) as isize,
    ) as *mut c_void;
}
unsafe extern "C-unwind" fn aux_upvalue(
    mut fi: *mut TValue,
    mut n: i32,
    mut val: *mut *mut TValue,
    mut owner: *mut *mut GCObject,
) -> *const std::ffi::c_char {
    match (*fi).tt_ as i32 & 0x3f as i32 {
        38 => {
            let mut f: *mut CClosure = &mut (*((*fi).value_.gc as *mut GCUnion)).cl.c;
            if !((n as u32).wrapping_sub(1 as u32) < (*f).nupvalues as u32) {
                return 0 as *const std::ffi::c_char;
            }
            *val = &mut *((*f).upvalue).as_mut_ptr().offset((n - 1 as i32) as isize) as *mut TValue;
            if !owner.is_null() {
                *owner = &mut (*(f as *mut GCUnion)).gc;
            }
            return c"".as_ptr();
        }
        6 => {
            let mut f_0: *mut LClosure = &mut (*((*fi).value_.gc as *mut GCUnion)).cl.l;
            let mut name: *mut TString = 0 as *mut TString;
            let mut p: *mut Proto = (*f_0).p;
            if !((n as u32).wrapping_sub(1 as u32) < (*p).sizeupvalues as u32) {
                return 0 as *const std::ffi::c_char;
            }
            *val = (**((*f_0).upvals).as_mut_ptr().offset((n - 1 as i32) as isize))
                .v
                .p;
            if !owner.is_null() {
                *owner = &mut (*(*((*f_0).upvals).as_mut_ptr().offset((n - 1 as i32) as isize)
                    as *mut GCUnion))
                    .gc;
            }
            name = (*((*p).upvalues).offset((n - 1 as i32) as isize)).name;
            return if name.is_null() {
                c"(no name)".as_ptr()
            } else {
                ((*name).contents).as_mut_ptr() as *const std::ffi::c_char
            };
        }
        _ => return 0 as *const std::ffi::c_char,
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_getupvalue(
    mut L: *mut lua_State,
    mut funcindex: i32,
    mut n: i32,
) -> *const std::ffi::c_char {
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut val: *mut TValue = 0 as *mut TValue;
    name = aux_upvalue(
        index2value(L, funcindex),
        n,
        &mut val,
        0 as *mut *mut GCObject,
    );
    if !name.is_null() {
        let mut io1: *mut TValue = &mut (*(*L).top.p).val;
        let mut io2: *const TValue = val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        (*L).top.p = ((*L).top.p).offset(1);
        (*L).top.p;
    }
    return name;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_setupvalue(
    mut L: *mut lua_State,
    mut funcindex: i32,
    mut n: i32,
) -> *const std::ffi::c_char {
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut val: *mut TValue = 0 as *mut TValue;
    let mut owner: *mut GCObject = 0 as *mut GCObject;
    let mut fi: *mut TValue = 0 as *mut TValue;
    fi = index2value(L, funcindex);
    name = aux_upvalue(fi, n, &mut val, &mut owner);
    if !name.is_null() {
        (*L).top.p = ((*L).top.p).offset(-1);
        (*L).top.p;
        let mut io1: *mut TValue = val;
        let mut io2: *const TValue = &mut (*(*L).top.p).val;
        (*io1).value_ = (*io2).value_;
        (*io1).tt_ = (*io2).tt_;
        if (*io1).tt_ as i32 & (1 as i32) << 6 as i32 == 0
            || (*io1).tt_ as i32 & 0x3f as i32 == (*(*io1).value_.gc).tt as i32
                && (L.is_null()
                    || (*(*io1).value_.gc).marked as i32
                        & ((*(*L).l_G).currentwhite as i32
                            ^ ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32))
                        == 0)
        {
        } else {
        };
        if (*val).tt_ as i32 & (1 as i32) << 6 as i32 != 0 {
            if (*owner).marked as i32 & (1 as i32) << 5 as i32 != 0
                && (*(*val).value_.gc).marked as i32
                    & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32)
                    != 0
            {
                luaC_barrier_(
                    L,
                    &mut (*(owner as *mut GCUnion)).gc,
                    &mut (*((*val).value_.gc as *mut GCUnion)).gc,
                );
            } else {
            };
        } else {
        };
    }
    return name;
}
unsafe extern "C-unwind" fn getupvalref(
    mut L: *mut lua_State,
    mut fidx: i32,
    mut n: i32,
    mut pf: *mut *mut LClosure,
) -> *mut *mut UpVal {
    static mut nullup: *const UpVal = 0 as *const UpVal;
    let mut f: *mut LClosure = 0 as *mut LClosure;
    let mut fi: *mut TValue = index2value(L, fidx);
    f = &mut (*((*fi).value_.gc as *mut GCUnion)).cl.l;
    if !pf.is_null() {
        *pf = f;
    }
    if 1 as i32 <= n && n <= (*(*f).p).sizeupvalues {
        return &mut *((*f).upvals).as_mut_ptr().offset((n - 1 as i32) as isize) as *mut *mut UpVal;
    } else {
        return &raw const nullup as *const *const UpVal as *mut *mut UpVal;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_upvalueid(
    mut L: *mut lua_State,
    mut fidx: i32,
    mut n: i32,
) -> *mut c_void {
    let mut fi: *mut TValue = index2value(L, fidx);
    match (*fi).tt_ as i32 & 0x3f as i32 {
        6 => {
            return *getupvalref(L, fidx, n, 0 as *mut *mut LClosure) as *mut c_void;
        }
        38 => {
            let mut f: *mut CClosure = &mut (*((*fi).value_.gc as *mut GCUnion)).cl.c;
            if 1 as i32 <= n && n <= (*f).nupvalues as i32 {
                return &mut *((*f).upvalue).as_mut_ptr().offset((n - 1 as i32) as isize)
                    as *mut TValue as *mut c_void;
            }
        }
        22 => {}
        _ => return 0 as *mut c_void,
    }
    return 0 as *mut c_void;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn lua_upvaluejoin(
    mut L: *mut lua_State,
    mut fidx1: i32,
    mut n1: i32,
    mut fidx2: i32,
    mut n2: i32,
) {
    let mut f1: *mut LClosure = 0 as *mut LClosure;
    let mut up1: *mut *mut UpVal = getupvalref(L, fidx1, n1, &mut f1);
    let mut up2: *mut *mut UpVal = getupvalref(L, fidx2, n2, 0 as *mut *mut LClosure);
    *up1 = *up2;
    if (*f1).marked as i32 & (1 as i32) << 5 as i32 != 0
        && (**up1).marked as i32 & ((1 as i32) << 3 as i32 | (1 as i32) << 4 as i32) != 0
    {
        luaC_barrier_(
            L,
            &mut (*(f1 as *mut GCUnion)).gc,
            &mut (*(*up1 as *mut GCUnion)).gc,
        );
    } else {
    };
}
unsafe extern "C-unwind" fn findfield(
    mut L: *mut lua_State,
    mut objidx: i32,
    mut level: i32,
) -> i32 {
    if level == 0 || !(lua_type(L, -(1 as i32)) == 5 as i32) {
        return 0;
    }
    lua_pushnil(L);
    while lua_next(L, -(2 as i32)) != 0 {
        if lua_type(L, -(2 as i32)) == 4 as i32 {
            if lua_rawequal(L, objidx, -(1 as i32)) != 0 {
                lua_settop(L, -(1 as i32) - 1 as i32);
                return 1 as i32;
            } else if findfield(L, objidx, level - 1 as i32) != 0 {
                lua_pushstring(L, c".".as_ptr());
                lua_copy(L, -(1 as i32), -(3 as i32));
                lua_settop(L, -(1 as i32) - 1 as i32);
                lua_concat(L, 3 as i32);
                return 1 as i32;
            }
        }
        lua_settop(L, -(1 as i32) - 1 as i32);
    }
    return 0;
}
unsafe extern "C-unwind" fn pushglobalfuncname(
    mut L: *mut lua_State,
    mut ar: *mut lua_Debug,
) -> i32 {
    let mut top: i32 = lua_gettop(L);
    lua_getinfo(L, c"f".as_ptr(), ar);
    lua_getfield(L, -(1000000) - 1000, c"_LOADED".as_ptr());
    luaL_checkstack(L, 6 as i32, c"not enough stack".as_ptr());
    if findfield(L, top + 1 as i32, 2 as i32) != 0 {
        let mut name: *const std::ffi::c_char = lua_tolstring(L, -(1 as i32), 0 as *mut size_t);
        if strncmp(name, c"_G.".as_ptr(), 3) == 0 {
            lua_pushstring(L, name.offset(3));
            lua_rotate(L, -(2 as i32), -(1 as i32));
            lua_settop(L, -(1 as i32) - 1 as i32);
        }
        lua_copy(L, -(1 as i32), top + 1 as i32);
        lua_settop(L, top + 1 as i32);
        return 1 as i32;
    } else {
        lua_settop(L, top);
        return 0;
    };
}
unsafe extern "C-unwind" fn pushfuncname(mut L: *mut lua_State, mut ar: *mut lua_Debug) {
    if pushglobalfuncname(L, ar) != 0 {
        lua_pushfstring(
            L,
            c"function '%s'".as_ptr(),
            lua_tolstring(L, -(1 as i32), 0 as *mut size_t),
        );
        lua_rotate(L, -(2 as i32), -(1 as i32));
        lua_settop(L, -(1 as i32) - 1 as i32);
    } else if *(*ar).namewhat as i32 != '\0' as i32 {
        lua_pushfstring(L, c"%s '%s'".as_ptr(), (*ar).namewhat, (*ar).name);
    } else if *(*ar).what as i32 == 'm' as i32 {
        lua_pushstring(L, c"main chunk".as_ptr());
    } else if *(*ar).what as i32 != 'C' as i32 {
        lua_pushfstring(
            L,
            c"function <%s:%d>".as_ptr(),
            ((*ar).short_src).as_mut_ptr(),
            (*ar).linedefined,
        );
    } else {
        lua_pushstring(L, c"?".as_ptr());
    };
}
unsafe extern "C-unwind" fn lastlevel(mut L: *mut lua_State) -> i32 {
    let mut ar: lua_Debug = lua_Debug {
        event: 0,
        name: 0 as *const std::ffi::c_char,
        namewhat: 0 as *const std::ffi::c_char,
        what: 0 as *const std::ffi::c_char,
        source: 0 as *const std::ffi::c_char,
        srclen: 0,
        currentline: 0,
        linedefined: 0,
        lastlinedefined: 0,
        nups: 0,
        nparams: 0,
        isvararg: 0,
        istailcall: 0,
        ftransfer: 0,
        ntransfer: 0,
        short_src: [0; 60],
        i_ci: 0 as *mut CallInfo,
    };
    let mut li: i32 = 1 as i32;
    let mut le: i32 = 1 as i32;
    while lua_getstack(L, le, &mut ar) != 0 {
        li = le;
        le *= 2 as i32;
    }
    while li < le {
        let mut m: i32 = (li + le) / 2 as i32;
        if lua_getstack(L, m, &mut ar) != 0 {
            li = m + 1 as i32;
        } else {
            le = m;
        }
    }
    return le - 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_traceback(
    mut L: *mut lua_State,
    mut L1: *mut lua_State,
    mut msg: *const std::ffi::c_char,
    mut level: i32,
) {
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut ar: lua_Debug = lua_Debug {
        event: 0,
        name: 0 as *const std::ffi::c_char,
        namewhat: 0 as *const std::ffi::c_char,
        what: 0 as *const std::ffi::c_char,
        source: 0 as *const std::ffi::c_char,
        srclen: 0,
        currentline: 0,
        linedefined: 0,
        lastlinedefined: 0,
        nups: 0,
        nparams: 0,
        isvararg: 0,
        istailcall: 0,
        ftransfer: 0,
        ntransfer: 0,
        short_src: [0; 60],
        i_ci: 0 as *mut CallInfo,
    };
    let mut last: i32 = lastlevel(L1);
    let mut limit2show: i32 = if last - level > 10 + 11 as i32 {
        10
    } else {
        -(1 as i32)
    };
    luaL_buffinit(L, &mut b);
    if !msg.is_null() {
        luaL_addstring(&mut b, msg);
        (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
        let fresh145 = b.n;
        b.n = (b.n).wrapping_add(1);
        *(b.b).offset(fresh145 as isize) = '\n' as i32 as std::ffi::c_char;
    }
    luaL_addstring(&mut b, c"stack traceback:".as_ptr());
    loop {
        let fresh146 = level;
        level = level + 1;
        if !(lua_getstack(L1, fresh146, &mut ar) != 0) {
            break;
        }
        let fresh147 = limit2show;
        limit2show = limit2show - 1;
        if fresh147 == 0 {
            let mut n: i32 = last - level - 11 as i32 + 1 as i32;
            lua_pushfstring(L, c"\n\t...\t(skipping %d levels)".as_ptr(), n);
            luaL_addvalue(&mut b);
            level += n;
        } else {
            lua_getinfo(L1, c"Slnt".as_ptr(), &mut ar);
            if ar.currentline <= 0 {
                lua_pushfstring(L, c"\n\t%s: in ".as_ptr(), (ar.short_src).as_mut_ptr());
            } else {
                lua_pushfstring(
                    L,
                    c"\n\t%s:%d: in ".as_ptr(),
                    (ar.short_src).as_mut_ptr(),
                    ar.currentline,
                );
            }
            luaL_addvalue(&mut b);
            pushfuncname(L, &mut ar);
            luaL_addvalue(&mut b);
            if ar.istailcall != 0 {
                luaL_addstring(&mut b, c"\n\t(...tail calls...)".as_ptr());
            }
        }
    }
    luaL_pushresult(&mut b);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_argerror(
    mut L: *mut lua_State,
    mut arg: i32,
    mut extramsg: *const std::ffi::c_char,
) -> i32 {
    let mut ar: lua_Debug = lua_Debug {
        event: 0,
        name: 0 as *const std::ffi::c_char,
        namewhat: 0 as *const std::ffi::c_char,
        what: 0 as *const std::ffi::c_char,
        source: 0 as *const std::ffi::c_char,
        srclen: 0,
        currentline: 0,
        linedefined: 0,
        lastlinedefined: 0,
        nups: 0,
        nparams: 0,
        isvararg: 0,
        istailcall: 0,
        ftransfer: 0,
        ntransfer: 0,
        short_src: [0; 60],
        i_ci: 0 as *mut CallInfo,
    };
    if lua_getstack(L, 0, &mut ar) == 0 {
        return luaL_error(L, c"bad argument #%d (%s)".as_ptr(), arg, extramsg);
    }
    lua_getinfo(L, c"n".as_ptr(), &mut ar);
    if strcmp(ar.namewhat, c"method".as_ptr()) == 0 {
        arg -= 1;
        arg;
        if arg == 0 {
            return luaL_error(
                L,
                c"calling '%s' on bad self (%s)".as_ptr(),
                ar.name,
                extramsg,
            );
        }
    }
    if (ar.name).is_null() {
        ar.name = if pushglobalfuncname(L, &mut ar) != 0 {
            lua_tolstring(L, -(1 as i32), 0 as *mut size_t)
        } else {
            c"?".as_ptr()
        };
    }
    return luaL_error(
        L,
        c"bad argument #%d to '%s' (%s)".as_ptr(),
        arg,
        ar.name,
        extramsg,
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_typeerror(
    mut L: *mut lua_State,
    mut arg: i32,
    mut tname: *const std::ffi::c_char,
) -> i32 {
    let mut msg: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut typearg: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if luaL_getmetafield(L, arg, c"__name".as_ptr()) == 4 as i32 {
        typearg = lua_tolstring(L, -(1 as i32), 0 as *mut size_t);
    } else if lua_type(L, arg) == 2 as i32 {
        typearg = c"light userdata".as_ptr();
    } else {
        typearg = lua_typename(L, lua_type(L, arg));
    }
    msg = lua_pushfstring(L, c"%s expected, got %s".as_ptr(), tname, typearg);
    return luaL_argerror(L, arg, msg);
}
unsafe extern "C-unwind" fn tag_error(mut L: *mut lua_State, mut arg: i32, mut tag: i32) {
    luaL_typeerror(L, arg, lua_typename(L, tag));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_where(mut L: *mut lua_State, mut level: i32) {
    let mut ar: lua_Debug = lua_Debug {
        event: 0,
        name: 0 as *const std::ffi::c_char,
        namewhat: 0 as *const std::ffi::c_char,
        what: 0 as *const std::ffi::c_char,
        source: 0 as *const std::ffi::c_char,
        srclen: 0,
        currentline: 0,
        linedefined: 0,
        lastlinedefined: 0,
        nups: 0,
        nparams: 0,
        isvararg: 0,
        istailcall: 0,
        ftransfer: 0,
        ntransfer: 0,
        short_src: [0; 60],
        i_ci: 0 as *mut CallInfo,
    };
    if lua_getstack(L, level, &mut ar) != 0 {
        lua_getinfo(L, c"Sl".as_ptr(), &mut ar);
        if ar.currentline > 0 {
            lua_pushfstring(
                L,
                c"%s:%d: ".as_ptr(),
                (ar.short_src).as_mut_ptr(),
                ar.currentline,
            );
            return;
        }
    }
    lua_pushfstring(L, c"".as_ptr());
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_error(
    mut L: *mut lua_State,
    mut fmt: *const std::ffi::c_char,
    mut args: ...
) -> i32 {
    let mut argp: ::core::ffi::VaListImpl;
    argp = args.clone();
    luaL_where(L, 1 as i32);
    lua_pushvfstring(L, fmt, argp.as_va_list());
    lua_concat(L, 2 as i32);
    return lua_error(L);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_fileresult(
    mut L: *mut lua_State,
    mut stat: i32,
    mut fname: *const std::ffi::c_char,
) -> i32 {
    let mut en: i32 = *__errno_location();
    if stat != 0 {
        lua_pushboolean(L, 1 as i32);
        return 1 as i32;
    } else {
        let mut msg: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
        lua_pushnil(L);
        msg = if en != 0 {
            strerror(en) as *const std::ffi::c_char
        } else {
            c"(no extra info)".as_ptr()
        };
        if !fname.is_null() {
            lua_pushfstring(L, c"%s: %s".as_ptr(), fname, msg);
        } else {
            lua_pushstring(L, msg);
        }
        lua_pushinteger(L, en as lua_Integer);
        return 3 as i32;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_execresult(mut L: *mut lua_State, mut stat: i32) -> i32 {
    if stat != 0 && *__errno_location() != 0 {
        return luaL_fileresult(L, 0, 0 as *const std::ffi::c_char);
    } else {
        let mut what: *const std::ffi::c_char = c"exit".as_ptr();
        if stat & 0x7f as i32 == 0 {
            stat = (stat & 0xff00) >> 8 as i32;
        } else if ((stat & 0x7f as i32) + 1 as i32) as std::ffi::c_schar as i32 >> 1 as i32 > 0 {
            stat = stat & 0x7f as i32;
            what = c"signal".as_ptr();
        }
        if *what as i32 == 'e' as i32 && stat == 0 {
            lua_pushboolean(L, 1 as i32);
        } else {
            lua_pushnil(L);
        }
        lua_pushstring(L, what);
        lua_pushinteger(L, stat as lua_Integer);
        return 3 as i32;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_newmetatable(
    mut L: *mut lua_State,
    mut tname: *const std::ffi::c_char,
) -> i32 {
    if lua_getfield(L, -(1000000) - 1000, tname) != 0 {
        return 0;
    }
    lua_settop(L, -(1 as i32) - 1 as i32);
    lua_createtable(L, 0, 2 as i32);
    lua_pushstring(L, tname);
    lua_setfield(L, -(2 as i32), c"__name".as_ptr());
    lua_pushvalue(L, -(1 as i32));
    lua_setfield(L, -(1000000) - 1000, tname);
    return 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_setmetatable(
    mut L: *mut lua_State,
    mut tname: *const std::ffi::c_char,
) {
    lua_getfield(L, -(1000000) - 1000, tname);
    lua_setmetatable(L, -(2 as i32));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_testudata(
    mut L: *mut lua_State,
    mut ud: i32,
    mut tname: *const std::ffi::c_char,
) -> *mut c_void {
    let mut p: *mut c_void = lua_touserdata(L, ud);
    if !p.is_null() {
        if lua_getmetatable(L, ud) != 0 {
            lua_getfield(L, -(1000000) - 1000, tname);
            if lua_rawequal(L, -(1 as i32), -(2 as i32)) == 0 {
                p = 0 as *mut c_void;
            }
            lua_settop(L, -(2 as i32) - 1 as i32);
            return p;
        }
    }
    return 0 as *mut c_void;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checkudata(
    mut L: *mut lua_State,
    mut ud: i32,
    mut tname: *const std::ffi::c_char,
) -> *mut c_void {
    let mut p: *mut c_void = luaL_testudata(L, ud, tname);
    (((p != 0 as *mut c_void) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_typeerror(L, ud, tname) != 0) as i32;
    return p;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checkoption(
    mut L: *mut lua_State,
    mut arg: i32,
    mut def: *const std::ffi::c_char,
    mut lst: *const *const std::ffi::c_char,
) -> i32 {
    let mut name: *const std::ffi::c_char = if !def.is_null() {
        luaL_optlstring(L, arg, def, 0 as *mut size_t)
    } else {
        luaL_checklstring(L, arg, 0 as *mut size_t)
    };
    let mut i: i32 = 0;
    i = 0;
    while !(*lst.offset(i as isize)).is_null() {
        if strcmp(*lst.offset(i as isize), name) == 0 {
            return i;
        }
        i += 1;
        i;
    }
    return luaL_argerror(
        L,
        arg,
        lua_pushfstring(L, c"invalid option '%s'".as_ptr(), name),
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checkstack(
    mut L: *mut lua_State,
    mut space: i32,
    mut msg: *const std::ffi::c_char,
) {
    if ((lua_checkstack(L, space) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        if !msg.is_null() {
            luaL_error(L, c"stack overflow (%s)".as_ptr(), msg);
        } else {
            luaL_error(L, c"stack overflow".as_ptr());
        }
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checktype(mut L: *mut lua_State, mut arg: i32, mut t: i32) {
    if ((lua_type(L, arg) != t) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        tag_error(L, arg, t);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checkany(mut L: *mut lua_State, mut arg: i32) {
    if ((lua_type(L, arg) == -(1 as i32)) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_argerror(L, arg, c"value expected".as_ptr());
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checklstring(
    mut L: *mut lua_State,
    mut arg: i32,
    mut len: *mut size_t,
) -> *const std::ffi::c_char {
    let mut s: *const std::ffi::c_char = lua_tolstring(L, arg, len);
    if (s.is_null() as i32 != 0) as i32 as std::ffi::c_long != 0 {
        tag_error(L, arg, 4 as i32);
    }
    return s;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_optlstring(
    mut L: *mut lua_State,
    mut arg: i32,
    mut def: *const std::ffi::c_char,
    mut len: *mut size_t,
) -> *const std::ffi::c_char {
    if lua_type(L, arg) <= 0 {
        if !len.is_null() {
            *len = if !def.is_null() {
                strlen(def)
            } else {
                0 as usize
            };
        }
        return def;
    } else {
        return luaL_checklstring(L, arg, len);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checknumber(
    mut L: *mut lua_State,
    mut arg: i32,
) -> lua_Number {
    let mut isnum: i32 = 0;
    let mut d: lua_Number = lua_tonumberx(L, arg, &mut isnum);
    if ((isnum == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        tag_error(L, arg, 3 as i32);
    }
    return d;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_optnumber(
    mut L: *mut lua_State,
    mut arg: i32,
    mut def: lua_Number,
) -> lua_Number {
    return if lua_type(L, arg) <= 0 {
        def
    } else {
        luaL_checknumber(L, arg)
    };
}
unsafe extern "C-unwind" fn interror(mut L: *mut lua_State, mut arg: i32) {
    if lua_isnumber(L, arg) != 0 {
        luaL_argerror(L, arg, c"number has no integer representation".as_ptr());
    } else {
        tag_error(L, arg, 3 as i32);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checkinteger(
    mut L: *mut lua_State,
    mut arg: i32,
) -> lua_Integer {
    let mut isnum: i32 = 0;
    let mut d: lua_Integer = lua_tointegerx(L, arg, &mut isnum);
    if ((isnum == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        interror(L, arg);
    }
    return d;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_optinteger(
    mut L: *mut lua_State,
    mut arg: i32,
    mut def: lua_Integer,
) -> lua_Integer {
    return if lua_type(L, arg) <= 0 {
        def
    } else {
        luaL_checkinteger(L, arg)
    };
}
unsafe extern "C-unwind" fn resizebox(
    mut L: *mut lua_State,
    mut idx: i32,
    mut newsize: size_t,
) -> *mut c_void {
    let mut ud: *mut c_void = 0 as *mut c_void;
    let mut allocf: lua_Alloc = lua_getallocf(L, &mut ud);
    let mut box_0: *mut UBox = lua_touserdata(L, idx) as *mut UBox;
    let mut temp: *mut c_void =
        allocf.expect("non-null function pointer")(ud, (*box_0).box_0, (*box_0).bsize, newsize);
    if ((temp.is_null() && newsize > 0 as size_t) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushstring(L, c"not enough memory".as_ptr());
        lua_error(L);
    }
    (*box_0).box_0 = temp;
    (*box_0).bsize = newsize;
    return temp;
}
unsafe extern "C-unwind" fn boxgc(mut L: *mut lua_State) -> i32 {
    resizebox(L, 1 as i32, 0 as size_t);
    return 0;
}
static mut boxmt: [luaL_Reg; 3] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"__gc".as_ptr(),
                func: Some(boxgc as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__close".as_ptr(),
                func: Some(boxgc as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
unsafe extern "C-unwind" fn newbox(mut L: *mut lua_State) {
    let mut box_0: *mut UBox =
        lua_newuserdatauv(L, ::core::mem::size_of::<UBox>() as usize, 0) as *mut UBox;
    (*box_0).box_0 = 0 as *mut c_void;
    (*box_0).bsize = 0 as size_t;
    if luaL_newmetatable(L, c"_UBOX*".as_ptr()) != 0 {
        luaL_setfuncs(L, (&raw const boxmt).cast(), 0);
    }
    lua_setmetatable(L, -(2 as i32));
}
unsafe extern "C-unwind" fn newbuffsize(mut B: *mut luaL_Buffer, mut sz: size_t) -> size_t {
    let mut newsize: size_t = (*B).size / 2 as i32 as size_t * 3 as i32 as size_t;
    if (((!(0 as size_t)).wrapping_sub(sz) < (*B).n) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        return luaL_error((*B).L, c"buffer too large".as_ptr()) as size_t;
    }
    if newsize < ((*B).n).wrapping_add(sz) {
        newsize = ((*B).n).wrapping_add(sz);
    }
    return newsize;
}
unsafe extern "C-unwind" fn prepbuffsize(
    mut B: *mut luaL_Buffer,
    mut sz: size_t,
    mut boxidx: i32,
) -> *mut std::ffi::c_char {
    if ((*B).size).wrapping_sub((*B).n) >= sz {
        return ((*B).b).offset((*B).n as isize);
    } else {
        let mut L: *mut lua_State = (*B).L;
        let mut newbuff: *mut std::ffi::c_char = 0 as *mut std::ffi::c_char;
        let mut newsize: size_t = newbuffsize(B, sz);
        if (*B).b != ((*B).init.b).as_mut_ptr() {
            newbuff = resizebox(L, boxidx, newsize) as *mut std::ffi::c_char;
        } else {
            lua_rotate(L, boxidx, -(1 as i32));
            lua_settop(L, -(1 as i32) - 1 as i32);
            newbox(L);
            lua_rotate(L, boxidx, 1 as i32);
            lua_toclose(L, boxidx);
            newbuff = resizebox(L, boxidx, newsize) as *mut std::ffi::c_char;
            memcpy(
                newbuff as *mut c_void,
                (*B).b as *const c_void,
                ((*B).n).wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
            );
        }
        (*B).b = newbuff;
        (*B).size = newsize;
        return newbuff.offset((*B).n as isize);
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_prepbuffsize(
    mut B: *mut luaL_Buffer,
    mut sz: size_t,
) -> *mut std::ffi::c_char {
    return prepbuffsize(B, sz, -(1 as i32));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_addlstring(
    mut B: *mut luaL_Buffer,
    mut s: *const std::ffi::c_char,
    mut l: size_t,
) {
    if l > 0 as size_t {
        let mut b: *mut std::ffi::c_char = prepbuffsize(B, l, -(1 as i32));
        memcpy(
            b as *mut c_void,
            s as *const c_void,
            l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
        );
        (*B).n = ((*B).n).wrapping_add(l);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_addstring(
    mut B: *mut luaL_Buffer,
    mut s: *const std::ffi::c_char,
) {
    luaL_addlstring(B, s, strlen(s));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_pushresult(mut B: *mut luaL_Buffer) {
    let mut L: *mut lua_State = (*B).L;
    lua_pushlstring(L, (*B).b, (*B).n);
    if (*B).b != ((*B).init.b).as_mut_ptr() {
        lua_closeslot(L, -(2 as i32));
    }
    lua_rotate(L, -(2 as i32), -(1 as i32));
    lua_settop(L, -(1 as i32) - 1 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_pushresultsize(mut B: *mut luaL_Buffer, mut sz: size_t) {
    (*B).n = ((*B).n).wrapping_add(sz);
    luaL_pushresult(B);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_addvalue(mut B: *mut luaL_Buffer) {
    let mut L: *mut lua_State = (*B).L;
    let mut len: size_t = 0;
    let mut s: *const std::ffi::c_char = lua_tolstring(L, -(1 as i32), &mut len);
    let mut b: *mut std::ffi::c_char = prepbuffsize(B, len, -(2 as i32));
    memcpy(
        b as *mut c_void,
        s as *const c_void,
        len.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
    );
    (*B).n = ((*B).n).wrapping_add(len);
    lua_settop(L, -(1 as i32) - 1 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_buffinit(mut L: *mut lua_State, mut B: *mut luaL_Buffer) {
    (*B).L = L;
    (*B).b = ((*B).init.b).as_mut_ptr();
    (*B).n = 0 as size_t;
    (*B).size = (16usize)
        .wrapping_mul(::core::mem::size_of::<*mut c_void>() as usize)
        .wrapping_mul(::core::mem::size_of::<lua_Number>() as usize) as i32
        as size_t;
    lua_pushlightuserdata(L, B as *mut c_void);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_buffinitsize(
    mut L: *mut lua_State,
    mut B: *mut luaL_Buffer,
    mut sz: size_t,
) -> *mut std::ffi::c_char {
    luaL_buffinit(L, B);
    return prepbuffsize(B, sz, -(1 as i32));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_ref(mut L: *mut lua_State, mut t: i32) -> i32 {
    let mut ref_0: i32 = 0;
    if lua_type(L, -(1 as i32)) == 0 {
        lua_settop(L, -(1 as i32) - 1 as i32);
        return -(1 as i32);
    }
    t = lua_absindex(L, t);
    if lua_rawgeti(L, t, (2 as i32 + 1 as i32) as lua_Integer) == 0 {
        ref_0 = 0;
        lua_pushinteger(L, 0 as lua_Integer);
        lua_rawseti(L, t, (2 as i32 + 1 as i32) as lua_Integer);
    } else {
        ref_0 = lua_tointegerx(L, -(1 as i32), 0 as *mut i32) as i32;
    }
    lua_settop(L, -(1 as i32) - 1 as i32);
    if ref_0 != 0 {
        lua_rawgeti(L, t, ref_0 as lua_Integer);
        lua_rawseti(L, t, (2 as i32 + 1 as i32) as lua_Integer);
    } else {
        ref_0 = lua_rawlen(L, t) as i32 + 1 as i32;
    }
    lua_rawseti(L, t, ref_0 as lua_Integer);
    return ref_0;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_unref(mut L: *mut lua_State, mut t: i32, mut ref_0: i32) {
    if ref_0 >= 0 {
        t = lua_absindex(L, t);
        lua_rawgeti(L, t, (2 as i32 + 1 as i32) as lua_Integer);
        lua_rawseti(L, t, ref_0 as lua_Integer);
        lua_pushinteger(L, ref_0 as lua_Integer);
        lua_rawseti(L, t, (2 as i32 + 1 as i32) as lua_Integer);
    }
}
unsafe extern "C-unwind" fn getF(
    mut L: *mut lua_State,
    mut ud: *mut c_void,
    mut size: *mut size_t,
) -> *const std::ffi::c_char {
    let mut lf: *mut LoadF = ud as *mut LoadF;
    if (*lf).n > 0 {
        *size = (*lf).n as size_t;
        (*lf).n = 0;
    } else {
        if feof((*lf).f) != 0 {
            return 0 as *const std::ffi::c_char;
        }
        *size = fread(
            ((*lf).buff).as_mut_ptr() as *mut c_void,
            1,
            ::core::mem::size_of::<[std::ffi::c_char; 8192]>() as usize,
            (*lf).f,
        );
    }
    return ((*lf).buff).as_mut_ptr();
}
unsafe extern "C-unwind" fn errfile(
    mut L: *mut lua_State,
    mut what: *const std::ffi::c_char,
    mut fnameindex: i32,
) -> i32 {
    let mut err: i32 = *__errno_location();
    let mut filename: *const std::ffi::c_char =
        (lua_tolstring(L, fnameindex, 0 as *mut size_t)).offset(1);
    if err != 0 {
        lua_pushfstring(
            L,
            c"cannot %s %s: %s".as_ptr(),
            what,
            filename,
            strerror(err),
        );
    } else {
        lua_pushfstring(L, c"cannot %s %s".as_ptr(), what, filename);
    }
    lua_rotate(L, fnameindex, -(1 as i32));
    lua_settop(L, -(1 as i32) - 1 as i32);
    return 5 as i32 + 1 as i32;
}
unsafe extern "C-unwind" fn skipBOM(mut f: *mut FILE) -> i32 {
    let mut c: i32 = getc(f);
    if c == 0xef as i32 && getc(f) == 0xbb as i32 && getc(f) == 0xbf as i32 {
        return getc(f);
    } else {
        return c;
    };
}
unsafe extern "C-unwind" fn skipcomment(mut f: *mut FILE, mut cp: *mut i32) -> i32 {
    *cp = skipBOM(f);
    let mut c: i32 = *cp;
    if c == '#' as i32 {
        loop {
            c = getc(f);
            if !(c != -(1 as i32) && c != '\n' as i32) {
                break;
            }
        }
        *cp = getc(f);
        return 1 as i32;
    } else {
        return 0;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_loadfilex(
    mut L: *mut lua_State,
    mut filename: *const std::ffi::c_char,
    mut mode: *const std::ffi::c_char,
) -> i32 {
    let mut lf: LoadF = LoadF {
        n: 0,
        f: 0 as *mut FILE,
        buff: [0; 8192],
    };
    let mut status: i32 = 0;
    let mut readstatus: i32 = 0;
    let mut c: i32 = 0;
    let mut fnameindex: i32 = lua_gettop(L) + 1 as i32;
    if filename.is_null() {
        lua_pushstring(L, c"=stdin".as_ptr());
        lf.f = stdin;
    } else {
        lua_pushfstring(L, c"@%s".as_ptr(), filename);
        *__errno_location() = 0;
        lf.f = fopen(filename, c"r".as_ptr());
        if (lf.f).is_null() {
            return errfile(L, c"open".as_ptr(), fnameindex);
        }
    }
    lf.n = 0;
    if skipcomment(lf.f, &mut c) != 0 {
        let fresh148 = lf.n;
        lf.n = lf.n + 1;
        lf.buff[fresh148 as usize] = '\n' as i32 as std::ffi::c_char;
    }
    if c == (*::core::mem::transmute::<&[u8; 5], &[std::ffi::c_char; 5]>(b"\x1BLua\0"))[0 as usize]
        as i32
    {
        lf.n = 0;
        if !filename.is_null() {
            *__errno_location() = 0;
            lf.f = freopen(filename, c"rb".as_ptr(), lf.f);
            if (lf.f).is_null() {
                return errfile(L, c"reopen".as_ptr(), fnameindex);
            }
            skipcomment(lf.f, &mut c);
        }
    }
    if c != -(1 as i32) {
        let fresh149 = lf.n;
        lf.n = lf.n + 1;
        lf.buff[fresh149 as usize] = c as std::ffi::c_char;
    }
    *__errno_location() = 0;
    status = lua_load(
        L,
        Some(
            getF as unsafe extern "C-unwind" fn(
                *mut lua_State,
                *mut c_void,
                *mut size_t,
            ) -> *const std::ffi::c_char,
        ),
        &mut lf as *mut LoadF as *mut c_void,
        lua_tolstring(L, -(1 as i32), 0 as *mut size_t),
        mode,
    );
    readstatus = ferror(lf.f);
    if !filename.is_null() {
        fclose(lf.f);
    }
    if readstatus != 0 {
        lua_settop(L, fnameindex);
        return errfile(L, c"read".as_ptr(), fnameindex);
    }
    lua_rotate(L, fnameindex, -(1 as i32));
    lua_settop(L, -(1 as i32) - 1 as i32);
    return status;
}
unsafe extern "C-unwind" fn getS(
    mut L: *mut lua_State,
    mut ud: *mut c_void,
    mut size: *mut size_t,
) -> *const std::ffi::c_char {
    let mut ls: *mut LoadS = ud as *mut LoadS;
    if (*ls).size == 0 as size_t {
        return 0 as *const std::ffi::c_char;
    }
    *size = (*ls).size;
    (*ls).size = 0 as size_t;
    return (*ls).s;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_loadbufferx(
    mut L: *mut lua_State,
    mut buff: *const std::ffi::c_char,
    mut size: size_t,
    mut name: *const std::ffi::c_char,
    mut mode: *const std::ffi::c_char,
) -> i32 {
    let mut ls: LoadS = LoadS {
        s: 0 as *const std::ffi::c_char,
        size: 0,
    };
    ls.s = buff;
    ls.size = size;
    return lua_load(
        L,
        Some(
            getS as unsafe extern "C-unwind" fn(
                *mut lua_State,
                *mut c_void,
                *mut size_t,
            ) -> *const std::ffi::c_char,
        ),
        &mut ls as *mut LoadS as *mut c_void,
        name,
        mode,
    );
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_loadstring(
    mut L: *mut lua_State,
    mut s: *const std::ffi::c_char,
) -> i32 {
    return luaL_loadbufferx(L, s, strlen(s), s, 0 as *const std::ffi::c_char);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_getmetafield(
    mut L: *mut lua_State,
    mut obj: i32,
    mut event: *const std::ffi::c_char,
) -> i32 {
    if lua_getmetatable(L, obj) == 0 {
        return 0;
    } else {
        let mut tt: i32 = 0;
        lua_pushstring(L, event);
        tt = lua_rawget(L, -(2 as i32));
        if tt == 0 {
            lua_settop(L, -(2 as i32) - 1 as i32);
        } else {
            lua_rotate(L, -(2 as i32), -(1 as i32));
            lua_settop(L, -(1 as i32) - 1 as i32);
        }
        return tt;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_callmeta(
    mut L: *mut lua_State,
    mut obj: i32,
    mut event: *const std::ffi::c_char,
) -> i32 {
    obj = lua_absindex(L, obj);
    if luaL_getmetafield(L, obj, event) == 0 {
        return 0;
    }
    lua_pushvalue(L, obj);
    lua_callk(L, 1 as i32, 1 as i32, 0 as lua_KContext, None);
    return 1 as i32;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_len(mut L: *mut lua_State, mut idx: i32) -> lua_Integer {
    let mut l: lua_Integer = 0;
    let mut isnum: i32 = 0;
    lua_len(L, idx);
    l = lua_tointegerx(L, -(1 as i32), &mut isnum);
    if ((isnum == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(L, c"object length is not an integer".as_ptr());
    }
    lua_settop(L, -(1 as i32) - 1 as i32);
    return l;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_tolstring(
    mut L: *mut lua_State,
    mut idx: i32,
    mut len: *mut size_t,
) -> *const std::ffi::c_char {
    idx = lua_absindex(L, idx);
    if luaL_callmeta(L, idx, c"__tostring".as_ptr()) != 0 {
        if lua_isstring(L, -(1 as i32)) == 0 {
            luaL_error(L, c"'__tostring' must return a string".as_ptr());
        }
    } else {
        match lua_type(L, idx) {
            3 => {
                if lua_isinteger(L, idx) != 0 {
                    lua_pushfstring(L, c"%I".as_ptr(), lua_tointegerx(L, idx, 0 as *mut i32));
                } else {
                    lua_pushfstring(L, c"%f".as_ptr(), lua_tonumberx(L, idx, 0 as *mut i32));
                }
            }
            4 => {
                lua_pushvalue(L, idx);
            }
            1 => {
                lua_pushstring(
                    L,
                    if lua_toboolean(L, idx) != 0 {
                        c"true".as_ptr()
                    } else {
                        c"false".as_ptr()
                    },
                );
            }
            0 => {
                lua_pushstring(L, c"nil".as_ptr());
            }
            _ => {
                let mut tt: i32 = luaL_getmetafield(L, idx, c"__name".as_ptr());
                let mut kind: *const std::ffi::c_char = if tt == 4 as i32 {
                    lua_tolstring(L, -(1 as i32), 0 as *mut size_t)
                } else {
                    lua_typename(L, lua_type(L, idx))
                };
                lua_pushfstring(L, c"%s: %p".as_ptr(), kind, lua_topointer(L, idx));
                if tt != 0 {
                    lua_rotate(L, -(2 as i32), -(1 as i32));
                    lua_settop(L, -(1 as i32) - 1 as i32);
                }
            }
        }
    }
    return lua_tolstring(L, -(1 as i32), len);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_setfuncs(
    mut L: *mut lua_State,
    mut l: *const luaL_Reg,
    mut nup: i32,
) {
    luaL_checkstack(L, nup, c"too many upvalues".as_ptr());
    while !((*l).name).is_null() {
        if ((*l).func).is_none() {
            lua_pushboolean(L, 0);
        } else {
            let mut i: i32 = 0;
            i = 0;
            while i < nup {
                lua_pushvalue(L, -nup);
                i += 1;
                i;
            }
            lua_pushcclosure(L, (*l).func, nup);
        }
        lua_setfield(L, -(nup + 2 as i32), (*l).name);
        l = l.offset(1);
        l;
    }
    lua_settop(L, -nup - 1 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_getsubtable(
    mut L: *mut lua_State,
    mut idx: i32,
    mut fname: *const std::ffi::c_char,
) -> i32 {
    if lua_getfield(L, idx, fname) == 5 as i32 {
        return 1 as i32;
    } else {
        lua_settop(L, -(1 as i32) - 1 as i32);
        idx = lua_absindex(L, idx);
        lua_createtable(L, 0, 0);
        lua_pushvalue(L, -(1 as i32));
        lua_setfield(L, idx, fname);
        return 0;
    };
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_requiref(
    mut L: *mut lua_State,
    mut modname: *const std::ffi::c_char,
    mut openf: lua_CFunction,
    mut glb: i32,
) {
    luaL_getsubtable(L, -(1000000) - 1000, c"_LOADED".as_ptr());
    lua_getfield(L, -(1 as i32), modname);
    if lua_toboolean(L, -(1 as i32)) == 0 {
        lua_settop(L, -(1 as i32) - 1 as i32);
        lua_pushcclosure(L, openf, 0);
        lua_pushstring(L, modname);
        lua_callk(L, 1 as i32, 1 as i32, 0 as lua_KContext, None);
        lua_pushvalue(L, -(1 as i32));
        lua_setfield(L, -(3 as i32), modname);
    }
    lua_rotate(L, -(2 as i32), -(1 as i32));
    lua_settop(L, -(1 as i32) - 1 as i32);
    if glb != 0 {
        lua_pushvalue(L, -(1 as i32));
        lua_setglobal(L, modname);
    }
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_addgsub(
    mut b: *mut luaL_Buffer,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
    mut r: *const std::ffi::c_char,
) {
    let mut wild: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut l: size_t = strlen(p);
    loop {
        wild = strstr(s, p);
        if wild.is_null() {
            break;
        }
        luaL_addlstring(b, s, wild.offset_from(s) as std::ffi::c_long as size_t);
        luaL_addstring(b, r);
        s = wild.offset(l as isize);
    }
    luaL_addstring(b, s);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_gsub(
    mut L: *mut lua_State,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
    mut r: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    luaL_buffinit(L, &mut b);
    luaL_addgsub(&mut b, s, p, r);
    luaL_pushresult(&mut b);
    return lua_tolstring(L, -(1 as i32), 0 as *mut size_t);
}
unsafe extern "C-unwind" fn l_alloc(
    mut ud: *mut c_void,
    mut ptr: *mut c_void,
    mut osize: size_t,
    mut nsize: size_t,
) -> *mut c_void {
    if nsize == 0 as size_t {
        free(ptr);
        return 0 as *mut c_void;
    } else {
        return realloc(ptr, nsize);
    };
}
unsafe extern "C-unwind" fn panic(mut L: *mut lua_State) -> i32 {
    let mut msg: *const std::ffi::c_char = if lua_type(L, -(1 as i32)) == 4 as i32 {
        lua_tolstring(L, -(1 as i32), 0 as *mut size_t)
    } else {
        c"error object is not a string".as_ptr()
    };
    fprintf(
        stderr,
        c"PANIC: unprotected error in call to Lua API (%s)\n".as_ptr(),
        msg,
    );
    fflush(stderr);
    return 0;
}
unsafe extern "C-unwind" fn checkcontrol(
    mut L: *mut lua_State,
    mut message: *const std::ffi::c_char,
    mut tocont: i32,
) -> i32 {
    if tocont != 0 || {
        let fresh150 = message;
        message = message.offset(1);
        *fresh150 != b'@' as std::ffi::c_char
    } {
        return 0;
    } else {
        if strcmp(message, c"off".as_ptr()) == 0 {
            lua_setwarnf(
                L,
                Some(
                    warnfoff
                        as unsafe extern "C-unwind" fn(
                            *mut c_void,
                            *const std::ffi::c_char,
                            i32,
                        ) -> (),
                ),
                L as *mut c_void,
            );
        } else if strcmp(message, c"on".as_ptr()) == 0 {
            lua_setwarnf(
                L,
                Some(
                    warnfon
                        as unsafe extern "C-unwind" fn(
                            *mut c_void,
                            *const std::ffi::c_char,
                            i32,
                        ) -> (),
                ),
                L as *mut c_void,
            );
        }
        return 1 as i32;
    };
}
unsafe extern "C-unwind" fn warnfoff(
    mut ud: *mut c_void,
    mut message: *const std::ffi::c_char,
    mut tocont: i32,
) {
    checkcontrol(ud as *mut lua_State, message, tocont);
}
unsafe extern "C-unwind" fn warnfcont(
    mut ud: *mut c_void,
    mut message: *const std::ffi::c_char,
    mut tocont: i32,
) {
    let mut L: *mut lua_State = ud as *mut lua_State;
    fprintf(stderr, c"%s".as_ptr(), message);
    fflush(stderr);
    if tocont != 0 {
        lua_setwarnf(
            L,
            Some(
                warnfcont
                    as unsafe extern "C-unwind" fn(*mut c_void, *const std::ffi::c_char, i32) -> (),
            ),
            L as *mut c_void,
        );
    } else {
        fprintf(stderr, c"%s".as_ptr(), c"\n".as_ptr());
        fflush(stderr);
        lua_setwarnf(
            L,
            Some(
                warnfon
                    as unsafe extern "C-unwind" fn(*mut c_void, *const std::ffi::c_char, i32) -> (),
            ),
            L as *mut c_void,
        );
    };
}
unsafe extern "C-unwind" fn warnfon(
    mut ud: *mut c_void,
    mut message: *const std::ffi::c_char,
    mut tocont: i32,
) {
    if checkcontrol(ud as *mut lua_State, message, tocont) != 0 {
        return;
    }
    fprintf(stderr, c"%s".as_ptr(), c"Lua warning: ".as_ptr());
    fflush(stderr);
    warnfcont(ud, message, tocont);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_newstate() -> *mut lua_State {
    let mut L: *mut lua_State = lua_newstate(
        Some(
            l_alloc
                as unsafe extern "C-unwind" fn(
                    *mut c_void,
                    *mut c_void,
                    size_t,
                    size_t,
                ) -> *mut c_void,
        ),
        0 as *mut c_void,
    );
    if (L != 0 as *mut lua_State) as i32 as std::ffi::c_long != 0 {
        lua_atpanic(
            L,
            Some(panic as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
        );
        lua_setwarnf(
            L,
            Some(
                warnfoff
                    as unsafe extern "C-unwind" fn(*mut c_void, *const std::ffi::c_char, i32) -> (),
            ),
            L as *mut c_void,
        );
    }
    return L;
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_checkversion_(
    mut L: *mut lua_State,
    mut ver: lua_Number,
    mut sz: size_t,
) {
    let mut v: lua_Number = lua_version(L);
    if sz
        != (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize)
    {
        luaL_error(
            L,
            c"core and library have incompatible numeric types".as_ptr(),
        );
    } else if v != ver {
        luaL_error(
            L,
            c"version mismatch: app. needs %f, Lua core provides %f".as_ptr(),
            ver,
            v,
        );
    }
}
unsafe extern "C-unwind" fn luaB_print(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = lua_gettop(L);
    let mut i: i32 = 0;
    i = 1 as i32;
    while i <= n {
        let mut l: size_t = 0;
        let mut s: *const std::ffi::c_char = luaL_tolstring(L, i, &mut l);
        if i > 1 as i32 {
            fwrite(
                c"\t".as_ptr() as *const c_void,
                ::core::mem::size_of::<std::ffi::c_char>() as usize,
                1,
                stdout,
            );
        }
        fwrite(
            s as *const c_void,
            ::core::mem::size_of::<std::ffi::c_char>() as usize,
            l,
            stdout,
        );
        lua_settop(L, -(1 as i32) - 1 as i32);
        i += 1;
        i;
    }
    fwrite(
        c"\n".as_ptr() as *const c_void,
        ::core::mem::size_of::<std::ffi::c_char>() as usize,
        1,
        stdout,
    );
    fflush(stdout);
    return 0;
}
unsafe extern "C-unwind" fn luaB_warn(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = lua_gettop(L);
    let mut i: i32 = 0;
    luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    i = 2 as i32;
    while i <= n {
        luaL_checklstring(L, i, 0 as *mut size_t);
        i += 1;
        i;
    }
    i = 1 as i32;
    while i < n {
        lua_warning(L, lua_tolstring(L, i, 0 as *mut size_t), 1 as i32);
        i += 1;
        i;
    }
    lua_warning(L, lua_tolstring(L, n, 0 as *mut size_t), 0);
    return 0;
}
unsafe extern "C-unwind" fn b_str2int(
    mut s: *const std::ffi::c_char,
    mut base: i32,
    mut pn: *mut lua_Integer,
) -> *const std::ffi::c_char {
    let mut n: lua_Unsigned = 0 as lua_Unsigned;
    let mut neg: i32 = 0;
    s = s.offset(strspn(s, c" \x0C\n\r\t\x0B".as_ptr()) as isize);
    if *s as i32 == '-' as i32 {
        s = s.offset(1);
        s;
        neg = 1 as i32;
    } else if *s as i32 == '+' as i32 {
        s = s.offset(1);
        s;
    }
    if *(*__ctype_b_loc()).offset(*s as u8 as i32 as isize) as i32 & _ISalnum as i32 as u16 as i32
        == 0
    {
        return 0 as *const std::ffi::c_char;
    }
    loop {
        let mut digit_0: i32 = if *(*__ctype_b_loc()).offset(*s as u8 as i32 as isize) as i32
            & _ISdigit as i32 as u16 as i32
            != 0
        {
            *s as i32 - '0' as i32
        } else {
            toupper(*s as u8 as i32) - 'A' as i32 + 10
        };
        if digit_0 >= base {
            return 0 as *const std::ffi::c_char;
        }
        n = (n * base as lua_Unsigned).wrapping_add(digit_0 as lua_Unsigned);
        s = s.offset(1);
        s;
        if !(*(*__ctype_b_loc()).offset(*s as u8 as i32 as isize) as i32
            & _ISalnum as i32 as u16 as i32
            != 0)
        {
            break;
        }
    }
    s = s.offset(strspn(s, c" \x0C\n\r\t\x0B".as_ptr()) as isize);
    *pn = (if neg != 0 {
        (0 as u32 as lua_Unsigned).wrapping_sub(n)
    } else {
        n
    }) as lua_Integer;
    return s;
}
unsafe extern "C-unwind" fn luaB_tonumber(mut L: *mut lua_State) -> i32 {
    if lua_type(L, 2 as i32) <= 0 {
        if lua_type(L, 1 as i32) == 3 as i32 {
            lua_settop(L, 1 as i32);
            return 1 as i32;
        } else {
            let mut l: size_t = 0;
            let mut s: *const std::ffi::c_char = lua_tolstring(L, 1 as i32, &mut l);
            if !s.is_null() && lua_stringtonumber(L, s) == l.wrapping_add(1 as i32 as size_t) {
                return 1 as i32;
            }
            luaL_checkany(L, 1 as i32);
        }
    } else {
        let mut l_0: size_t = 0;
        let mut s_0: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
        let mut n: lua_Integer = 0 as lua_Integer;
        let mut base: lua_Integer = luaL_checkinteger(L, 2 as i32);
        luaL_checktype(L, 1 as i32, 4 as i32);
        s_0 = lua_tolstring(L, 1 as i32, &mut l_0);
        (((2 as i32 as lua_Integer <= base && base <= 36 as i32 as lua_Integer) as i32 != 0) as i32
            as std::ffi::c_long
            != 0
            || luaL_argerror(L, 2 as i32, c"base out of range".as_ptr()) != 0) as i32;
        if b_str2int(s_0, base as i32, &mut n) == s_0.offset(l_0 as isize) {
            lua_pushinteger(L, n);
            return 1 as i32;
        }
    }
    lua_pushnil(L);
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_error(mut L: *mut lua_State) -> i32 {
    let mut level: i32 = luaL_optinteger(L, 2 as i32, 1 as i32 as lua_Integer) as i32;
    lua_settop(L, 1 as i32);
    if lua_type(L, 1 as i32) == 4 as i32 && level > 0 {
        luaL_where(L, level);
        lua_pushvalue(L, 1 as i32);
        lua_concat(L, 2 as i32);
    }
    return lua_error(L);
}
unsafe extern "C-unwind" fn luaB_getmetatable(mut L: *mut lua_State) -> i32 {
    luaL_checkany(L, 1 as i32);
    if lua_getmetatable(L, 1 as i32) == 0 {
        lua_pushnil(L);
        return 1 as i32;
    }
    luaL_getmetafield(L, 1 as i32, c"__metatable".as_ptr());
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_setmetatable(mut L: *mut lua_State) -> i32 {
    let mut t: i32 = lua_type(L, 2 as i32);
    luaL_checktype(L, 1 as i32, 5 as i32);
    (((t == 0 || t == 5 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_typeerror(L, 2 as i32, c"nil or table".as_ptr()) != 0) as i32;
    if ((luaL_getmetafield(L, 1 as i32, c"__metatable".as_ptr()) != 0) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
    {
        return luaL_error(L, c"cannot change a protected metatable".as_ptr());
    }
    lua_settop(L, 2 as i32);
    lua_setmetatable(L, 1 as i32);
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_rawequal(mut L: *mut lua_State) -> i32 {
    luaL_checkany(L, 1 as i32);
    luaL_checkany(L, 2 as i32);
    lua_pushboolean(L, lua_rawequal(L, 1 as i32, 2 as i32));
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_rawlen(mut L: *mut lua_State) -> i32 {
    let mut t: i32 = lua_type(L, 1 as i32);
    (((t == 5 as i32 || t == 4 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_typeerror(L, 1 as i32, c"table or string".as_ptr()) != 0) as i32;
    lua_pushinteger(L, lua_rawlen(L, 1 as i32) as lua_Integer);
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_rawget(mut L: *mut lua_State) -> i32 {
    luaL_checktype(L, 1 as i32, 5 as i32);
    luaL_checkany(L, 2 as i32);
    lua_settop(L, 2 as i32);
    lua_rawget(L, 1 as i32);
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_rawset(mut L: *mut lua_State) -> i32 {
    luaL_checktype(L, 1 as i32, 5 as i32);
    luaL_checkany(L, 2 as i32);
    luaL_checkany(L, 3 as i32);
    lua_settop(L, 3 as i32);
    lua_rawset(L, 1 as i32);
    return 1 as i32;
}
unsafe extern "C-unwind" fn pushmode(mut L: *mut lua_State, mut oldmode: i32) -> i32 {
    if oldmode == -(1 as i32) {
        lua_pushnil(L);
    } else {
        lua_pushstring(
            L,
            if oldmode == 11 as i32 {
                c"incremental".as_ptr()
            } else {
                c"generational".as_ptr()
            },
        );
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_collectgarbage(mut L: *mut lua_State) -> i32 {
    static mut opts: [*const std::ffi::c_char; 11] = [
        c"stop".as_ptr(),
        c"restart".as_ptr(),
        c"collect".as_ptr(),
        c"count".as_ptr(),
        c"step".as_ptr(),
        c"setpause".as_ptr(),
        c"setstepmul".as_ptr(),
        c"isrunning".as_ptr(),
        c"generational".as_ptr(),
        c"incremental".as_ptr(),
        0 as *const std::ffi::c_char,
    ];
    static mut optsnum: [i32; 10] = [
        0, 1 as i32, 2 as i32, 3 as i32, 5 as i32, 6 as i32, 7 as i32, 9 as i32, 10, 11 as i32,
    ];
    let mut o: i32 = optsnum
        [luaL_checkoption(L, 1 as i32, c"collect".as_ptr(), (&raw const opts).cast()) as usize];
    match o {
        3 => {
            let mut k: i32 = lua_gc(L, o);
            let mut b: i32 = lua_gc(L, 4 as i32);
            if !(k == -(1 as i32)) {
                lua_pushnumber(
                    L,
                    k as lua_Number + b as lua_Number / 1024 as i32 as lua_Number,
                );
                return 1 as i32;
            }
        }
        5 => {
            let mut step: i32 = luaL_optinteger(L, 2 as i32, 0 as lua_Integer) as i32;
            let mut res: i32 = lua_gc(L, o, step);
            if !(res == -(1 as i32)) {
                lua_pushboolean(L, res);
                return 1 as i32;
            }
        }
        6 | 7 => {
            let mut p: i32 = luaL_optinteger(L, 2 as i32, 0 as lua_Integer) as i32;
            let mut previous: i32 = lua_gc(L, o, p);
            if !(previous == -(1 as i32)) {
                lua_pushinteger(L, previous as lua_Integer);
                return 1 as i32;
            }
        }
        9 => {
            let mut res_0: i32 = lua_gc(L, o);
            if !(res_0 == -(1 as i32)) {
                lua_pushboolean(L, res_0);
                return 1 as i32;
            }
        }
        10 => {
            let mut minormul: i32 = luaL_optinteger(L, 2 as i32, 0 as lua_Integer) as i32;
            let mut majormul: i32 = luaL_optinteger(L, 3 as i32, 0 as lua_Integer) as i32;
            return pushmode(L, lua_gc(L, o, minormul, majormul));
        }
        11 => {
            let mut pause: i32 = luaL_optinteger(L, 2 as i32, 0 as lua_Integer) as i32;
            let mut stepmul: i32 = luaL_optinteger(L, 3 as i32, 0 as lua_Integer) as i32;
            let mut stepsize: i32 = luaL_optinteger(L, 4 as i32, 0 as lua_Integer) as i32;
            return pushmode(L, lua_gc(L, o, pause, stepmul, stepsize));
        }
        _ => {
            let mut res_1: i32 = lua_gc(L, o);
            if !(res_1 == -(1 as i32)) {
                lua_pushinteger(L, res_1 as lua_Integer);
                return 1 as i32;
            }
        }
    }
    lua_pushnil(L);
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_type(mut L: *mut lua_State) -> i32 {
    let mut t: i32 = lua_type(L, 1 as i32);
    (((t != -(1 as i32)) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 1 as i32, c"value expected".as_ptr()) != 0) as i32;
    lua_pushstring(L, lua_typename(L, t));
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_next(mut L: *mut lua_State) -> i32 {
    luaL_checktype(L, 1 as i32, 5 as i32);
    lua_settop(L, 2 as i32);
    if lua_next(L, 1 as i32) != 0 {
        return 2 as i32;
    } else {
        lua_pushnil(L);
        return 1 as i32;
    };
}
unsafe extern "C-unwind" fn pairscont(
    mut L: *mut lua_State,
    mut status: i32,
    mut k: lua_KContext,
) -> i32 {
    return 3 as i32;
}
unsafe extern "C-unwind" fn luaB_pairs(mut L: *mut lua_State) -> i32 {
    luaL_checkany(L, 1 as i32);
    if luaL_getmetafield(L, 1 as i32, c"__pairs".as_ptr()) == 0 {
        lua_pushcclosure(
            L,
            Some(luaB_next as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            0,
        );
        lua_pushvalue(L, 1 as i32);
        lua_pushnil(L);
    } else {
        lua_pushvalue(L, 1 as i32);
        lua_callk(
            L,
            1 as i32,
            3 as i32,
            0 as lua_KContext,
            Some(
                pairscont as unsafe extern "C-unwind" fn(*mut lua_State, i32, lua_KContext) -> i32,
            ),
        );
    }
    return 3 as i32;
}
unsafe extern "C-unwind" fn ipairsaux(mut L: *mut lua_State) -> i32 {
    let mut i: lua_Integer = luaL_checkinteger(L, 2 as i32);
    i = (i as lua_Unsigned).wrapping_add(1 as i32 as lua_Unsigned) as lua_Integer;
    lua_pushinteger(L, i);
    return if lua_geti(L, 1 as i32, i) == 0 {
        1 as i32
    } else {
        2 as i32
    };
}
unsafe extern "C-unwind" fn luaB_ipairs(mut L: *mut lua_State) -> i32 {
    luaL_checkany(L, 1 as i32);
    lua_pushcclosure(
        L,
        Some(ipairsaux as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
        0,
    );
    lua_pushvalue(L, 1 as i32);
    lua_pushinteger(L, 0 as lua_Integer);
    return 3 as i32;
}
unsafe extern "C-unwind" fn load_aux(
    mut L: *mut lua_State,
    mut status: i32,
    mut envidx: i32,
) -> i32 {
    if ((status == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        if envidx != 0 {
            lua_pushvalue(L, envidx);
            if (lua_setupvalue(L, -(2 as i32), 1 as i32)).is_null() {
                lua_settop(L, -(1 as i32) - 1 as i32);
            }
        }
        return 1 as i32;
    } else {
        lua_pushnil(L);
        lua_rotate(L, -(2 as i32), 1 as i32);
        return 2 as i32;
    };
}
unsafe extern "C-unwind" fn luaB_loadfile(mut L: *mut lua_State) -> i32 {
    let mut fname: *const std::ffi::c_char =
        luaL_optlstring(L, 1 as i32, 0 as *const std::ffi::c_char, 0 as *mut size_t);
    let mut mode: *const std::ffi::c_char =
        luaL_optlstring(L, 2 as i32, 0 as *const std::ffi::c_char, 0 as *mut size_t);
    let mut env: i32 = if !(lua_type(L, 3 as i32) == -(1 as i32)) {
        3 as i32
    } else {
        0
    };
    let mut status: i32 = luaL_loadfilex(L, fname, mode);
    return load_aux(L, status, env);
}
unsafe extern "C-unwind" fn generic_reader(
    mut L: *mut lua_State,
    mut ud: *mut c_void,
    mut size: *mut size_t,
) -> *const std::ffi::c_char {
    luaL_checkstack(L, 2 as i32, c"too many nested functions".as_ptr());
    lua_pushvalue(L, 1 as i32);
    lua_callk(L, 0, 1 as i32, 0 as lua_KContext, None);
    if lua_type(L, -(1 as i32)) == 0 {
        lua_settop(L, -(1 as i32) - 1 as i32);
        *size = 0 as size_t;
        return 0 as *const std::ffi::c_char;
    } else if ((lua_isstring(L, -(1 as i32)) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(L, c"reader function must return a string".as_ptr());
    }
    lua_copy(L, -(1 as i32), 5 as i32);
    lua_settop(L, -(1 as i32) - 1 as i32);
    return lua_tolstring(L, 5 as i32, size);
}
unsafe extern "C-unwind" fn luaB_load(mut L: *mut lua_State) -> i32 {
    let mut status: i32 = 0;
    let mut l: size_t = 0;
    let mut s: *const std::ffi::c_char = lua_tolstring(L, 1 as i32, &mut l);
    let mut mode: *const std::ffi::c_char =
        luaL_optlstring(L, 3 as i32, c"bt".as_ptr(), 0 as *mut size_t);
    let mut env: i32 = if !(lua_type(L, 4 as i32) == -(1 as i32)) {
        4 as i32
    } else {
        0
    };
    if !s.is_null() {
        let mut chunkname: *const std::ffi::c_char =
            luaL_optlstring(L, 2 as i32, s, 0 as *mut size_t);
        status = luaL_loadbufferx(L, s, l, chunkname, mode);
    } else {
        let mut chunkname_0: *const std::ffi::c_char =
            luaL_optlstring(L, 2 as i32, c"=(load)".as_ptr(), 0 as *mut size_t);
        luaL_checktype(L, 1 as i32, 6 as i32);
        lua_settop(L, 5 as i32);
        status = lua_load(
            L,
            Some(
                generic_reader
                    as unsafe extern "C-unwind" fn(
                        *mut lua_State,
                        *mut c_void,
                        *mut size_t,
                    ) -> *const std::ffi::c_char,
            ),
            0 as *mut c_void,
            chunkname_0,
            mode,
        );
    }
    return load_aux(L, status, env);
}
unsafe extern "C-unwind" fn dofilecont(
    mut L: *mut lua_State,
    mut d1: i32,
    mut d2: lua_KContext,
) -> i32 {
    return lua_gettop(L) - 1 as i32;
}
unsafe extern "C-unwind" fn luaB_dofile(mut L: *mut lua_State) -> i32 {
    let mut fname: *const std::ffi::c_char =
        luaL_optlstring(L, 1 as i32, 0 as *const std::ffi::c_char, 0 as *mut size_t);
    lua_settop(L, 1 as i32);
    if ((luaL_loadfilex(L, fname, 0 as *const std::ffi::c_char) != 0) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
    {
        return lua_error(L);
    }
    lua_callk(
        L,
        0,
        -(1 as i32),
        0 as lua_KContext,
        Some(dofilecont as unsafe extern "C-unwind" fn(*mut lua_State, i32, lua_KContext) -> i32),
    );
    return dofilecont(L, 0, 0 as lua_KContext);
}
unsafe extern "C-unwind" fn luaB_assert(mut L: *mut lua_State) -> i32 {
    if (lua_toboolean(L, 1 as i32) != 0) as i32 as std::ffi::c_long != 0 {
        return lua_gettop(L);
    } else {
        luaL_checkany(L, 1 as i32);
        lua_rotate(L, 1 as i32, -(1 as i32));
        lua_settop(L, -(1 as i32) - 1 as i32);
        lua_pushstring(L, c"assertion failed!".as_ptr());
        lua_settop(L, 1 as i32);
        return luaB_error(L);
    };
}
unsafe extern "C-unwind" fn luaB_select(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = lua_gettop(L);
    if lua_type(L, 1 as i32) == 4 as i32
        && *lua_tolstring(L, 1 as i32, 0 as *mut size_t) as i32 == '#' as i32
    {
        lua_pushinteger(L, (n - 1 as i32) as lua_Integer);
        return 1 as i32;
    } else {
        let mut i: lua_Integer = luaL_checkinteger(L, 1 as i32);
        if i < 0 as lua_Integer {
            i = n as lua_Integer + i;
        } else if i > n as lua_Integer {
            i = n as lua_Integer;
        }
        (((1 as i32 as lua_Integer <= i) as i32 != 0) as i32 as std::ffi::c_long != 0
            || luaL_argerror(L, 1 as i32, c"index out of range".as_ptr()) != 0) as i32;
        return n - i as i32;
    };
}
unsafe extern "C-unwind" fn finishpcall(
    mut L: *mut lua_State,
    mut status: i32,
    mut extra: lua_KContext,
) -> i32 {
    if ((status != 0 && status != 1 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushboolean(L, 0);
        lua_pushvalue(L, -(2 as i32));
        return 2 as i32;
    } else {
        return lua_gettop(L) - extra as i32;
    };
}
unsafe extern "C-unwind" fn luaB_pcall(mut L: *mut lua_State) -> i32 {
    let mut status: i32 = 0;
    luaL_checkany(L, 1 as i32);
    lua_pushboolean(L, 1 as i32);
    lua_rotate(L, 1 as i32, 1 as i32);
    status = lua_pcallk(
        L,
        lua_gettop(L) - 2 as i32,
        -(1 as i32),
        0,
        0 as lua_KContext,
        Some(finishpcall as unsafe extern "C-unwind" fn(*mut lua_State, i32, lua_KContext) -> i32),
    );
    return finishpcall(L, status, 0 as lua_KContext);
}
unsafe extern "C-unwind" fn luaB_xpcall(mut L: *mut lua_State) -> i32 {
    let mut status: i32 = 0;
    let mut n: i32 = lua_gettop(L);
    luaL_checktype(L, 2 as i32, 6 as i32);
    lua_pushboolean(L, 1 as i32);
    lua_pushvalue(L, 1 as i32);
    lua_rotate(L, 3 as i32, 2 as i32);
    status = lua_pcallk(
        L,
        n - 2 as i32,
        -(1 as i32),
        2 as i32,
        2 as i32 as lua_KContext,
        Some(finishpcall as unsafe extern "C-unwind" fn(*mut lua_State, i32, lua_KContext) -> i32),
    );
    return finishpcall(L, status, 2 as i32 as lua_KContext);
}
unsafe extern "C-unwind" fn luaB_tostring(mut L: *mut lua_State) -> i32 {
    luaL_checkany(L, 1 as i32);
    luaL_tolstring(L, 1 as i32, 0 as *mut size_t);
    return 1 as i32;
}
static mut base_funcs: [luaL_Reg; 26] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"assert".as_ptr(),
                func: Some(luaB_assert as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"collectgarbage".as_ptr(),
                func: Some(
                    luaB_collectgarbage as unsafe extern "C-unwind" fn(*mut lua_State) -> i32,
                ),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"dofile".as_ptr(),
                func: Some(luaB_dofile as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"error".as_ptr(),
                func: Some(luaB_error as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getmetatable".as_ptr(),
                func: Some(luaB_getmetatable as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"ipairs".as_ptr(),
                func: Some(luaB_ipairs as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"loadfile".as_ptr(),
                func: Some(luaB_loadfile as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"load".as_ptr(),
                func: Some(luaB_load as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"next".as_ptr(),
                func: Some(luaB_next as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"pairs".as_ptr(),
                func: Some(luaB_pairs as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"pcall".as_ptr(),
                func: Some(luaB_pcall as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"print".as_ptr(),
                func: Some(luaB_print as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"warn".as_ptr(),
                func: Some(luaB_warn as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"rawequal".as_ptr(),
                func: Some(luaB_rawequal as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"rawlen".as_ptr(),
                func: Some(luaB_rawlen as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"rawget".as_ptr(),
                func: Some(luaB_rawget as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"rawset".as_ptr(),
                func: Some(luaB_rawset as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"select".as_ptr(),
                func: Some(luaB_select as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setmetatable".as_ptr(),
                func: Some(luaB_setmetatable as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"tonumber".as_ptr(),
                func: Some(luaB_tonumber as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"tostring".as_ptr(),
                func: Some(luaB_tostring as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"type".as_ptr(),
                func: Some(luaB_type as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"xpcall".as_ptr(),
                func: Some(luaB_xpcall as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"_G".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"_VERSION".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_base(mut L: *mut lua_State) -> i32 {
    lua_rawgeti(L, -(1000000) - 1000, 2 as i32 as lua_Integer);
    luaL_setfuncs(L, (&raw const base_funcs).cast(), 0);
    lua_pushvalue(L, -(1 as i32));
    lua_setfield(L, -(2 as i32), c"_G".as_ptr());
    lua_pushstring(L, c"Lua 5.4".as_ptr());
    lua_setfield(L, -(2 as i32), c"_VERSION".as_ptr());
    return 1 as i32;
}
unsafe extern "C-unwind" fn getco(mut L: *mut lua_State) -> *mut lua_State {
    let mut co: *mut lua_State = lua_tothread(L, 1 as i32);
    ((co != 0 as *mut lua_State) as i32 as std::ffi::c_long != 0
        || luaL_typeerror(L, 1 as i32, c"thread".as_ptr()) != 0) as i32;
    return co;
}
unsafe extern "C-unwind" fn auxresume(
    mut L: *mut lua_State,
    mut co: *mut lua_State,
    mut narg: i32,
) -> i32 {
    let mut status: i32 = 0;
    let mut nres: i32 = 0;
    if ((lua_checkstack(co, narg) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushstring(L, c"too many arguments to resume".as_ptr());
        return -(1 as i32);
    }
    lua_xmove(L, co, narg);
    status = lua_resume(co, L, narg, &mut nres);
    if ((status == 0 || status == 1 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        if ((lua_checkstack(L, nres + 1 as i32) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            lua_settop(co, -nres - 1 as i32);
            lua_pushstring(L, c"too many results to resume".as_ptr());
            return -(1 as i32);
        }
        lua_xmove(co, L, nres);
        return nres;
    } else {
        lua_xmove(co, L, 1 as i32);
        return -(1 as i32);
    };
}
unsafe extern "C-unwind" fn luaB_coresume(mut L: *mut lua_State) -> i32 {
    let mut co: *mut lua_State = getco(L);
    let mut r: i32 = 0;
    r = auxresume(L, co, lua_gettop(L) - 1 as i32);
    if ((r < 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushboolean(L, 0);
        lua_rotate(L, -(2 as i32), 1 as i32);
        return 2 as i32;
    } else {
        lua_pushboolean(L, 1 as i32);
        lua_rotate(L, -(r + 1 as i32), 1 as i32);
        return r + 1 as i32;
    };
}
unsafe extern "C-unwind" fn luaB_auxwrap(mut L: *mut lua_State) -> i32 {
    let mut co: *mut lua_State = lua_tothread(L, -(1000000) - 1000 - 1 as i32);
    let mut r: i32 = auxresume(L, co, lua_gettop(L));
    if ((r < 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        let mut stat: i32 = lua_status(co);
        if stat != 0 && stat != 1 as i32 {
            stat = lua_closethread(co, L);
            lua_xmove(co, L, 1 as i32);
        }
        if stat != 4 as i32 && lua_type(L, -(1 as i32)) == 4 as i32 {
            luaL_where(L, 1 as i32);
            lua_rotate(L, -(2 as i32), 1 as i32);
            lua_concat(L, 2 as i32);
        }
        return lua_error(L);
    }
    return r;
}
unsafe extern "C-unwind" fn luaB_cocreate(mut L: *mut lua_State) -> i32 {
    let mut NL: *mut lua_State = 0 as *mut lua_State;
    luaL_checktype(L, 1 as i32, 6 as i32);
    NL = lua_newthread(L);
    lua_pushvalue(L, 1 as i32);
    lua_xmove(L, NL, 1 as i32);
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_cowrap(mut L: *mut lua_State) -> i32 {
    luaB_cocreate(L);
    lua_pushcclosure(
        L,
        Some(luaB_auxwrap as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
        1 as i32,
    );
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_yield(mut L: *mut lua_State) -> i32 {
    return lua_yieldk(L, lua_gettop(L), 0 as lua_KContext, None);
}
static mut statname: [*const std::ffi::c_char; 4] = [
    c"running".as_ptr(),
    c"dead".as_ptr(),
    c"suspended".as_ptr(),
    c"normal".as_ptr(),
];
unsafe extern "C-unwind" fn auxstatus(mut L: *mut lua_State, mut co: *mut lua_State) -> i32 {
    if L == co {
        return 0;
    } else {
        match lua_status(co) {
            1 => return 2 as i32,
            0 => {
                let mut ar: lua_Debug = lua_Debug {
                    event: 0,
                    name: 0 as *const std::ffi::c_char,
                    namewhat: 0 as *const std::ffi::c_char,
                    what: 0 as *const std::ffi::c_char,
                    source: 0 as *const std::ffi::c_char,
                    srclen: 0,
                    currentline: 0,
                    linedefined: 0,
                    lastlinedefined: 0,
                    nups: 0,
                    nparams: 0,
                    isvararg: 0,
                    istailcall: 0,
                    ftransfer: 0,
                    ntransfer: 0,
                    short_src: [0; 60],
                    i_ci: 0 as *mut CallInfo,
                };
                if lua_getstack(co, 0, &mut ar) != 0 {
                    return 3 as i32;
                } else if lua_gettop(co) == 0 {
                    return 1 as i32;
                } else {
                    return 2 as i32;
                }
            }
            _ => return 1 as i32,
        }
    };
}
unsafe extern "C-unwind" fn luaB_costatus(mut L: *mut lua_State) -> i32 {
    let mut co: *mut lua_State = getco(L);
    lua_pushstring(L, statname[auxstatus(L, co) as usize]);
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_yieldable(mut L: *mut lua_State) -> i32 {
    let mut co: *mut lua_State = if lua_type(L, 1 as i32) == -(1 as i32) {
        L
    } else {
        getco(L)
    };
    lua_pushboolean(L, lua_isyieldable(co));
    return 1 as i32;
}
unsafe extern "C-unwind" fn luaB_corunning(mut L: *mut lua_State) -> i32 {
    let mut ismain: i32 = lua_pushthread(L);
    lua_pushboolean(L, ismain);
    return 2 as i32;
}
unsafe extern "C-unwind" fn luaB_close(mut L: *mut lua_State) -> i32 {
    let mut co: *mut lua_State = getco(L);
    let mut status: i32 = auxstatus(L, co);
    match status {
        1 | 2 => {
            status = lua_closethread(co, L);
            if status == 0 {
                lua_pushboolean(L, 1 as i32);
                return 1 as i32;
            } else {
                lua_pushboolean(L, 0);
                lua_xmove(co, L, 1 as i32);
                return 2 as i32;
            }
        }
        _ => {
            return luaL_error(
                L,
                c"cannot close a %s coroutine".as_ptr(),
                statname[status as usize],
            );
        }
    };
}
static mut co_funcs: [luaL_Reg; 9] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"create".as_ptr(),
                func: Some(luaB_cocreate as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"resume".as_ptr(),
                func: Some(luaB_coresume as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"running".as_ptr(),
                func: Some(luaB_corunning as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"status".as_ptr(),
                func: Some(luaB_costatus as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"wrap".as_ptr(),
                func: Some(luaB_cowrap as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"yield".as_ptr(),
                func: Some(luaB_yield as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"isyieldable".as_ptr(),
                func: Some(luaB_yieldable as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"close".as_ptr(),
                func: Some(luaB_close as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_coroutine(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 9]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const co_funcs).cast(), 0);
    return 1 as i32;
}
static mut HOOKKEY: *const std::ffi::c_char = c"_HOOKKEY".as_ptr();
unsafe extern "C-unwind" fn checkstack(mut L: *mut lua_State, mut L1: *mut lua_State, mut n: i32) {
    if ((L != L1 && lua_checkstack(L1, n) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(L, c"stack overflow".as_ptr());
    }
}
unsafe extern "C-unwind" fn db_getregistry(mut L: *mut lua_State) -> i32 {
    lua_pushvalue(L, -(1000000) - 1000);
    return 1 as i32;
}
unsafe extern "C-unwind" fn db_getmetatable(mut L: *mut lua_State) -> i32 {
    luaL_checkany(L, 1 as i32);
    if lua_getmetatable(L, 1 as i32) == 0 {
        lua_pushnil(L);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn db_setmetatable(mut L: *mut lua_State) -> i32 {
    let mut t: i32 = lua_type(L, 2 as i32);
    (((t == 0 || t == 5 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_typeerror(L, 2 as i32, c"nil or table".as_ptr()) != 0) as i32;
    lua_settop(L, 2 as i32);
    lua_setmetatable(L, 1 as i32);
    return 1 as i32;
}
unsafe extern "C-unwind" fn db_getuservalue(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = luaL_optinteger(L, 2 as i32, 1 as i32 as lua_Integer) as i32;
    if lua_type(L, 1 as i32) != 7 as i32 {
        lua_pushnil(L);
    } else if lua_getiuservalue(L, 1 as i32, n) != -(1 as i32) {
        lua_pushboolean(L, 1 as i32);
        return 2 as i32;
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn db_setuservalue(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = luaL_optinteger(L, 3 as i32, 1 as i32 as lua_Integer) as i32;
    luaL_checktype(L, 1 as i32, 7 as i32);
    luaL_checkany(L, 2 as i32);
    lua_settop(L, 2 as i32);
    if lua_setiuservalue(L, 1 as i32, n) == 0 {
        lua_pushnil(L);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn getthread(mut L: *mut lua_State, mut arg: *mut i32) -> *mut lua_State {
    if lua_type(L, 1 as i32) == 8 as i32 {
        *arg = 1 as i32;
        return lua_tothread(L, 1 as i32);
    } else {
        *arg = 0;
        return L;
    };
}
unsafe extern "C-unwind" fn settabss(
    mut L: *mut lua_State,
    mut k: *const std::ffi::c_char,
    mut v: *const std::ffi::c_char,
) {
    lua_pushstring(L, v);
    lua_setfield(L, -(2 as i32), k);
}
unsafe extern "C-unwind" fn settabsi(
    mut L: *mut lua_State,
    mut k: *const std::ffi::c_char,
    mut v: i32,
) {
    lua_pushinteger(L, v as lua_Integer);
    lua_setfield(L, -(2 as i32), k);
}
unsafe extern "C-unwind" fn settabsb(
    mut L: *mut lua_State,
    mut k: *const std::ffi::c_char,
    mut v: i32,
) {
    lua_pushboolean(L, v);
    lua_setfield(L, -(2 as i32), k);
}
unsafe extern "C-unwind" fn treatstackoption(
    mut L: *mut lua_State,
    mut L1: *mut lua_State,
    mut fname: *const std::ffi::c_char,
) {
    if L == L1 {
        lua_rotate(L, -(2 as i32), 1 as i32);
    } else {
        lua_xmove(L1, L, 1 as i32);
    }
    lua_setfield(L, -(2 as i32), fname);
}
unsafe extern "C-unwind" fn db_getinfo(mut L: *mut lua_State) -> i32 {
    let mut ar: lua_Debug = lua_Debug {
        event: 0,
        name: 0 as *const std::ffi::c_char,
        namewhat: 0 as *const std::ffi::c_char,
        what: 0 as *const std::ffi::c_char,
        source: 0 as *const std::ffi::c_char,
        srclen: 0,
        currentline: 0,
        linedefined: 0,
        lastlinedefined: 0,
        nups: 0,
        nparams: 0,
        isvararg: 0,
        istailcall: 0,
        ftransfer: 0,
        ntransfer: 0,
        short_src: [0; 60],
        i_ci: 0 as *mut CallInfo,
    };
    let mut arg: i32 = 0;
    let mut L1: *mut lua_State = getthread(L, &mut arg);
    let mut options: *const std::ffi::c_char =
        luaL_optlstring(L, arg + 2 as i32, c"flnSrtu".as_ptr(), 0 as *mut size_t);
    checkstack(L, L1, 3 as i32);
    (((*options.offset(0 as isize) as i32 != '>' as i32) as i32 != 0) as i32 as std::ffi::c_long
        != 0
        || luaL_argerror(L, arg + 2 as i32, c"invalid option '>'".as_ptr()) != 0) as i32;
    if lua_type(L, arg + 1 as i32) == 6 as i32 {
        options = lua_pushfstring(L, c">%s".as_ptr(), options);
        lua_pushvalue(L, arg + 1 as i32);
        lua_xmove(L, L1, 1 as i32);
    } else if lua_getstack(L1, luaL_checkinteger(L, arg + 1 as i32) as i32, &mut ar) == 0 {
        lua_pushnil(L);
        return 1 as i32;
    }
    if lua_getinfo(L1, options, &mut ar) == 0 {
        return luaL_argerror(L, arg + 2 as i32, c"invalid option".as_ptr());
    }
    lua_createtable(L, 0, 0);
    if !(strchr(options, 'S' as i32)).is_null() {
        lua_pushlstring(L, ar.source, ar.srclen);
        lua_setfield(L, -(2 as i32), c"source".as_ptr());
        settabss(L, c"short_src".as_ptr(), (ar.short_src).as_mut_ptr());
        settabsi(L, c"linedefined".as_ptr(), ar.linedefined);
        settabsi(L, c"lastlinedefined".as_ptr(), ar.lastlinedefined);
        settabss(L, c"what".as_ptr(), ar.what);
    }
    if !(strchr(options, 'l' as i32)).is_null() {
        settabsi(L, c"currentline".as_ptr(), ar.currentline);
    }
    if !(strchr(options, 'u' as i32)).is_null() {
        settabsi(L, c"nups".as_ptr(), ar.nups as i32);
        settabsi(L, c"nparams".as_ptr(), ar.nparams as i32);
        settabsb(L, c"isvararg".as_ptr(), ar.isvararg as i32);
    }
    if !(strchr(options, 'n' as i32)).is_null() {
        settabss(L, c"name".as_ptr(), ar.name);
        settabss(L, c"namewhat".as_ptr(), ar.namewhat);
    }
    if !(strchr(options, 'r' as i32)).is_null() {
        settabsi(L, c"ftransfer".as_ptr(), ar.ftransfer as i32);
        settabsi(L, c"ntransfer".as_ptr(), ar.ntransfer as i32);
    }
    if !(strchr(options, 't' as i32)).is_null() {
        settabsb(L, c"istailcall".as_ptr(), ar.istailcall as i32);
    }
    if !(strchr(options, 'L' as i32)).is_null() {
        treatstackoption(L, L1, c"activelines".as_ptr());
    }
    if !(strchr(options, 'f' as i32)).is_null() {
        treatstackoption(L, L1, c"func".as_ptr());
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn db_getlocal(mut L: *mut lua_State) -> i32 {
    let mut arg: i32 = 0;
    let mut L1: *mut lua_State = getthread(L, &mut arg);
    let mut nvar: i32 = luaL_checkinteger(L, arg + 2 as i32) as i32;
    if lua_type(L, arg + 1 as i32) == 6 as i32 {
        lua_pushvalue(L, arg + 1 as i32);
        lua_pushstring(L, lua_getlocal(L, 0 as *const lua_Debug, nvar));
        return 1 as i32;
    } else {
        let mut ar: lua_Debug = lua_Debug {
            event: 0,
            name: 0 as *const std::ffi::c_char,
            namewhat: 0 as *const std::ffi::c_char,
            what: 0 as *const std::ffi::c_char,
            source: 0 as *const std::ffi::c_char,
            srclen: 0,
            currentline: 0,
            linedefined: 0,
            lastlinedefined: 0,
            nups: 0,
            nparams: 0,
            isvararg: 0,
            istailcall: 0,
            ftransfer: 0,
            ntransfer: 0,
            short_src: [0; 60],
            i_ci: 0 as *mut CallInfo,
        };
        let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
        let mut level: i32 = luaL_checkinteger(L, arg + 1 as i32) as i32;
        if ((lua_getstack(L1, level, &mut ar) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            return luaL_argerror(L, arg + 1 as i32, c"level out of range".as_ptr());
        }
        checkstack(L, L1, 1 as i32);
        name = lua_getlocal(L1, &mut ar, nvar);
        if !name.is_null() {
            lua_xmove(L1, L, 1 as i32);
            lua_pushstring(L, name);
            lua_rotate(L, -(2 as i32), 1 as i32);
            return 2 as i32;
        } else {
            lua_pushnil(L);
            return 1 as i32;
        }
    };
}
unsafe extern "C-unwind" fn db_setlocal(mut L: *mut lua_State) -> i32 {
    let mut arg: i32 = 0;
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut L1: *mut lua_State = getthread(L, &mut arg);
    let mut ar: lua_Debug = lua_Debug {
        event: 0,
        name: 0 as *const std::ffi::c_char,
        namewhat: 0 as *const std::ffi::c_char,
        what: 0 as *const std::ffi::c_char,
        source: 0 as *const std::ffi::c_char,
        srclen: 0,
        currentline: 0,
        linedefined: 0,
        lastlinedefined: 0,
        nups: 0,
        nparams: 0,
        isvararg: 0,
        istailcall: 0,
        ftransfer: 0,
        ntransfer: 0,
        short_src: [0; 60],
        i_ci: 0 as *mut CallInfo,
    };
    let mut level: i32 = luaL_checkinteger(L, arg + 1 as i32) as i32;
    let mut nvar: i32 = luaL_checkinteger(L, arg + 2 as i32) as i32;
    if ((lua_getstack(L1, level, &mut ar) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        return luaL_argerror(L, arg + 1 as i32, c"level out of range".as_ptr());
    }
    luaL_checkany(L, arg + 3 as i32);
    lua_settop(L, arg + 3 as i32);
    checkstack(L, L1, 1 as i32);
    lua_xmove(L, L1, 1 as i32);
    name = lua_setlocal(L1, &mut ar, nvar);
    if name.is_null() {
        lua_settop(L1, -(1 as i32) - 1 as i32);
    }
    lua_pushstring(L, name);
    return 1 as i32;
}
unsafe extern "C-unwind" fn auxupvalue(mut L: *mut lua_State, mut get: i32) -> i32 {
    let mut name: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut n: i32 = luaL_checkinteger(L, 2 as i32) as i32;
    luaL_checktype(L, 1 as i32, 6 as i32);
    name = if get != 0 {
        lua_getupvalue(L, 1 as i32, n)
    } else {
        lua_setupvalue(L, 1 as i32, n)
    };
    if name.is_null() {
        return 0;
    }
    lua_pushstring(L, name);
    lua_rotate(L, -(get + 1 as i32), 1 as i32);
    return get + 1 as i32;
}
unsafe extern "C-unwind" fn db_getupvalue(mut L: *mut lua_State) -> i32 {
    return auxupvalue(L, 1 as i32);
}
unsafe extern "C-unwind" fn db_setupvalue(mut L: *mut lua_State) -> i32 {
    luaL_checkany(L, 3 as i32);
    return auxupvalue(L, 0);
}
unsafe extern "C-unwind" fn checkupval(
    mut L: *mut lua_State,
    mut argf: i32,
    mut argnup: i32,
    mut pnup: *mut i32,
) -> *mut c_void {
    let mut id: *mut c_void = 0 as *mut c_void;
    let mut nup: i32 = luaL_checkinteger(L, argnup) as i32;
    luaL_checktype(L, argf, 6 as i32);
    id = lua_upvalueid(L, argf, nup);
    if !pnup.is_null() {
        (((id != 0 as *mut c_void) as i32 != 0) as i32 as std::ffi::c_long != 0
            || luaL_argerror(L, argnup, c"invalid upvalue index".as_ptr()) != 0) as i32;
        *pnup = nup;
    }
    return id;
}
unsafe extern "C-unwind" fn db_upvalueid(mut L: *mut lua_State) -> i32 {
    let mut id: *mut c_void = checkupval(L, 1 as i32, 2 as i32, 0 as *mut i32);
    if !id.is_null() {
        lua_pushlightuserdata(L, id);
    } else {
        lua_pushnil(L);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn db_upvaluejoin(mut L: *mut lua_State) -> i32 {
    let mut n1: i32 = 0;
    let mut n2: i32 = 0;
    checkupval(L, 1 as i32, 2 as i32, &mut n1);
    checkupval(L, 3 as i32, 4 as i32, &mut n2);
    (((lua_iscfunction(L, 1 as i32) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 1 as i32, c"Lua function expected".as_ptr()) != 0) as i32;
    (((lua_iscfunction(L, 3 as i32) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 3 as i32, c"Lua function expected".as_ptr()) != 0) as i32;
    lua_upvaluejoin(L, 1 as i32, n1, 3 as i32, n2);
    return 0;
}
unsafe extern "C-unwind" fn hookf(mut L: *mut lua_State, mut ar: *mut lua_Debug) {
    static mut hooknames: [*const std::ffi::c_char; 5] = [
        c"call".as_ptr(),
        c"return".as_ptr(),
        c"line".as_ptr(),
        c"count".as_ptr(),
        c"tail call".as_ptr(),
    ];
    lua_getfield(L, -(1000000) - 1000, HOOKKEY);
    lua_pushthread(L);
    if lua_rawget(L, -(2 as i32)) == 6 as i32 {
        lua_pushstring(L, hooknames[(*ar).event as usize]);
        if (*ar).currentline >= 0 {
            lua_pushinteger(L, (*ar).currentline as lua_Integer);
        } else {
            lua_pushnil(L);
        }
        lua_callk(L, 2 as i32, 0, 0 as lua_KContext, None);
    }
}
unsafe extern "C-unwind" fn makemask(mut smask: *const std::ffi::c_char, mut count: i32) -> i32 {
    let mut mask: i32 = 0;
    if !(strchr(smask, 'c' as i32)).is_null() {
        mask |= (1 as i32) << 0;
    }
    if !(strchr(smask, 'r' as i32)).is_null() {
        mask |= (1 as i32) << 1 as i32;
    }
    if !(strchr(smask, 'l' as i32)).is_null() {
        mask |= (1 as i32) << 2 as i32;
    }
    if count > 0 {
        mask |= (1 as i32) << 3 as i32;
    }
    return mask;
}
unsafe extern "C-unwind" fn unmakemask(
    mut mask: i32,
    mut smask: *mut std::ffi::c_char,
) -> *mut std::ffi::c_char {
    let mut i: i32 = 0;
    if mask & (1 as i32) << 0 != 0 {
        let fresh151 = i;
        i = i + 1;
        *smask.offset(fresh151 as isize) = 'c' as i32 as std::ffi::c_char;
    }
    if mask & (1 as i32) << 1 as i32 != 0 {
        let fresh152 = i;
        i = i + 1;
        *smask.offset(fresh152 as isize) = 'r' as i32 as std::ffi::c_char;
    }
    if mask & (1 as i32) << 2 as i32 != 0 {
        let fresh153 = i;
        i = i + 1;
        *smask.offset(fresh153 as isize) = 'l' as i32 as std::ffi::c_char;
    }
    *smask.offset(i as isize) = '\0' as i32 as std::ffi::c_char;
    return smask;
}
unsafe extern "C-unwind" fn db_sethook(mut L: *mut lua_State) -> i32 {
    let mut arg: i32 = 0;
    let mut mask: i32 = 0;
    let mut count: i32 = 0;
    let mut func: lua_Hook = None;
    let mut L1: *mut lua_State = getthread(L, &mut arg);
    if lua_type(L, arg + 1 as i32) <= 0 {
        lua_settop(L, arg + 1 as i32);
        func = None;
        mask = 0;
        count = 0;
    } else {
        let mut smask: *const std::ffi::c_char =
            luaL_checklstring(L, arg + 2 as i32, 0 as *mut size_t);
        luaL_checktype(L, arg + 1 as i32, 6 as i32);
        count = luaL_optinteger(L, arg + 3 as i32, 0 as lua_Integer) as i32;
        func = Some(hookf as unsafe extern "C-unwind" fn(*mut lua_State, *mut lua_Debug) -> ());
        mask = makemask(smask, count);
    }
    if luaL_getsubtable(L, -(1000000) - 1000, HOOKKEY) == 0 {
        lua_pushstring(L, c"k".as_ptr());
        lua_setfield(L, -(2 as i32), c"__mode".as_ptr());
        lua_pushvalue(L, -(1 as i32));
        lua_setmetatable(L, -(2 as i32));
    }
    checkstack(L, L1, 1 as i32);
    lua_pushthread(L1);
    lua_xmove(L1, L, 1 as i32);
    lua_pushvalue(L, arg + 1 as i32);
    lua_rawset(L, -(3 as i32));
    lua_sethook(L1, func, mask, count);
    return 0;
}
unsafe extern "C-unwind" fn db_gethook(mut L: *mut lua_State) -> i32 {
    let mut arg: i32 = 0;
    let mut L1: *mut lua_State = getthread(L, &mut arg);
    let mut buff: [std::ffi::c_char; 5] = [0; 5];
    let mut mask: i32 = lua_gethookmask(L1);
    let mut hook: lua_Hook = lua_gethook(L1);
    if hook.is_none() {
        lua_pushnil(L);
        return 1 as i32;
    } else if hook
        != Some(hookf as unsafe extern "C-unwind" fn(*mut lua_State, *mut lua_Debug) -> ())
    {
        lua_pushstring(L, c"external hook".as_ptr());
    } else {
        lua_getfield(L, -(1000000) - 1000, HOOKKEY);
        checkstack(L, L1, 1 as i32);
        lua_pushthread(L1);
        lua_xmove(L1, L, 1 as i32);
        lua_rawget(L, -(2 as i32));
        lua_rotate(L, -(2 as i32), -(1 as i32));
        lua_settop(L, -(1 as i32) - 1 as i32);
    }
    lua_pushstring(L, unmakemask(mask, buff.as_mut_ptr()));
    lua_pushinteger(L, lua_gethookcount(L1) as lua_Integer);
    return 3 as i32;
}
unsafe extern "C-unwind" fn db_debug(mut L: *mut lua_State) -> i32 {
    loop {
        let mut buffer: [std::ffi::c_char; 250] = [0; 250];
        fprintf(stderr, c"%s".as_ptr(), c"lua_debug> ".as_ptr());
        fflush(stderr);
        if (fgets(
            buffer.as_mut_ptr(),
            ::core::mem::size_of::<[std::ffi::c_char; 250]>() as usize as i32,
            stdin,
        ))
        .is_null()
            || strcmp(buffer.as_mut_ptr(), c"cont\n".as_ptr()) == 0
        {
            return 0;
        }
        if luaL_loadbufferx(
            L,
            buffer.as_mut_ptr(),
            strlen(buffer.as_mut_ptr()),
            c"=(debug command)".as_ptr(),
            0 as *const std::ffi::c_char,
        ) != 0
            || lua_pcallk(L, 0, 0, 0, 0 as lua_KContext, None) != 0
        {
            fprintf(
                stderr,
                c"%s\n".as_ptr(),
                luaL_tolstring(L, -(1 as i32), 0 as *mut size_t),
            );
            fflush(stderr);
        }
        lua_settop(L, 0);
    }
}
unsafe extern "C-unwind" fn db_traceback(mut L: *mut lua_State) -> i32 {
    let mut arg: i32 = 0;
    let mut L1: *mut lua_State = getthread(L, &mut arg);
    let mut msg: *const std::ffi::c_char = lua_tolstring(L, arg + 1 as i32, 0 as *mut size_t);
    if msg.is_null() && !(lua_type(L, arg + 1 as i32) <= 0) {
        lua_pushvalue(L, arg + 1 as i32);
    } else {
        let mut level: i32 = luaL_optinteger(
            L,
            arg + 2 as i32,
            (if L == L1 { 1 as i32 } else { 0 }) as lua_Integer,
        ) as i32;
        luaL_traceback(L, L1, msg, level);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn db_setcstacklimit(mut L: *mut lua_State) -> i32 {
    let mut limit: i32 = luaL_checkinteger(L, 1 as i32) as i32;
    let mut res: i32 = lua_setcstacklimit(L, limit as u32);
    lua_pushinteger(L, res as lua_Integer);
    return 1 as i32;
}
static mut dblib: [luaL_Reg; 18] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"debug".as_ptr(),
                func: Some(db_debug as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getuservalue".as_ptr(),
                func: Some(db_getuservalue as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"gethook".as_ptr(),
                func: Some(db_gethook as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getinfo".as_ptr(),
                func: Some(db_getinfo as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getlocal".as_ptr(),
                func: Some(db_getlocal as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getregistry".as_ptr(),
                func: Some(db_getregistry as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getmetatable".as_ptr(),
                func: Some(db_getmetatable as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getupvalue".as_ptr(),
                func: Some(db_getupvalue as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"upvaluejoin".as_ptr(),
                func: Some(db_upvaluejoin as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"upvalueid".as_ptr(),
                func: Some(db_upvalueid as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setuservalue".as_ptr(),
                func: Some(db_setuservalue as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"sethook".as_ptr(),
                func: Some(db_sethook as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setlocal".as_ptr(),
                func: Some(db_setlocal as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setmetatable".as_ptr(),
                func: Some(db_setmetatable as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setupvalue".as_ptr(),
                func: Some(db_setupvalue as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"traceback".as_ptr(),
                func: Some(db_traceback as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setcstacklimit".as_ptr(),
                func: Some(db_setcstacklimit as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_debug(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 18]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const dblib).cast(), 0);
    return 1 as i32;
}
unsafe extern "C-unwind" fn l_checkmode(mut mode: *const std::ffi::c_char) -> i32 {
    return (*mode as i32 != '\0' as i32
        && {
            let fresh154 = mode;
            mode = mode.offset(1);
            !(strchr(c"rwa".as_ptr(), *fresh154 as i32)).is_null()
        }
        && (*mode as i32 != '+' as i32 || {
            mode = mode.offset(1);
            mode;
            1 as i32 != 0
        })
        && strspn(mode, c"b".as_ptr()) == strlen(mode)) as i32;
}
unsafe extern "C-unwind" fn io_type(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = 0 as *mut LStream;
    luaL_checkany(L, 1 as i32);
    p = luaL_testudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    if p.is_null() {
        lua_pushnil(L);
    } else if ((*p).closef).is_none() {
        lua_pushstring(L, c"closed file".as_ptr());
    } else {
        lua_pushstring(L, c"file".as_ptr());
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn f_tostring(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = luaL_checkudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    if ((*p).closef).is_none() {
        lua_pushstring(L, c"file (closed)".as_ptr());
    } else {
        lua_pushfstring(L, c"file (%p)".as_ptr(), (*p).f);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn tofile(mut L: *mut lua_State) -> *mut FILE {
    let mut p: *mut LStream = luaL_checkudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    if (((*p).closef).is_none() as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(L, c"attempt to use a closed file".as_ptr());
    }
    return (*p).f;
}
unsafe extern "C-unwind" fn newprefile(mut L: *mut lua_State) -> *mut LStream {
    let mut p: *mut LStream =
        lua_newuserdatauv(L, ::core::mem::size_of::<LStream>() as usize, 0) as *mut LStream;
    (*p).closef = None;
    luaL_setmetatable(L, c"FILE*".as_ptr());
    return p;
}
unsafe extern "C-unwind" fn aux_close(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = luaL_checkudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    let mut cf: lua_CFunction = (*p).closef;
    (*p).closef = None;
    return (Some(cf.expect("non-null function pointer"))).expect("non-null function pointer")(L);
}
unsafe extern "C-unwind" fn f_close(mut L: *mut lua_State) -> i32 {
    tofile(L);
    return aux_close(L);
}
unsafe extern "C-unwind" fn io_close(mut L: *mut lua_State) -> i32 {
    if lua_type(L, 1 as i32) == -(1 as i32) {
        lua_getfield(L, -(1000000) - 1000, c"_IO_output".as_ptr());
    }
    return f_close(L);
}
unsafe extern "C-unwind" fn f_gc(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = luaL_checkudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    if ((*p).closef).is_some() && !((*p).f).is_null() {
        aux_close(L);
    }
    return 0;
}
unsafe extern "C-unwind" fn io_fclose(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = luaL_checkudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    *__errno_location() = 0;
    return luaL_fileresult(
        L,
        (fclose((*p).f) == 0) as i32,
        0 as *const std::ffi::c_char,
    );
}
unsafe extern "C-unwind" fn newfile(mut L: *mut lua_State) -> *mut LStream {
    let mut p: *mut LStream = newprefile(L);
    (*p).f = 0 as *mut FILE;
    (*p).closef = Some(io_fclose as unsafe extern "C-unwind" fn(*mut lua_State) -> i32);
    return p;
}
unsafe extern "C-unwind" fn opencheck(
    mut L: *mut lua_State,
    mut fname: *const std::ffi::c_char,
    mut mode: *const std::ffi::c_char,
) {
    let mut p: *mut LStream = newfile(L);
    (*p).f = fopen(fname, mode);
    if (((*p).f == 0 as *mut c_void as *mut FILE) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(
            L,
            c"cannot open file '%s' (%s)".as_ptr(),
            fname,
            strerror(*__errno_location()),
        );
    }
}
unsafe extern "C-unwind" fn io_open(mut L: *mut lua_State) -> i32 {
    let mut filename: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut mode: *const std::ffi::c_char =
        luaL_optlstring(L, 2 as i32, c"r".as_ptr(), 0 as *mut size_t);
    let mut p: *mut LStream = newfile(L);
    let mut md: *const std::ffi::c_char = mode;
    ((l_checkmode(md) != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 2 as i32, c"invalid mode".as_ptr()) != 0) as i32;
    *__errno_location() = 0;
    (*p).f = fopen(filename, mode);
    return if ((*p).f).is_null() {
        luaL_fileresult(L, 0, filename)
    } else {
        1 as i32
    };
}
unsafe extern "C-unwind" fn io_pclose(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = luaL_checkudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    *__errno_location() = 0;
    return luaL_execresult(L, pclose((*p).f));
}
unsafe extern "C-unwind" fn io_popen(mut L: *mut lua_State) -> i32 {
    let mut filename: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut mode: *const std::ffi::c_char =
        luaL_optlstring(L, 2 as i32, c"r".as_ptr(), 0 as *mut size_t);
    let mut p: *mut LStream = newprefile(L);
    ((((*mode.offset(0 as isize) as i32 == 'r' as i32
        || *mode.offset(0 as isize) as i32 == 'w' as i32)
        && *mode.offset(1) as i32 == '\0' as i32) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
        || luaL_argerror(L, 2 as i32, c"invalid mode".as_ptr()) != 0) as i32;
    *__errno_location() = 0;
    fflush(0 as *mut FILE);
    (*p).f = popen(filename, mode);
    (*p).closef = Some(io_pclose as unsafe extern "C-unwind" fn(*mut lua_State) -> i32);
    return if ((*p).f).is_null() {
        luaL_fileresult(L, 0, filename)
    } else {
        1 as i32
    };
}
unsafe extern "C-unwind" fn io_tmpfile(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = newfile(L);
    *__errno_location() = 0;
    (*p).f = tmpfile();
    return if ((*p).f).is_null() {
        luaL_fileresult(L, 0, 0 as *const std::ffi::c_char)
    } else {
        1 as i32
    };
}
unsafe extern "C-unwind" fn getiofile(
    mut L: *mut lua_State,
    mut findex: *const std::ffi::c_char,
) -> *mut FILE {
    let mut p: *mut LStream = 0 as *mut LStream;
    lua_getfield(L, -(1000000) - 1000, findex);
    p = lua_touserdata(L, -(1 as i32)) as *mut LStream;
    if (((*p).closef).is_none() as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(
            L,
            c"default %s file is closed".as_ptr(),
            findex.offset(
                (::core::mem::size_of::<[std::ffi::c_char; 5]>() as usize)
                    .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
                    .wrapping_sub(1) as isize,
            ),
        );
    }
    return (*p).f;
}
unsafe extern "C-unwind" fn g_iofile(
    mut L: *mut lua_State,
    mut f: *const std::ffi::c_char,
    mut mode: *const std::ffi::c_char,
) -> i32 {
    if !(lua_type(L, 1 as i32) <= 0) {
        let mut filename: *const std::ffi::c_char = lua_tolstring(L, 1 as i32, 0 as *mut size_t);
        if !filename.is_null() {
            opencheck(L, filename, mode);
        } else {
            tofile(L);
            lua_pushvalue(L, 1 as i32);
        }
        lua_setfield(L, -(1000000) - 1000, f);
    }
    lua_getfield(L, -(1000000) - 1000, f);
    return 1 as i32;
}
unsafe extern "C-unwind" fn io_input(mut L: *mut lua_State) -> i32 {
    return g_iofile(L, c"_IO_input".as_ptr(), c"r".as_ptr());
}
unsafe extern "C-unwind" fn io_output(mut L: *mut lua_State) -> i32 {
    return g_iofile(L, c"_IO_output".as_ptr(), c"w".as_ptr());
}
unsafe extern "C-unwind" fn aux_lines(mut L: *mut lua_State, mut toclose: i32) {
    let mut n: i32 = lua_gettop(L) - 1 as i32;
    (((n <= 250) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 250 + 2 as i32, c"too many arguments".as_ptr()) != 0) as i32;
    lua_pushvalue(L, 1 as i32);
    lua_pushinteger(L, n as lua_Integer);
    lua_pushboolean(L, toclose);
    lua_rotate(L, 2 as i32, 3 as i32);
    lua_pushcclosure(
        L,
        Some(io_readline as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
        3 as i32 + n,
    );
}
unsafe extern "C-unwind" fn f_lines(mut L: *mut lua_State) -> i32 {
    tofile(L);
    aux_lines(L, 0);
    return 1 as i32;
}
unsafe extern "C-unwind" fn io_lines(mut L: *mut lua_State) -> i32 {
    let mut toclose: i32 = 0;
    if lua_type(L, 1 as i32) == -(1 as i32) {
        lua_pushnil(L);
    }
    if lua_type(L, 1 as i32) == 0 {
        lua_getfield(L, -(1000000) - 1000, c"_IO_input".as_ptr());
        lua_copy(L, -(1 as i32), 1 as i32);
        lua_settop(L, -(1 as i32) - 1 as i32);
        tofile(L);
        toclose = 0;
    } else {
        let mut filename: *const std::ffi::c_char =
            luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
        opencheck(L, filename, c"r".as_ptr());
        lua_copy(L, -(1 as i32), 1 as i32);
        lua_settop(L, -(1 as i32) - 1 as i32);
        toclose = 1 as i32;
    }
    aux_lines(L, toclose);
    if toclose != 0 {
        lua_pushnil(L);
        lua_pushnil(L);
        lua_pushvalue(L, 1 as i32);
        return 4 as i32;
    } else {
        return 1 as i32;
    };
}
unsafe extern "C-unwind" fn nextc(mut rn: *mut RN) -> i32 {
    if (((*rn).n >= 200) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        (*rn).buff[0 as usize] = '\0' as i32 as std::ffi::c_char;
        return 0;
    } else {
        let fresh155 = (*rn).n;
        (*rn).n = (*rn).n + 1;
        (*rn).buff[fresh155 as usize] = (*rn).c as std::ffi::c_char;
        (*rn).c = getc_unlocked((*rn).f);
        return 1 as i32;
    };
}
unsafe extern "C-unwind" fn test2(mut rn: *mut RN, mut set: *const std::ffi::c_char) -> i32 {
    if (*rn).c == *set.offset(0 as isize) as i32 || (*rn).c == *set.offset(1) as i32 {
        return nextc(rn);
    } else {
        return 0;
    };
}
unsafe extern "C-unwind" fn readdigits(mut rn: *mut RN, mut hex: i32) -> i32 {
    let mut count: i32 = 0;
    while (if hex != 0 {
        *(*__ctype_b_loc()).offset((*rn).c as isize) as i32 & _ISxdigit as i32 as u16 as i32
    } else {
        *(*__ctype_b_loc()).offset((*rn).c as isize) as i32 & _ISdigit as i32 as u16 as i32
    }) != 0
        && nextc(rn) != 0
    {
        count += 1;
        count;
    }
    return count;
}
unsafe extern "C-unwind" fn read_number(mut L: *mut lua_State, mut f: *mut FILE) -> i32 {
    let mut rn: RN = RN {
        f: 0 as *mut FILE,
        c: 0,
        n: 0,
        buff: [0; 201],
    };
    let mut count: i32 = 0;
    let mut hex: i32 = 0;
    let mut decp: [std::ffi::c_char; 2] = [0; 2];
    rn.f = f;
    rn.n = 0;
    decp[0 as usize] = *((*localeconv()).decimal_point).offset(0 as isize);
    decp[1] = '.' as i32 as std::ffi::c_char;
    flockfile(rn.f);
    loop {
        rn.c = getc_unlocked(rn.f);
        if !(*(*__ctype_b_loc()).offset(rn.c as isize) as i32 & _ISspace as i32 as u16 as i32 != 0)
        {
            break;
        }
    }
    test2(&mut rn, c"-+".as_ptr());
    if test2(&mut rn, c"00".as_ptr()) != 0 {
        if test2(&mut rn, c"xX".as_ptr()) != 0 {
            hex = 1 as i32;
        } else {
            count = 1 as i32;
        }
    }
    count += readdigits(&mut rn, hex);
    if test2(&mut rn, decp.as_mut_ptr()) != 0 {
        count += readdigits(&mut rn, hex);
    }
    if count > 0
        && test2(
            &mut rn,
            (if hex != 0 {
                c"pP".as_ptr()
            } else {
                c"eE".as_ptr()
            }),
        ) != 0
    {
        test2(&mut rn, c"-+".as_ptr());
        readdigits(&mut rn, 0);
    }
    ungetc(rn.c, rn.f);
    funlockfile(rn.f);
    rn.buff[rn.n as usize] = '\0' as i32 as std::ffi::c_char;
    if (lua_stringtonumber(L, (rn.buff).as_mut_ptr()) != 0 as size_t) as i32 as std::ffi::c_long
        != 0
    {
        return 1 as i32;
    } else {
        lua_pushnil(L);
        return 0;
    };
}
unsafe extern "C-unwind" fn test_eof(mut L: *mut lua_State, mut f: *mut FILE) -> i32 {
    let mut c: i32 = getc(f);
    ungetc(c, f);
    lua_pushstring(L, c"".as_ptr());
    return (c != -(1 as i32)) as i32;
}
unsafe extern "C-unwind" fn read_line(
    mut L: *mut lua_State,
    mut f: *mut FILE,
    mut chop: i32,
) -> i32 {
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut c: i32 = 0;
    luaL_buffinit(L, &mut b);
    loop {
        let mut buff: *mut std::ffi::c_char = luaL_prepbuffsize(
            &mut b,
            (16usize)
                .wrapping_mul(::core::mem::size_of::<*mut c_void>() as usize)
                .wrapping_mul(::core::mem::size_of::<lua_Number>() as usize) as i32
                as size_t,
        );
        let mut i: i32 = 0;
        flockfile(f);
        while i
            < (16usize)
                .wrapping_mul(::core::mem::size_of::<*mut c_void>() as usize)
                .wrapping_mul(::core::mem::size_of::<lua_Number>() as usize) as i32
            && {
                c = getc_unlocked(f);
                c != -(1 as i32)
            }
            && c != '\n' as i32
        {
            let fresh156 = i;
            i = i + 1;
            *buff.offset(fresh156 as isize) = c as std::ffi::c_char;
        }
        funlockfile(f);
        b.n = (b.n).wrapping_add(i as size_t);
        if !(c != -(1 as i32) && c != '\n' as i32) {
            break;
        }
    }
    if chop == 0 && c == '\n' as i32 {
        (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
        let fresh157 = b.n;
        b.n = (b.n).wrapping_add(1);
        *(b.b).offset(fresh157 as isize) = c as std::ffi::c_char;
    }
    luaL_pushresult(&mut b);
    return (c == '\n' as i32 || lua_rawlen(L, -(1 as i32)) > 0 as lua_Unsigned) as i32;
}
unsafe extern "C-unwind" fn read_all(mut L: *mut lua_State, mut f: *mut FILE) {
    let mut nr: size_t = 0;
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    luaL_buffinit(L, &mut b);
    loop {
        let mut p: *mut std::ffi::c_char = luaL_prepbuffsize(
            &mut b,
            (16usize)
                .wrapping_mul(::core::mem::size_of::<*mut c_void>() as usize)
                .wrapping_mul(::core::mem::size_of::<lua_Number>() as usize) as i32
                as size_t,
        );
        nr = fread(
            p as *mut c_void,
            ::core::mem::size_of::<std::ffi::c_char>() as usize,
            (16usize)
                .wrapping_mul(::core::mem::size_of::<*mut c_void>() as usize)
                .wrapping_mul(::core::mem::size_of::<lua_Number>() as usize) as i32
                as usize,
            f,
        );
        b.n = (b.n).wrapping_add(nr);
        if !(nr
            == (16usize)
                .wrapping_mul(::core::mem::size_of::<*mut c_void>() as usize)
                .wrapping_mul(::core::mem::size_of::<lua_Number>() as usize) as i32
                as size_t)
        {
            break;
        }
    }
    luaL_pushresult(&mut b);
}
unsafe extern "C-unwind" fn read_chars(
    mut L: *mut lua_State,
    mut f: *mut FILE,
    mut n: size_t,
) -> i32 {
    let mut nr: size_t = 0;
    let mut p: *mut std::ffi::c_char = 0 as *mut std::ffi::c_char;
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    luaL_buffinit(L, &mut b);
    p = luaL_prepbuffsize(&mut b, n);
    nr = fread(
        p as *mut c_void,
        ::core::mem::size_of::<std::ffi::c_char>() as usize,
        n,
        f,
    );
    b.n = (b.n).wrapping_add(nr);
    luaL_pushresult(&mut b);
    return (nr > 0 as size_t) as i32;
}
unsafe extern "C-unwind" fn g_read(mut L: *mut lua_State, mut f: *mut FILE, mut first: i32) -> i32 {
    let mut nargs: i32 = lua_gettop(L) - 1 as i32;
    let mut n: i32 = 0;
    let mut success: i32 = 0;
    clearerr(f);
    *__errno_location() = 0;
    if nargs == 0 {
        success = read_line(L, f, 1 as i32);
        n = first + 1 as i32;
    } else {
        luaL_checkstack(L, nargs + 20, c"too many arguments".as_ptr());
        success = 1 as i32;
        n = first;
        loop {
            let fresh158 = nargs;
            nargs = nargs - 1;
            if !(fresh158 != 0 && success != 0) {
                break;
            }
            if lua_type(L, n) == 3 as i32 {
                let mut l: size_t = luaL_checkinteger(L, n) as size_t;
                success = if l == 0 as size_t {
                    test_eof(L, f)
                } else {
                    read_chars(L, f, l)
                };
            } else {
                let mut p: *const std::ffi::c_char = luaL_checklstring(L, n, 0 as *mut size_t);
                if *p as i32 == '*' as i32 {
                    p = p.offset(1);
                    p;
                }
                match *p as i32 {
                    110 => {
                        success = read_number(L, f);
                    }
                    108 => {
                        success = read_line(L, f, 1 as i32);
                    }
                    76 => {
                        success = read_line(L, f, 0);
                    }
                    97 => {
                        read_all(L, f);
                        success = 1 as i32;
                    }
                    _ => {
                        return luaL_argerror(L, n, c"invalid format".as_ptr());
                    }
                }
            }
            n += 1;
            n;
        }
    }
    if ferror(f) != 0 {
        return luaL_fileresult(L, 0, 0 as *const std::ffi::c_char);
    }
    if success == 0 {
        lua_settop(L, -(1 as i32) - 1 as i32);
        lua_pushnil(L);
    }
    return n - first;
}
unsafe extern "C-unwind" fn io_read(mut L: *mut lua_State) -> i32 {
    return g_read(L, getiofile(L, c"_IO_input".as_ptr()), 1 as i32);
}
unsafe extern "C-unwind" fn f_read(mut L: *mut lua_State) -> i32 {
    return g_read(L, tofile(L), 2 as i32);
}
unsafe extern "C-unwind" fn io_readline(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = lua_touserdata(L, -(1000000) - 1000 - 1 as i32) as *mut LStream;
    let mut i: i32 = 0;
    let mut n: i32 = lua_tointegerx(L, -(1000000) - 1000 - 2 as i32, 0 as *mut i32) as i32;
    if ((*p).closef).is_none() {
        return luaL_error(L, c"file is already closed".as_ptr());
    }
    lua_settop(L, 1 as i32);
    luaL_checkstack(L, n, c"too many arguments".as_ptr());
    i = 1 as i32;
    while i <= n {
        lua_pushvalue(L, -(1000000) - 1000 - (3 as i32 + i));
        i += 1;
        i;
    }
    n = g_read(L, (*p).f, 2 as i32);
    if lua_toboolean(L, -n) != 0 {
        return n;
    } else {
        if n > 1 as i32 {
            return luaL_error(
                L,
                c"%s".as_ptr(),
                lua_tolstring(L, -n + 1 as i32, 0 as *mut size_t),
            );
        }
        if lua_toboolean(L, -(1000000) - 1000 - 3 as i32) != 0 {
            lua_settop(L, 0);
            lua_pushvalue(L, -(1000000) - 1000 - 1 as i32);
            aux_close(L);
        }
        return 0;
    };
}
unsafe extern "C-unwind" fn g_write(mut L: *mut lua_State, mut f: *mut FILE, mut arg: i32) -> i32 {
    let mut nargs: i32 = lua_gettop(L) - arg;
    let mut status: i32 = 1 as i32;
    *__errno_location() = 0;
    loop {
        let fresh159 = nargs;
        nargs = nargs - 1;
        if !(fresh159 != 0) {
            break;
        }
        if lua_type(L, arg) == 3 as i32 {
            let mut len: i32 = if lua_isinteger(L, arg) != 0 {
                fprintf(f, c"%lld".as_ptr(), lua_tointegerx(L, arg, 0 as *mut i32))
            } else {
                fprintf(f, c"%.14g".as_ptr(), lua_tonumberx(L, arg, 0 as *mut i32))
            };
            status = (status != 0 && len > 0) as i32;
        } else {
            let mut l: size_t = 0;
            let mut s: *const std::ffi::c_char = luaL_checklstring(L, arg, &mut l);
            status = (status != 0
                && fwrite(
                    s as *const c_void,
                    ::core::mem::size_of::<std::ffi::c_char>() as usize,
                    l,
                    f,
                ) == l) as i32;
        }
        arg += 1;
        arg;
    }
    if (status != 0) as i32 as std::ffi::c_long != 0 {
        return 1 as i32;
    } else {
        return luaL_fileresult(L, status, 0 as *const std::ffi::c_char);
    };
}
unsafe extern "C-unwind" fn io_write(mut L: *mut lua_State) -> i32 {
    return g_write(L, getiofile(L, c"_IO_output".as_ptr()), 1 as i32);
}
unsafe extern "C-unwind" fn f_write(mut L: *mut lua_State) -> i32 {
    let mut f: *mut FILE = tofile(L);
    lua_pushvalue(L, 1 as i32);
    return g_write(L, f, 2 as i32);
}
unsafe extern "C-unwind" fn f_seek(mut L: *mut lua_State) -> i32 {
    static mut mode: [i32; 3] = [0, 1 as i32, 2 as i32];
    static mut modenames: [*const std::ffi::c_char; 4] = [
        c"set".as_ptr(),
        c"cur".as_ptr(),
        c"end".as_ptr(),
        0 as *const std::ffi::c_char,
    ];
    let mut f: *mut FILE = tofile(L);
    let mut op: i32 = luaL_checkoption(L, 2 as i32, c"cur".as_ptr(), (&raw const modenames).cast());
    let mut p3: lua_Integer = luaL_optinteger(L, 3 as i32, 0 as lua_Integer);
    let mut offset: off_t = p3 as off_t;
    (((offset as lua_Integer == p3) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 3 as i32, c"not an integer in proper range".as_ptr()) != 0) as i32;
    *__errno_location() = 0;
    op = fseeko(f, offset, mode[op as usize]);
    if (op != 0) as i32 as std::ffi::c_long != 0 {
        return luaL_fileresult(L, 0, 0 as *const std::ffi::c_char);
    } else {
        lua_pushinteger(L, ftello(f) as lua_Integer);
        return 1 as i32;
    };
}
unsafe extern "C-unwind" fn f_setvbuf(mut L: *mut lua_State) -> i32 {
    static mut mode: [i32; 3] = [2 as i32, 0, 1 as i32];
    static mut modenames: [*const std::ffi::c_char; 4] = [
        c"no".as_ptr(),
        c"full".as_ptr(),
        c"line".as_ptr(),
        0 as *const std::ffi::c_char,
    ];
    let mut f: *mut FILE = tofile(L);
    let mut op: i32 = luaL_checkoption(
        L,
        2 as i32,
        0 as *const std::ffi::c_char,
        (&raw const modenames).cast(),
    );
    let mut sz: lua_Integer = luaL_optinteger(
        L,
        3 as i32,
        (16usize)
            .wrapping_mul(::core::mem::size_of::<*mut c_void>() as usize)
            .wrapping_mul(::core::mem::size_of::<lua_Number>() as usize) as i32
            as lua_Integer,
    );
    let mut res: i32 = 0;
    *__errno_location() = 0;
    res = setvbuf(
        f,
        0 as *mut std::ffi::c_char,
        mode[op as usize],
        sz as size_t,
    );
    return luaL_fileresult(L, (res == 0) as i32, 0 as *const std::ffi::c_char);
}
unsafe extern "C-unwind" fn io_flush(mut L: *mut lua_State) -> i32 {
    let mut f: *mut FILE = getiofile(L, c"_IO_output".as_ptr());
    *__errno_location() = 0;
    return luaL_fileresult(L, (fflush(f) == 0) as i32, 0 as *const std::ffi::c_char);
}
unsafe extern "C-unwind" fn f_flush(mut L: *mut lua_State) -> i32 {
    let mut f: *mut FILE = tofile(L);
    *__errno_location() = 0;
    return luaL_fileresult(L, (fflush(f) == 0) as i32, 0 as *const std::ffi::c_char);
}
static mut iolib: [luaL_Reg; 12] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"close".as_ptr(),
                func: Some(io_close as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"flush".as_ptr(),
                func: Some(io_flush as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"input".as_ptr(),
                func: Some(io_input as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"lines".as_ptr(),
                func: Some(io_lines as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"open".as_ptr(),
                func: Some(io_open as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"output".as_ptr(),
                func: Some(io_output as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"popen".as_ptr(),
                func: Some(io_popen as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"read".as_ptr(),
                func: Some(io_read as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"tmpfile".as_ptr(),
                func: Some(io_tmpfile as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"type".as_ptr(),
                func: Some(io_type as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"write".as_ptr(),
                func: Some(io_write as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
static mut meth: [luaL_Reg; 8] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"read".as_ptr(),
                func: Some(f_read as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"write".as_ptr(),
                func: Some(f_write as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"lines".as_ptr(),
                func: Some(f_lines as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"flush".as_ptr(),
                func: Some(f_flush as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"seek".as_ptr(),
                func: Some(f_seek as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"close".as_ptr(),
                func: Some(f_close as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setvbuf".as_ptr(),
                func: Some(f_setvbuf as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
static mut metameth: [luaL_Reg; 5] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"__index".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__gc".as_ptr(),
                func: Some(f_gc as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__close".as_ptr(),
                func: Some(f_gc as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__tostring".as_ptr(),
                func: Some(f_tostring as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
unsafe extern "C-unwind" fn createmeta(mut L: *mut lua_State) {
    luaL_newmetatable(L, c"FILE*".as_ptr());
    luaL_setfuncs(L, (&raw const metameth).cast(), 0);
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 8]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const meth).cast(), 0);
    lua_setfield(L, -(2 as i32), c"__index".as_ptr());
    lua_settop(L, -(1 as i32) - 1 as i32);
}
unsafe extern "C-unwind" fn io_noclose(mut L: *mut lua_State) -> i32 {
    let mut p: *mut LStream = luaL_checkudata(L, 1 as i32, c"FILE*".as_ptr()) as *mut LStream;
    (*p).closef = Some(io_noclose as unsafe extern "C-unwind" fn(*mut lua_State) -> i32);
    lua_pushnil(L);
    lua_pushstring(L, c"cannot close standard file".as_ptr());
    return 2 as i32;
}
unsafe extern "C-unwind" fn createstdfile(
    mut L: *mut lua_State,
    mut f: *mut FILE,
    mut k: *const std::ffi::c_char,
    mut fname: *const std::ffi::c_char,
) {
    let mut p: *mut LStream = newprefile(L);
    (*p).f = f;
    (*p).closef = Some(io_noclose as unsafe extern "C-unwind" fn(*mut lua_State) -> i32);
    if !k.is_null() {
        lua_pushvalue(L, -(1 as i32));
        lua_setfield(L, -(1000000) - 1000, k);
    }
    lua_setfield(L, -(2 as i32), fname);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_io(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 12]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const iolib).cast(), 0);
    createmeta(L);
    createstdfile(L, stdin, c"_IO_input".as_ptr(), c"stdin".as_ptr());
    createstdfile(L, stdout, c"_IO_output".as_ptr(), c"stdout".as_ptr());
    createstdfile(L, stderr, 0 as *const std::ffi::c_char, c"stderr".as_ptr());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_abs(mut L: *mut lua_State) -> i32 {
    if lua_isinteger(L, 1 as i32) != 0 {
        let mut n: lua_Integer = lua_tointegerx(L, 1 as i32, 0 as *mut i32);
        if n < 0 as lua_Integer {
            n = (0 as u32 as lua_Unsigned).wrapping_sub(n as lua_Unsigned) as lua_Integer;
        }
        lua_pushinteger(L, n);
    } else {
        lua_pushnumber(L, luaL_checknumber(L, 1 as i32).abs());
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_sin(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(L, luaL_checknumber(L, 1 as i32).sin());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_cos(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(L, luaL_checknumber(L, 1 as i32).cos());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_tan(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(L, luaL_checknumber(L, 1 as i32).tan());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_asin(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(L, luaL_checknumber(L, 1 as i32).asin());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_acos(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(L, luaL_checknumber(L, 1 as i32).acos());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_atan(mut L: *mut lua_State) -> i32 {
    let mut y: lua_Number = luaL_checknumber(L, 1 as i32);
    let mut x: lua_Number = luaL_optnumber(L, 2 as i32, 1 as i32 as lua_Number);
    lua_pushnumber(L, y.atan2(x));
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_toint(mut L: *mut lua_State) -> i32 {
    let mut valid: i32 = 0;
    let mut n: lua_Integer = lua_tointegerx(L, 1 as i32, &mut valid);
    if (valid != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushinteger(L, n);
    } else {
        luaL_checkany(L, 1 as i32);
        lua_pushnil(L);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn pushnumint(mut L: *mut lua_State, mut d: lua_Number) {
    let mut n: lua_Integer = 0;
    if d >= (-(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong)
        as std::ffi::c_double
        && d < -((-(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong)
            as std::ffi::c_double)
        && {
            n = d as std::ffi::c_longlong;
            1 as i32 != 0
        }
    {
        lua_pushinteger(L, n);
    } else {
        lua_pushnumber(L, d);
    };
}
unsafe extern "C-unwind" fn math_floor(mut L: *mut lua_State) -> i32 {
    if lua_isinteger(L, 1 as i32) != 0 {
        lua_settop(L, 1 as i32);
    } else {
        let mut d: lua_Number = luaL_checknumber(L, 1 as i32).floor();
        pushnumint(L, d);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_ceil(mut L: *mut lua_State) -> i32 {
    if lua_isinteger(L, 1 as i32) != 0 {
        lua_settop(L, 1 as i32);
    } else {
        let mut d: lua_Number = luaL_checknumber(L, 1 as i32).ceil();
        pushnumint(L, d);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_fmod(mut L: *mut lua_State) -> i32 {
    if lua_isinteger(L, 1 as i32) != 0 && lua_isinteger(L, 2 as i32) != 0 {
        let mut d: lua_Integer = lua_tointegerx(L, 2 as i32, 0 as *mut i32);
        if (d as lua_Unsigned).wrapping_add(1 as u32 as lua_Unsigned) <= 1 as u32 as lua_Unsigned {
            (((d != 0 as lua_Integer) as i32 != 0) as i32 as std::ffi::c_long != 0
                || luaL_argerror(L, 2 as i32, c"zero".as_ptr()) != 0) as i32;
            lua_pushinteger(L, 0 as lua_Integer);
        } else {
            lua_pushinteger(L, lua_tointegerx(L, 1 as i32, 0 as *mut i32) % d);
        }
    } else {
        lua_pushnumber(
            L,
            fmod(luaL_checknumber(L, 1 as i32), luaL_checknumber(L, 2 as i32)),
        );
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_modf(mut L: *mut lua_State) -> i32 {
    if lua_isinteger(L, 1 as i32) != 0 {
        lua_settop(L, 1 as i32);
        lua_pushnumber(L, 0 as lua_Number);
    } else {
        let mut n: lua_Number = luaL_checknumber(L, 1 as i32);
        let mut ip: lua_Number = if n < 0 as lua_Number {
            n.ceil()
        } else {
            n.floor()
        };
        pushnumint(L, ip);
        lua_pushnumber(L, if n == ip { 0.0f64 } else { n - ip });
    }
    return 2 as i32;
}
unsafe extern "C-unwind" fn math_sqrt(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(L, luaL_checknumber(L, 1 as i32).sqrt());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_ult(mut L: *mut lua_State) -> i32 {
    let mut a: lua_Integer = luaL_checkinteger(L, 1 as i32);
    let mut b: lua_Integer = luaL_checkinteger(L, 2 as i32);
    lua_pushboolean(L, ((a as lua_Unsigned) < b as lua_Unsigned) as i32);
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_log(mut L: *mut lua_State) -> i32 {
    let mut x: lua_Number = luaL_checknumber(L, 1 as i32);
    let mut res: lua_Number = 0.;
    if lua_type(L, 2 as i32) <= 0 {
        res = x.ln();
    } else {
        let mut base: lua_Number = luaL_checknumber(L, 2 as i32);
        if base == 2.0f64 {
            res = x.log2();
        } else if base == 10.0f64 {
            res = x.log10();
        } else {
            res = x.log(base);
        }
    }
    lua_pushnumber(L, res);
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_exp(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(L, luaL_checknumber(L, 1 as i32).exp());
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_deg(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(
        L,
        luaL_checknumber(L, 1 as i32) * (180.0f64 / 3.141592653589793238462643383279502884f64),
    );
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_rad(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(
        L,
        luaL_checknumber(L, 1 as i32) * (3.141592653589793238462643383279502884f64 / 180.0f64),
    );
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_min(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = lua_gettop(L);
    let mut imin: i32 = 1 as i32;
    let mut i: i32 = 0;
    (((n >= 1 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 1 as i32, c"value expected".as_ptr()) != 0) as i32;
    i = 2 as i32;
    while i <= n {
        if lua_compare(L, i, imin, 1 as i32) != 0 {
            imin = i;
        }
        i += 1;
        i;
    }
    lua_pushvalue(L, imin);
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_max(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = lua_gettop(L);
    let mut imax: i32 = 1 as i32;
    let mut i: i32 = 0;
    (((n >= 1 as i32) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 1 as i32, c"value expected".as_ptr()) != 0) as i32;
    i = 2 as i32;
    while i <= n {
        if lua_compare(L, imax, i, 1 as i32) != 0 {
            imax = i;
        }
        i += 1;
        i;
    }
    lua_pushvalue(L, imax);
    return 1 as i32;
}
unsafe extern "C-unwind" fn math_type(mut L: *mut lua_State) -> i32 {
    if lua_type(L, 1 as i32) == 3 as i32 {
        lua_pushstring(
            L,
            if lua_isinteger(L, 1 as i32) != 0 {
                c"integer".as_ptr()
            } else {
                c"float".as_ptr()
            },
        );
    } else {
        luaL_checkany(L, 1 as i32);
        lua_pushnil(L);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn rotl(mut x: usize, mut n: i32) -> usize {
    return x << n | (x & 0xffffffffffffffff as usize) >> 64 as i32 - n;
}
unsafe extern "C-unwind" fn nextrand(mut state: *mut usize) -> usize {
    let mut state0: usize = *state.offset(0 as isize);
    let mut state1: usize = *state.offset(1);
    let mut state2: usize = *state.offset(2) ^ state0;
    let mut state3: usize = *state.offset(3) ^ state1;
    let mut res: usize = (rotl(state1.wrapping_mul(5), 7 as i32)).wrapping_mul(9);
    *state.offset(0 as isize) = state0 ^ state3;
    *state.offset(1) = state1 ^ state2;
    *state.offset(2) = state2 ^ state1 << 17 as i32;
    *state.offset(3) = rotl(state3, 45 as i32);
    return res;
}
unsafe extern "C-unwind" fn I2d(mut x: usize) -> lua_Number {
    let mut sx: std::ffi::c_long =
        ((x & 0xffffffffffffffff as usize) >> 64 as i32 - 53 as i32) as std::ffi::c_long;
    let mut res: lua_Number =
        sx as lua_Number * (0.5f64 / ((1usize) << 53 as i32 - 1 as i32) as std::ffi::c_double);
    if sx < 0 as std::ffi::c_long {
        res += 1.0f64;
    }
    return res;
}
unsafe extern "C-unwind" fn project(
    mut ran: lua_Unsigned,
    mut n: lua_Unsigned,
    mut state: *mut RanState,
) -> lua_Unsigned {
    if n & n.wrapping_add(1 as i32 as lua_Unsigned) == 0 as lua_Unsigned {
        return ran & n;
    } else {
        let mut lim: lua_Unsigned = n;
        lim |= lim >> 1 as i32;
        lim |= lim >> 2 as i32;
        lim |= lim >> 4 as i32;
        lim |= lim >> 8 as i32;
        lim |= lim >> 16 as i32;
        lim |= lim >> 32 as i32;
        loop {
            ran &= lim;
            if !(ran > n) {
                break;
            }
            ran =
                (nextrand(((*state).s).as_mut_ptr()) & 0xffffffffffffffff as usize) as lua_Unsigned;
        }
        return ran;
    };
}
unsafe extern "C-unwind" fn math_random(mut L: *mut lua_State) -> i32 {
    let mut low: lua_Integer = 0;
    let mut up: lua_Integer = 0;
    let mut p: lua_Unsigned = 0;
    let mut state: *mut RanState = lua_touserdata(L, -(1000000) - 1000 - 1 as i32) as *mut RanState;
    let mut rv: usize = nextrand(((*state).s).as_mut_ptr());
    match lua_gettop(L) {
        0 => {
            lua_pushnumber(L, I2d(rv));
            return 1 as i32;
        }
        1 => {
            low = 1 as i32 as lua_Integer;
            up = luaL_checkinteger(L, 1 as i32);
            if up == 0 as lua_Integer {
                lua_pushinteger(
                    L,
                    (rv & 0xffffffffffffffff as usize) as lua_Unsigned as lua_Integer,
                );
                return 1 as i32;
            }
        }
        2 => {
            low = luaL_checkinteger(L, 1 as i32);
            up = luaL_checkinteger(L, 2 as i32);
        }
        _ => {
            return luaL_error(L, c"wrong number of arguments".as_ptr());
        }
    }
    (((low <= up) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 1 as i32, c"interval is empty".as_ptr()) != 0) as i32;
    p = project(
        (rv & 0xffffffffffffffff as usize) as lua_Unsigned,
        (up as lua_Unsigned).wrapping_sub(low as lua_Unsigned),
        state,
    );
    lua_pushinteger(L, p.wrapping_add(low as lua_Unsigned) as lua_Integer);
    return 1 as i32;
}
unsafe extern "C-unwind" fn setseed(
    mut L: *mut lua_State,
    mut state: *mut usize,
    mut n1: lua_Unsigned,
    mut n2: lua_Unsigned,
) {
    let mut i: i32 = 0;
    *state.offset(0 as isize) = n1 as usize;
    *state.offset(1) = 0xff as i32 as usize;
    *state.offset(2) = n2 as usize;
    *state.offset(3) = 0 as usize;
    i = 0;
    while i < 16 as i32 {
        nextrand(state);
        i += 1;
        i;
    }
    lua_pushinteger(L, n1 as lua_Integer);
    lua_pushinteger(L, n2 as lua_Integer);
}
unsafe extern "C-unwind" fn randseed(mut L: *mut lua_State, mut state: *mut RanState) {
    let mut seed1: lua_Unsigned = time(0 as *mut time_t) as lua_Unsigned;
    let mut seed2: lua_Unsigned = L as size_t as lua_Unsigned;
    setseed(L, ((*state).s).as_mut_ptr(), seed1, seed2);
}
unsafe extern "C-unwind" fn math_randomseed(mut L: *mut lua_State) -> i32 {
    let mut state: *mut RanState = lua_touserdata(L, -(1000000) - 1000 - 1 as i32) as *mut RanState;
    if lua_type(L, 1 as i32) == -(1 as i32) {
        randseed(L, state);
    } else {
        let mut n1: lua_Integer = luaL_checkinteger(L, 1 as i32);
        let mut n2: lua_Integer = luaL_optinteger(L, 2 as i32, 0 as lua_Integer);
        setseed(
            L,
            ((*state).s).as_mut_ptr(),
            n1 as lua_Unsigned,
            n2 as lua_Unsigned,
        );
    }
    return 2 as i32;
}
static mut randfuncs: [luaL_Reg; 3] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"random".as_ptr(),
                func: Some(math_random as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"randomseed".as_ptr(),
                func: Some(math_randomseed as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
unsafe extern "C-unwind" fn setrandfunc(mut L: *mut lua_State) {
    let mut state: *mut RanState =
        lua_newuserdatauv(L, ::core::mem::size_of::<RanState>() as usize, 0) as *mut RanState;
    randseed(L, state);
    lua_settop(L, -(2 as i32) - 1 as i32);
    luaL_setfuncs(L, (&raw const randfuncs).cast(), 1 as i32);
}
static mut mathlib: [luaL_Reg; 28] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"abs".as_ptr(),
                func: Some(math_abs as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"acos".as_ptr(),
                func: Some(math_acos as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"asin".as_ptr(),
                func: Some(math_asin as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"atan".as_ptr(),
                func: Some(math_atan as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"ceil".as_ptr(),
                func: Some(math_ceil as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"cos".as_ptr(),
                func: Some(math_cos as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"deg".as_ptr(),
                func: Some(math_deg as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"exp".as_ptr(),
                func: Some(math_exp as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"tointeger".as_ptr(),
                func: Some(math_toint as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"floor".as_ptr(),
                func: Some(math_floor as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"fmod".as_ptr(),
                func: Some(math_fmod as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"ult".as_ptr(),
                func: Some(math_ult as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"log".as_ptr(),
                func: Some(math_log as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"max".as_ptr(),
                func: Some(math_max as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"min".as_ptr(),
                func: Some(math_min as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"modf".as_ptr(),
                func: Some(math_modf as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"rad".as_ptr(),
                func: Some(math_rad as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"sin".as_ptr(),
                func: Some(math_sin as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"sqrt".as_ptr(),
                func: Some(math_sqrt as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"tan".as_ptr(),
                func: Some(math_tan as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"type".as_ptr(),
                func: Some(math_type as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"random".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"randomseed".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"pi".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"huge".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"maxinteger".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"mininteger".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_math(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 28]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const mathlib).cast(), 0);
    lua_pushnumber(L, 3.141592653589793238462643383279502884f64);
    lua_setfield(L, -(2 as i32), c"pi".as_ptr());
    lua_pushnumber(L, ::core::f64::INFINITY);
    lua_setfield(L, -(2 as i32), c"huge".as_ptr());
    lua_pushinteger(L, 9223372036854775807 as std::ffi::c_longlong);
    lua_setfield(L, -(2 as i32), c"maxinteger".as_ptr());
    lua_pushinteger(
        L,
        -(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong,
    );
    lua_setfield(L, -(2 as i32), c"mininteger".as_ptr());
    setrandfunc(L);
    return 1 as i32;
}
static mut CLIBS: *const std::ffi::c_char = c"_CLIBS".as_ptr();
unsafe extern "C-unwind" fn lsys_unloadlib(mut lib: *mut c_void) {
    dlclose(lib);
}
unsafe extern "C-unwind" fn lsys_load(
    mut L: *mut lua_State,
    mut path: *const std::ffi::c_char,
    mut seeglb: i32,
) -> *mut c_void {
    let mut lib: *mut c_void = dlopen(path, 0x2 as i32 | (if seeglb != 0 { 0x100 } else { 0 }));
    if ((lib == 0 as *mut c_void) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushstring(L, dlerror());
    }
    return lib;
}
unsafe extern "C-unwind" fn lsys_sym(
    mut L: *mut lua_State,
    mut lib: *mut c_void,
    mut sym: *const std::ffi::c_char,
) -> lua_CFunction {
    let mut f: lua_CFunction =
        ::core::mem::transmute::<*mut c_void, lua_CFunction>(dlsym(lib, sym));
    if (f.is_none() as i32 != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushstring(L, dlerror());
    }
    return f;
}
unsafe extern "C-unwind" fn noenv(mut L: *mut lua_State) -> i32 {
    let mut b: i32 = 0;
    lua_getfield(L, -(1000000) - 1000, c"LUA_NOENV".as_ptr());
    b = lua_toboolean(L, -(1 as i32));
    lua_settop(L, -(1 as i32) - 1 as i32);
    return b;
}
unsafe extern "C-unwind" fn setpath(
    mut L: *mut lua_State,
    mut fieldname: *const std::ffi::c_char,
    mut envname: *const std::ffi::c_char,
    mut dft: *const std::ffi::c_char,
) {
    let mut dftmark: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut nver: *const std::ffi::c_char =
        lua_pushfstring(L, c"%s%s".as_ptr(), envname, c"_5_4".as_ptr());
    let mut path: *const std::ffi::c_char = getenv(nver);
    if path.is_null() {
        path = getenv(envname);
    }
    if path.is_null() || noenv(L) != 0 {
        lua_pushstring(L, dft);
    } else {
        dftmark = strstr(path, c";;".as_ptr());
        if dftmark.is_null() {
            lua_pushstring(L, path);
        } else {
            let mut len: size_t = strlen(path);
            let mut b: luaL_Buffer = luaL_Buffer {
                b: 0 as *mut std::ffi::c_char,
                size: 0,
                n: 0,
                L: 0 as *mut lua_State,
                init: C2RustUnnamed_15 { n: 0. },
            };
            luaL_buffinit(L, &mut b);
            if path < dftmark {
                luaL_addlstring(
                    &mut b,
                    path,
                    dftmark.offset_from(path) as std::ffi::c_long as size_t,
                );
                (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
                let fresh160 = b.n;
                b.n = (b.n).wrapping_add(1);
                *(b.b).offset(fresh160 as isize) = *(c";".as_ptr());
            }
            luaL_addstring(&mut b, dft);
            if dftmark < path.offset(len as isize).offset(-(2)) {
                (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
                let fresh161 = b.n;
                b.n = (b.n).wrapping_add(1);
                *(b.b).offset(fresh161 as isize) = *(c";".as_ptr());
                luaL_addlstring(
                    &mut b,
                    dftmark.offset(2),
                    path.offset(len as isize).offset(-(2)).offset_from(dftmark) as std::ffi::c_long
                        as size_t,
                );
            }
            luaL_pushresult(&mut b);
        }
    }
    lua_setfield(L, -(3 as i32), fieldname);
    lua_settop(L, -(1 as i32) - 1 as i32);
}
unsafe extern "C-unwind" fn checkclib(
    mut L: *mut lua_State,
    mut path: *const std::ffi::c_char,
) -> *mut c_void {
    let mut plib: *mut c_void = 0 as *mut c_void;
    lua_getfield(L, -(1000000) - 1000, CLIBS);
    lua_getfield(L, -(1 as i32), path);
    plib = lua_touserdata(L, -(1 as i32));
    lua_settop(L, -(2 as i32) - 1 as i32);
    return plib;
}
unsafe extern "C-unwind" fn addtoclib(
    mut L: *mut lua_State,
    mut path: *const std::ffi::c_char,
    mut plib: *mut c_void,
) {
    lua_getfield(L, -(1000000) - 1000, CLIBS);
    lua_pushlightuserdata(L, plib);
    lua_pushvalue(L, -(1 as i32));
    lua_setfield(L, -(3 as i32), path);
    lua_rawseti(
        L,
        -(2 as i32),
        luaL_len(L, -(2 as i32)) + 1 as i32 as lua_Integer,
    );
    lua_settop(L, -(1 as i32) - 1 as i32);
}
unsafe extern "C-unwind" fn gctm(mut L: *mut lua_State) -> i32 {
    let mut n: lua_Integer = luaL_len(L, 1 as i32);
    while n >= 1 as i32 as lua_Integer {
        lua_rawgeti(L, 1 as i32, n);
        lsys_unloadlib(lua_touserdata(L, -(1 as i32)));
        lua_settop(L, -(1 as i32) - 1 as i32);
        n -= 1;
        n;
    }
    return 0;
}
unsafe extern "C-unwind" fn lookforfunc(
    mut L: *mut lua_State,
    mut path: *const std::ffi::c_char,
    mut sym: *const std::ffi::c_char,
) -> i32 {
    let mut reg: *mut c_void = checkclib(L, path);
    if reg.is_null() {
        reg = lsys_load(L, path, (*sym as i32 == '*' as i32) as i32);
        if reg.is_null() {
            return 1 as i32;
        }
        addtoclib(L, path, reg);
    }
    if *sym as i32 == '*' as i32 {
        lua_pushboolean(L, 1 as i32);
        return 0;
    } else {
        let mut f: lua_CFunction = lsys_sym(L, reg, sym);
        if f.is_none() {
            return 2 as i32;
        }
        lua_pushcclosure(L, f, 0);
        return 0;
    };
}
unsafe extern "C-unwind" fn ll_loadlib(mut L: *mut lua_State) -> i32 {
    let mut path: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut init: *const std::ffi::c_char = luaL_checklstring(L, 2 as i32, 0 as *mut size_t);
    let mut stat: i32 = lookforfunc(L, path, init);
    if ((stat == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        return 1 as i32;
    } else {
        lua_pushnil(L);
        lua_rotate(L, -(2 as i32), 1 as i32);
        lua_pushstring(
            L,
            if stat == 1 as i32 {
                c"open".as_ptr()
            } else {
                c"init".as_ptr()
            },
        );
        return 3 as i32;
    };
}
unsafe extern "C-unwind" fn readable(mut filename: *const std::ffi::c_char) -> i32 {
    let mut f: *mut FILE = fopen(filename, c"r".as_ptr());
    if f.is_null() {
        return 0;
    }
    fclose(f);
    return 1 as i32;
}
unsafe extern "C-unwind" fn getnextfilename(
    mut path: *mut *mut std::ffi::c_char,
    mut end: *mut std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut sep: *mut std::ffi::c_char = 0 as *mut std::ffi::c_char;
    let mut name: *mut std::ffi::c_char = *path;
    if name == end {
        return 0 as *const std::ffi::c_char;
    } else if *name as i32 == '\0' as i32 {
        *name = *(c";".as_ptr());
        name = name.offset(1);
        name;
    }
    sep = strchr(name, *(c";".as_ptr()) as i32);
    if sep.is_null() {
        sep = end;
    }
    *sep = '\0' as i32 as std::ffi::c_char;
    *path = sep;
    return name;
}
unsafe extern "C-unwind" fn pusherrornotfound(
    mut L: *mut lua_State,
    mut path: *const std::ffi::c_char,
) {
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    luaL_buffinit(L, &mut b);
    luaL_addstring(&mut b, c"no file '".as_ptr());
    luaL_addgsub(&mut b, path, c";".as_ptr(), c"'\n\tno file '".as_ptr());
    luaL_addstring(&mut b, c"'".as_ptr());
    luaL_pushresult(&mut b);
}
unsafe extern "C-unwind" fn searchpath(
    mut L: *mut lua_State,
    mut name: *const std::ffi::c_char,
    mut path: *const std::ffi::c_char,
    mut sep: *const std::ffi::c_char,
    mut dirsep: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut buff: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut pathname: *mut std::ffi::c_char = 0 as *mut std::ffi::c_char;
    let mut endpathname: *mut std::ffi::c_char = 0 as *mut std::ffi::c_char;
    let mut filename: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if *sep as i32 != '\0' as i32 && !(strchr(name, *sep as i32)).is_null() {
        name = luaL_gsub(L, name, sep, dirsep);
    }
    luaL_buffinit(L, &mut buff);
    luaL_addgsub(&mut buff, path, c"?".as_ptr(), name);
    (buff.n < buff.size || !(luaL_prepbuffsize(&mut buff, 1 as i32 as size_t)).is_null()) as i32;
    let fresh162 = buff.n;
    buff.n = (buff.n).wrapping_add(1);
    *(buff.b).offset(fresh162 as isize) = '\0' as i32 as std::ffi::c_char;
    pathname = buff.b;
    endpathname = pathname.offset(buff.n as isize).offset(-(1));
    loop {
        filename = getnextfilename(&mut pathname, endpathname);
        if filename.is_null() {
            break;
        }
        if readable(filename) != 0 {
            return lua_pushstring(L, filename);
        }
    }
    luaL_pushresult(&mut buff);
    pusherrornotfound(L, lua_tolstring(L, -(1 as i32), 0 as *mut size_t));
    return 0 as *const std::ffi::c_char;
}
unsafe extern "C-unwind" fn ll_searchpath(mut L: *mut lua_State) -> i32 {
    let mut f: *const std::ffi::c_char = searchpath(
        L,
        luaL_checklstring(L, 1 as i32, 0 as *mut size_t),
        luaL_checklstring(L, 2 as i32, 0 as *mut size_t),
        luaL_optlstring(L, 3 as i32, c".".as_ptr(), 0 as *mut size_t),
        luaL_optlstring(L, 4 as i32, c"/".as_ptr(), 0 as *mut size_t),
    );
    if !f.is_null() {
        return 1 as i32;
    } else {
        lua_pushnil(L);
        lua_rotate(L, -(2 as i32), 1 as i32);
        return 2 as i32;
    };
}
unsafe extern "C-unwind" fn findfile(
    mut L: *mut lua_State,
    mut name: *const std::ffi::c_char,
    mut pname: *const std::ffi::c_char,
    mut dirsep: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut path: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    lua_getfield(L, -(1000000) - 1000 - 1 as i32, pname);
    path = lua_tolstring(L, -(1 as i32), 0 as *mut size_t);
    if ((path == 0 as *mut c_void as *const std::ffi::c_char) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
    {
        luaL_error(L, c"'package.%s' must be a string".as_ptr(), pname);
    }
    return searchpath(L, name, path, c".".as_ptr(), dirsep);
}
unsafe extern "C-unwind" fn checkload(
    mut L: *mut lua_State,
    mut stat: i32,
    mut filename: *const std::ffi::c_char,
) -> i32 {
    if (stat != 0) as i32 as std::ffi::c_long != 0 {
        lua_pushstring(L, filename);
        return 2 as i32;
    } else {
        return luaL_error(
            L,
            c"error loading module '%s' from file '%s':\n\t%s".as_ptr(),
            lua_tolstring(L, 1 as i32, 0 as *mut size_t),
            filename,
            lua_tolstring(L, -(1 as i32), 0 as *mut size_t),
        );
    };
}
unsafe extern "C-unwind" fn searcher_Lua(mut L: *mut lua_State) -> i32 {
    let mut filename: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut name: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    filename = findfile(L, name, c"path".as_ptr(), c"/".as_ptr());
    if filename.is_null() {
        return 1 as i32;
    }
    return checkload(
        L,
        (luaL_loadfilex(L, filename, 0 as *const std::ffi::c_char) == 0) as i32,
        filename,
    );
}
unsafe extern "C-unwind" fn loadfunc(
    mut L: *mut lua_State,
    mut filename: *const std::ffi::c_char,
    mut modname: *const std::ffi::c_char,
) -> i32 {
    let mut openfunc: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut mark: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    modname = luaL_gsub(L, modname, c".".as_ptr(), c"_".as_ptr());
    mark = strchr(modname, *(c"-".as_ptr()) as i32);
    if !mark.is_null() {
        let mut stat: i32 = 0;
        openfunc = lua_pushlstring(
            L,
            modname,
            mark.offset_from(modname) as std::ffi::c_long as size_t,
        );
        openfunc = lua_pushfstring(L, c"luaopen_%s".as_ptr(), openfunc);
        stat = lookforfunc(L, filename, openfunc);
        if stat != 2 as i32 {
            return stat;
        }
        modname = mark.offset(1);
    }
    openfunc = lua_pushfstring(L, c"luaopen_%s".as_ptr(), modname);
    return lookforfunc(L, filename, openfunc);
}
unsafe extern "C-unwind" fn searcher_C(mut L: *mut lua_State) -> i32 {
    let mut name: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut filename: *const std::ffi::c_char = findfile(L, name, c"cpath".as_ptr(), c"/".as_ptr());
    if filename.is_null() {
        return 1 as i32;
    }
    return checkload(L, (loadfunc(L, filename, name) == 0) as i32, filename);
}
unsafe extern "C-unwind" fn searcher_Croot(mut L: *mut lua_State) -> i32 {
    let mut filename: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut name: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut p: *const std::ffi::c_char = strchr(name, '.' as i32);
    let mut stat: i32 = 0;
    if p.is_null() {
        return 0;
    }
    lua_pushlstring(L, name, p.offset_from(name) as std::ffi::c_long as size_t);
    filename = findfile(
        L,
        lua_tolstring(L, -(1 as i32), 0 as *mut size_t),
        c"cpath".as_ptr(),
        c"/".as_ptr(),
    );
    if filename.is_null() {
        return 1 as i32;
    }
    stat = loadfunc(L, filename, name);
    if stat != 0 {
        if stat != 2 as i32 {
            return checkload(L, 0, filename);
        } else {
            lua_pushfstring(L, c"no module '%s' in file '%s'".as_ptr(), name, filename);
            return 1 as i32;
        }
    }
    lua_pushstring(L, filename);
    return 2 as i32;
}
unsafe extern "C-unwind" fn searcher_preload(mut L: *mut lua_State) -> i32 {
    let mut name: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    lua_getfield(L, -(1000000) - 1000, c"_PRELOAD".as_ptr());
    if lua_getfield(L, -(1 as i32), name) == 0 {
        lua_pushfstring(L, c"no field package.preload['%s']".as_ptr(), name);
        return 1 as i32;
    } else {
        lua_pushstring(L, c":preload:".as_ptr());
        return 2 as i32;
    };
}
unsafe extern "C-unwind" fn findloader(mut L: *mut lua_State, mut name: *const std::ffi::c_char) {
    let mut i: i32 = 0;
    let mut msg: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    if ((lua_getfield(L, -(1000000) - 1000 - 1 as i32, c"searchers".as_ptr()) != 5 as i32) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        luaL_error(L, c"'package.searchers' must be a table".as_ptr());
    }
    luaL_buffinit(L, &mut msg);
    i = 1 as i32;
    loop {
        luaL_addstring(&mut msg, c"\n\t".as_ptr());
        if ((lua_rawgeti(L, 3 as i32, i as lua_Integer) == 0) as i32 != 0) as i32
            as std::ffi::c_long
            != 0
        {
            lua_settop(L, -(1 as i32) - 1 as i32);
            msg.n = (msg.n).wrapping_sub(2 as i32 as size_t);
            luaL_pushresult(&mut msg);
            luaL_error(
                L,
                c"module '%s' not found:%s".as_ptr(),
                name,
                lua_tolstring(L, -(1 as i32), 0 as *mut size_t),
            );
        }
        lua_pushstring(L, name);
        lua_callk(L, 1 as i32, 2 as i32, 0 as lua_KContext, None);
        if lua_type(L, -(2 as i32)) == 6 as i32 {
            return;
        } else if lua_isstring(L, -(2 as i32)) != 0 {
            lua_settop(L, -(1 as i32) - 1 as i32);
            luaL_addvalue(&mut msg);
        } else {
            lua_settop(L, -(2 as i32) - 1 as i32);
            msg.n = (msg.n).wrapping_sub(2 as i32 as size_t);
        }
        i += 1;
        i;
    }
}
unsafe extern "C-unwind" fn ll_require(mut L: *mut lua_State) -> i32 {
    let mut name: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    lua_settop(L, 1 as i32);
    lua_getfield(L, -(1000000) - 1000, c"_LOADED".as_ptr());
    lua_getfield(L, 2 as i32, name);
    if lua_toboolean(L, -(1 as i32)) != 0 {
        return 1 as i32;
    }
    lua_settop(L, -(1 as i32) - 1 as i32);
    findloader(L, name);
    lua_rotate(L, -(2 as i32), 1 as i32);
    lua_pushvalue(L, 1 as i32);
    lua_pushvalue(L, -(3 as i32));
    lua_callk(L, 2 as i32, 1 as i32, 0 as lua_KContext, None);
    if !(lua_type(L, -(1 as i32)) == 0) {
        lua_setfield(L, 2 as i32, name);
    } else {
        lua_settop(L, -(1 as i32) - 1 as i32);
    }
    if lua_getfield(L, 2 as i32, name) == 0 {
        lua_pushboolean(L, 1 as i32);
        lua_copy(L, -(1 as i32), -(2 as i32));
        lua_setfield(L, 2 as i32, name);
    }
    lua_rotate(L, -(2 as i32), 1 as i32);
    return 2 as i32;
}
static mut pk_funcs: [luaL_Reg; 8] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"loadlib".as_ptr(),
                func: Some(ll_loadlib as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"searchpath".as_ptr(),
                func: Some(ll_searchpath as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"preload".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"cpath".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"path".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"searchers".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"loaded".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
static mut ll_funcs: [luaL_Reg; 2] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"require".as_ptr(),
                func: Some(ll_require as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
unsafe extern "C-unwind" fn createsearcherstable(mut L: *mut lua_State) {
    static mut searchers: [lua_CFunction; 5] = unsafe {
        [
            Some(searcher_preload as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            Some(searcher_Lua as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            Some(searcher_C as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            Some(searcher_Croot as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            None,
        ]
    };
    let mut i: i32 = 0;
    lua_createtable(
        L,
        (::core::mem::size_of::<[lua_CFunction; 5]>() as usize)
            .wrapping_div(::core::mem::size_of::<lua_CFunction>() as usize)
            .wrapping_sub(1) as i32,
        0,
    );
    i = 0;
    while (searchers[i as usize]).is_some() {
        lua_pushvalue(L, -(2 as i32));
        lua_pushcclosure(L, searchers[i as usize], 1 as i32);
        lua_rawseti(L, -(2 as i32), (i + 1 as i32) as lua_Integer);
        i += 1;
        i;
    }
    lua_setfield(L, -(2 as i32), c"searchers".as_ptr());
}
unsafe extern "C-unwind" fn createclibstable(mut L: *mut lua_State) {
    luaL_getsubtable(L, -(1000000) - 1000, CLIBS);
    lua_createtable(L, 0, 1 as i32);
    lua_pushcclosure(
        L,
        Some(gctm as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
        0,
    );
    lua_setfield(L, -(2 as i32), c"__gc".as_ptr());
    lua_setmetatable(L, -(2 as i32));
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_package(mut L: *mut lua_State) -> i32 {
    createclibstable(L);
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 8]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const pk_funcs).cast(), 0);
    createsearcherstable(L);
    setpath(
        L,
        c"path".as_ptr(),
        c"LUA_PATH".as_ptr(),
        c"/usr/local/share/lua/5.4/?.lua;/usr/local/share/lua/5.4/?/init.lua;/usr/local/lib/lua/5.4/?.lua;/usr/local/lib/lua/5.4/?/init.lua;./?.lua;./?/init.lua"
            .as_ptr(),
    );
    setpath(
        L,
        c"cpath".as_ptr(),
        c"LUA_CPATH".as_ptr(),
        c"/usr/local/lib/lua/5.4/?.so;/usr/local/lib/lua/5.4/loadall.so;./?.so".as_ptr(),
    );
    lua_pushstring(L, c"/\n;\n?\n!\n-\n".as_ptr());
    lua_setfield(L, -(2 as i32), c"config".as_ptr());
    luaL_getsubtable(L, -(1000000) - 1000, c"_LOADED".as_ptr());
    lua_setfield(L, -(2 as i32), c"loaded".as_ptr());
    luaL_getsubtable(L, -(1000000) - 1000, c"_PRELOAD".as_ptr());
    lua_setfield(L, -(2 as i32), c"preload".as_ptr());
    lua_rawgeti(L, -(1000000) - 1000, 2 as i32 as lua_Integer);
    lua_pushvalue(L, -(2 as i32));
    luaL_setfuncs(L, (&raw const ll_funcs).cast(), 1 as i32);
    lua_settop(L, -(1 as i32) - 1 as i32);
    return 1 as i32;
}
unsafe extern "C-unwind" fn os_execute(mut L: *mut lua_State) -> i32 {
    let mut cmd: *const std::ffi::c_char =
        luaL_optlstring(L, 1 as i32, 0 as *const std::ffi::c_char, 0 as *mut size_t);
    let mut stat: i32 = 0;
    *__errno_location() = 0;
    stat = system(cmd);
    if !cmd.is_null() {
        return luaL_execresult(L, stat);
    } else {
        lua_pushboolean(L, stat);
        return 1 as i32;
    };
}
unsafe extern "C-unwind" fn os_remove(mut L: *mut lua_State) -> i32 {
    let mut filename: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    *__errno_location() = 0;
    return luaL_fileresult(L, (remove(filename) == 0) as i32, filename);
}
unsafe extern "C-unwind" fn os_rename(mut L: *mut lua_State) -> i32 {
    let mut fromname: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut toname: *const std::ffi::c_char = luaL_checklstring(L, 2 as i32, 0 as *mut size_t);
    *__errno_location() = 0;
    return luaL_fileresult(
        L,
        (rename(fromname, toname) == 0) as i32,
        0 as *const std::ffi::c_char,
    );
}
unsafe extern "C-unwind" fn os_tmpname(mut L: *mut lua_State) -> i32 {
    let mut buff: [std::ffi::c_char; 32] = [0; 32];
    let mut err: i32 = 0;
    strcpy(buff.as_mut_ptr(), c"/tmp/lua_XXXXXX".as_ptr());
    err = mkstemp(buff.as_mut_ptr());
    if err != -(1 as i32) {
        close(err);
    }
    err = (err == -(1 as i32)) as i32;
    if (err != 0) as i32 as std::ffi::c_long != 0 {
        return luaL_error(L, c"unable to generate a unique filename".as_ptr());
    }
    lua_pushstring(L, buff.as_mut_ptr());
    return 1 as i32;
}
unsafe extern "C-unwind" fn os_getenv(mut L: *mut lua_State) -> i32 {
    lua_pushstring(L, getenv(luaL_checklstring(L, 1 as i32, 0 as *mut size_t)));
    return 1 as i32;
}
unsafe extern "C-unwind" fn os_clock(mut L: *mut lua_State) -> i32 {
    lua_pushnumber(
        L,
        clock() as lua_Number / 1000000 as __clock_t as lua_Number,
    );
    return 1 as i32;
}
unsafe extern "C-unwind" fn setfield(
    mut L: *mut lua_State,
    mut key: *const std::ffi::c_char,
    mut value: i32,
    mut delta: i32,
) {
    lua_pushinteger(L, value as lua_Integer + delta as lua_Integer);
    lua_setfield(L, -(2 as i32), key);
}
unsafe extern "C-unwind" fn setboolfield(
    mut L: *mut lua_State,
    mut key: *const std::ffi::c_char,
    mut value: i32,
) {
    if value < 0 {
        return;
    }
    lua_pushboolean(L, value);
    lua_setfield(L, -(2 as i32), key);
}
unsafe extern "C-unwind" fn setallfields(mut L: *mut lua_State, mut stm: *mut tm) {
    setfield(L, c"year".as_ptr(), (*stm).tm_year, 1900);
    setfield(L, c"month".as_ptr(), (*stm).tm_mon, 1 as i32);
    setfield(L, c"day".as_ptr(), (*stm).tm_mday, 0);
    setfield(L, c"hour".as_ptr(), (*stm).tm_hour, 0);
    setfield(L, c"min".as_ptr(), (*stm).tm_min, 0);
    setfield(L, c"sec".as_ptr(), (*stm).tm_sec, 0);
    setfield(L, c"yday".as_ptr(), (*stm).tm_yday, 1 as i32);
    setfield(L, c"wday".as_ptr(), (*stm).tm_wday, 1 as i32);
    setboolfield(L, c"isdst".as_ptr(), (*stm).tm_isdst);
}
unsafe extern "C-unwind" fn getboolfield(
    mut L: *mut lua_State,
    mut key: *const std::ffi::c_char,
) -> i32 {
    let mut res: i32 = 0;
    res = if lua_getfield(L, -(1 as i32), key) == 0 {
        -(1 as i32)
    } else {
        lua_toboolean(L, -(1 as i32))
    };
    lua_settop(L, -(1 as i32) - 1 as i32);
    return res;
}
unsafe extern "C-unwind" fn getfield(
    mut L: *mut lua_State,
    mut key: *const std::ffi::c_char,
    mut d: i32,
    mut delta: i32,
) -> i32 {
    let mut isnum: i32 = 0;
    let mut t: i32 = lua_getfield(L, -(1 as i32), key);
    let mut res: lua_Integer = lua_tointegerx(L, -(1 as i32), &mut isnum);
    if isnum == 0 {
        if ((t != 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            return luaL_error(L, c"field '%s' is not an integer".as_ptr(), key);
        } else if ((d < 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            return luaL_error(L, c"field '%s' missing in date table".as_ptr(), key);
        }
        res = d as lua_Integer;
    } else {
        if if res >= 0 as lua_Integer {
            (res - delta as lua_Integer <= 2147483647 as i32 as lua_Integer) as i32
        } else {
            ((-(2147483647 as i32) - 1 as i32 + delta) as lua_Integer <= res) as i32
        } == 0
        {
            return luaL_error(L, c"field '%s' is out-of-bound".as_ptr(), key);
        }
        res -= delta as lua_Integer;
    }
    lua_settop(L, -(1 as i32) - 1 as i32);
    return res as i32;
}
unsafe extern "C-unwind" fn checkoption(
    mut L: *mut lua_State,
    mut conv: *const std::ffi::c_char,
    mut convlen: ptrdiff_t,
    mut buff: *mut std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut option: *const std::ffi::c_char =
        c"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%||EcECExEXEyEYOdOeOHOIOmOMOSOuOUOVOwOWOy".as_ptr();
    let mut oplen: i32 = 1 as i32;
    while *option as i32 != '\0' as i32 && oplen as ptrdiff_t <= convlen {
        if *option as i32 == '|' as i32 {
            oplen += 1;
            oplen;
        } else if memcmp(
            conv as *const c_void,
            option as *const c_void,
            oplen as usize,
        ) == 0
        {
            memcpy(buff as *mut c_void, conv as *const c_void, oplen as usize);
            *buff.offset(oplen as isize) = b'\0' as std::ffi::c_char;
            return conv.offset(oplen as isize);
        }
        option = option.offset(oplen as isize);
    }
    luaL_argerror(
        L,
        1 as i32,
        lua_pushfstring(L, c"invalid conversion specifier '%%%s'".as_ptr(), conv),
    );
    return conv;
}
unsafe extern "C-unwind" fn l_checktime(mut L: *mut lua_State, mut arg: i32) -> time_t {
    let mut t: lua_Integer = luaL_checkinteger(L, arg);
    (((t as time_t as lua_Integer == t) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, arg, c"time out-of-bounds".as_ptr()) != 0) as i32;
    return t as time_t;
}
unsafe extern "C-unwind" fn os_date(mut L: *mut lua_State) -> i32 {
    let mut slen: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_optlstring(L, 1 as i32, c"%c".as_ptr(), &mut slen);
    let mut t: time_t = if lua_type(L, 2 as i32) <= 0 {
        time(0 as *mut time_t)
    } else {
        l_checktime(L, 2 as i32)
    };
    let mut se: *const std::ffi::c_char = s.offset(slen as isize);
    let mut tmr: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const std::ffi::c_char,
    };
    let mut stm: *mut tm = 0 as *mut tm;
    if *s as i32 == '!' as i32 {
        stm = gmtime_r(&mut t, &mut tmr);
        s = s.offset(1);
        s;
    } else {
        stm = localtime_r(&mut t, &mut tmr);
    }
    if stm.is_null() {
        return luaL_error(
            L,
            c"date result cannot be represented in this installation".as_ptr(),
        );
    }
    if strcmp(s, c"*t".as_ptr()) == 0 {
        lua_createtable(L, 0, 9 as i32);
        setallfields(L, stm);
    } else {
        let mut cc: [std::ffi::c_char; 4] = [0; 4];
        let mut b: luaL_Buffer = luaL_Buffer {
            b: 0 as *mut std::ffi::c_char,
            size: 0,
            n: 0,
            L: 0 as *mut lua_State,
            init: C2RustUnnamed_15 { n: 0. },
        };
        cc[0 as usize] = '%' as i32 as std::ffi::c_char;
        luaL_buffinit(L, &mut b);
        while s < se {
            if *s as i32 != '%' as i32 {
                (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
                let fresh163 = s;
                s = s.offset(1);
                let fresh164 = b.n;
                b.n = (b.n).wrapping_add(1);
                *(b.b).offset(fresh164 as isize) = *fresh163;
            } else {
                let mut reslen: size_t = 0;
                let mut buff: *mut std::ffi::c_char = luaL_prepbuffsize(&mut b, 250 as size_t);
                s = s.offset(1);
                s;
                s = checkoption(L, s, se.offset_from(s), cc.as_mut_ptr().offset(1));
                reslen = strftime(buff, 250 as size_t, cc.as_mut_ptr(), stm);
                b.n = (b.n).wrapping_add(reslen);
            }
        }
        luaL_pushresult(&mut b);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn os_time(mut L: *mut lua_State) -> i32 {
    let mut t: time_t = 0;
    if lua_type(L, 1 as i32) <= 0 {
        t = time(0 as *mut time_t);
    } else {
        let mut ts: tm = tm {
            tm_sec: 0,
            tm_min: 0,
            tm_hour: 0,
            tm_mday: 0,
            tm_mon: 0,
            tm_year: 0,
            tm_wday: 0,
            tm_yday: 0,
            tm_isdst: 0,
            tm_gmtoff: 0,
            tm_zone: 0 as *const std::ffi::c_char,
        };
        luaL_checktype(L, 1 as i32, 5 as i32);
        lua_settop(L, 1 as i32);
        ts.tm_year = getfield(L, c"year".as_ptr(), -(1 as i32), 1900);
        ts.tm_mon = getfield(L, c"month".as_ptr(), -(1 as i32), 1 as i32);
        ts.tm_mday = getfield(L, c"day".as_ptr(), -(1 as i32), 0);
        ts.tm_hour = getfield(L, c"hour".as_ptr(), 12 as i32, 0);
        ts.tm_min = getfield(L, c"min".as_ptr(), 0, 0);
        ts.tm_sec = getfield(L, c"sec".as_ptr(), 0, 0);
        ts.tm_isdst = getboolfield(L, c"isdst".as_ptr());
        t = mktime(&mut ts);
        setallfields(L, &mut ts);
    }
    if t != t as lua_Integer as time_t || t == -(1 as i32) as time_t {
        return luaL_error(
            L,
            c"time result cannot be represented in this installation".as_ptr(),
        );
    }
    lua_pushinteger(L, t as lua_Integer);
    return 1 as i32;
}
unsafe extern "C-unwind" fn os_difftime(mut L: *mut lua_State) -> i32 {
    let mut t1: time_t = l_checktime(L, 1 as i32);
    let mut t2: time_t = l_checktime(L, 2 as i32);
    lua_pushnumber(L, difftime(t1, t2));
    return 1 as i32;
}
unsafe extern "C-unwind" fn os_setlocale(mut L: *mut lua_State) -> i32 {
    static mut cat: [i32; 6] = [6 as i32, 3 as i32, 0, 4 as i32, 1 as i32, 2 as i32];
    static mut catnames: [*const std::ffi::c_char; 7] = [
        c"all".as_ptr(),
        c"collate".as_ptr(),
        c"ctype".as_ptr(),
        c"monetary".as_ptr(),
        c"numeric".as_ptr(),
        c"time".as_ptr(),
        0 as *const std::ffi::c_char,
    ];
    let mut l: *const std::ffi::c_char =
        luaL_optlstring(L, 1 as i32, 0 as *const std::ffi::c_char, 0 as *mut size_t);
    let mut op: i32 = luaL_checkoption(L, 2 as i32, c"all".as_ptr(), (&raw const catnames).cast());
    lua_pushstring(L, setlocale(cat[op as usize], l));
    return 1 as i32;
}
unsafe extern "C-unwind" fn os_exit(mut L: *mut lua_State) -> i32 {
    let mut status: i32 = 0;
    if lua_type(L, 1 as i32) == 1 as i32 {
        status = if lua_toboolean(L, 1 as i32) != 0 {
            0
        } else {
            1 as i32
        };
    } else {
        status = luaL_optinteger(L, 1 as i32, 0 as lua_Integer) as i32;
    }
    if lua_toboolean(L, 2 as i32) != 0 {
        lua_close(L);
    }
    if !L.is_null() {
        exit(status);
    }
    return 0;
}
static mut syslib: [luaL_Reg; 12] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"clock".as_ptr(),
                func: Some(os_clock as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"date".as_ptr(),
                func: Some(os_date as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"difftime".as_ptr(),
                func: Some(os_difftime as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"execute".as_ptr(),
                func: Some(os_execute as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"exit".as_ptr(),
                func: Some(os_exit as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"getenv".as_ptr(),
                func: Some(os_getenv as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"remove".as_ptr(),
                func: Some(os_remove as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"rename".as_ptr(),
                func: Some(os_rename as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"setlocale".as_ptr(),
                func: Some(os_setlocale as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"time".as_ptr(),
                func: Some(os_time as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"tmpname".as_ptr(),
                func: Some(os_tmpname as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_os(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 12]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const syslib).cast(), 0);
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_len(mut L: *mut lua_State) -> i32 {
    let mut l: size_t = 0;
    luaL_checklstring(L, 1 as i32, &mut l);
    lua_pushinteger(L, l as lua_Integer);
    return 1 as i32;
}
unsafe extern "C-unwind" fn posrelatI(mut pos: lua_Integer, mut len: size_t) -> size_t {
    if pos > 0 as lua_Integer {
        return pos as size_t;
    } else if pos == 0 as lua_Integer {
        return 1 as i32 as size_t;
    } else if pos < -(len as lua_Integer) {
        return 1 as i32 as size_t;
    } else {
        return len
            .wrapping_add(pos as size_t)
            .wrapping_add(1 as i32 as size_t);
    };
}
unsafe extern "C-unwind" fn getendpos(
    mut L: *mut lua_State,
    mut arg: i32,
    mut def: lua_Integer,
    mut len: size_t,
) -> size_t {
    let mut pos: lua_Integer = luaL_optinteger(L, arg, def);
    if pos > len as lua_Integer {
        return len;
    } else if pos >= 0 as lua_Integer {
        return pos as size_t;
    } else if pos < -(len as lua_Integer) {
        return 0 as size_t;
    } else {
        return len
            .wrapping_add(pos as size_t)
            .wrapping_add(1 as i32 as size_t);
    };
}
unsafe extern "C-unwind" fn str_sub(mut L: *mut lua_State) -> i32 {
    let mut l: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut l);
    let mut start: size_t = posrelatI(luaL_checkinteger(L, 2 as i32), l);
    let mut end: size_t = getendpos(L, 3 as i32, -(1 as i32) as lua_Integer, l);
    if start <= end {
        lua_pushlstring(
            L,
            s.offset(start as isize).offset(-(1)),
            end.wrapping_sub(start).wrapping_add(1 as i32 as size_t),
        );
    } else {
        lua_pushstring(L, c"".as_ptr());
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_reverse(mut L: *mut lua_State) -> i32 {
    let mut l: size_t = 0;
    let mut i: size_t = 0;
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut l);
    let mut p: *mut std::ffi::c_char = luaL_buffinitsize(L, &mut b, l);
    i = 0 as size_t;
    while i < l {
        *p.offset(i as isize) =
            *s.offset(l.wrapping_sub(i).wrapping_sub(1 as i32 as size_t) as isize);
        i = i.wrapping_add(1);
        i;
    }
    luaL_pushresultsize(&mut b, l);
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_lower(mut L: *mut lua_State) -> i32 {
    let mut l: size_t = 0;
    let mut i: size_t = 0;
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut l);
    let mut p: *mut std::ffi::c_char = luaL_buffinitsize(L, &mut b, l);
    i = 0 as size_t;
    while i < l {
        *p.offset(i as isize) = tolower(*s.offset(i as isize) as u8 as i32) as std::ffi::c_char;
        i = i.wrapping_add(1);
        i;
    }
    luaL_pushresultsize(&mut b, l);
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_upper(mut L: *mut lua_State) -> i32 {
    let mut l: size_t = 0;
    let mut i: size_t = 0;
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut l);
    let mut p: *mut std::ffi::c_char = luaL_buffinitsize(L, &mut b, l);
    i = 0 as size_t;
    while i < l {
        *p.offset(i as isize) = toupper(*s.offset(i as isize) as u8 as i32) as std::ffi::c_char;
        i = i.wrapping_add(1);
        i;
    }
    luaL_pushresultsize(&mut b, l);
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_rep(mut L: *mut lua_State) -> i32 {
    let mut l: size_t = 0;
    let mut lsep: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut l);
    let mut n: lua_Integer = luaL_checkinteger(L, 2 as i32);
    let mut sep: *const std::ffi::c_char = luaL_optlstring(L, 3 as i32, c"".as_ptr(), &mut lsep);
    if n <= 0 as lua_Integer {
        lua_pushstring(L, c"".as_ptr());
    } else if ((l.wrapping_add(lsep) < l
        || l.wrapping_add(lsep) as u64
            > ((if (::core::mem::size_of::<size_t>() as usize)
                < ::core::mem::size_of::<i32>() as usize
            {
                !(0 as size_t)
            } else {
                2147483647 as i32 as size_t
            }) as u64)
                .wrapping_div(n as u64)) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        return luaL_error(L, c"resulting string too large".as_ptr());
    } else {
        let mut totallen: size_t =
            (n as size_t * l).wrapping_add((n - 1 as i32 as lua_Integer) as size_t * lsep);
        let mut b: luaL_Buffer = luaL_Buffer {
            b: 0 as *mut std::ffi::c_char,
            size: 0,
            n: 0,
            L: 0 as *mut lua_State,
            init: C2RustUnnamed_15 { n: 0. },
        };
        let mut p: *mut std::ffi::c_char = luaL_buffinitsize(L, &mut b, totallen);
        loop {
            let fresh165 = n;
            n = n - 1;
            if !(fresh165 > 1 as i32 as lua_Integer) {
                break;
            }
            memcpy(
                p as *mut c_void,
                s as *const c_void,
                l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
            );
            p = p.offset(l as isize);
            if lsep > 0 as size_t {
                memcpy(
                    p as *mut c_void,
                    sep as *const c_void,
                    lsep.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
                );
                p = p.offset(lsep as isize);
            }
        }
        memcpy(
            p as *mut c_void,
            s as *const c_void,
            l.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
        );
        luaL_pushresultsize(&mut b, totallen);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_byte(mut L: *mut lua_State) -> i32 {
    let mut l: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut l);
    let mut pi: lua_Integer = luaL_optinteger(L, 2 as i32, 1 as i32 as lua_Integer);
    let mut posi: size_t = posrelatI(pi, l);
    let mut pose: size_t = getendpos(L, 3 as i32, pi, l);
    let mut n: i32 = 0;
    let mut i: i32 = 0;
    if posi > pose {
        return 0;
    }
    if ((pose.wrapping_sub(posi) >= 2147483647 as i32 as size_t) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
    {
        return luaL_error(L, c"string slice too long".as_ptr());
    }
    n = pose.wrapping_sub(posi) as i32 + 1 as i32;
    luaL_checkstack(L, n, c"string slice too long".as_ptr());
    i = 0;
    while i < n {
        lua_pushinteger(
            L,
            *s.offset(
                posi.wrapping_add(i as size_t)
                    .wrapping_sub(1 as i32 as size_t) as isize,
            ) as u8 as lua_Integer,
        );
        i += 1;
        i;
    }
    return n;
}
unsafe extern "C-unwind" fn str_char(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = lua_gettop(L);
    let mut i: i32 = 0;
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut p: *mut std::ffi::c_char = luaL_buffinitsize(L, &mut b, n as size_t);
    i = 1 as i32;
    while i <= n {
        let mut c: lua_Unsigned = luaL_checkinteger(L, i) as lua_Unsigned;
        (((c <= (127 as i32 * 2 as i32 + 1 as i32) as lua_Unsigned) as i32 != 0) as i32
            as std::ffi::c_long
            != 0
            || luaL_argerror(L, i, c"value out of range".as_ptr()) != 0) as i32;
        *p.offset((i - 1 as i32) as isize) = c as u8 as std::ffi::c_char;
        i += 1;
        i;
    }
    luaL_pushresultsize(&mut b, n as size_t);
    return 1 as i32;
}
unsafe extern "C-unwind" fn writer(
    mut L: *mut lua_State,
    mut b: *const c_void,
    mut size: size_t,
    mut ud: *mut c_void,
) -> i32 {
    let mut state: *mut str_Writer = ud as *mut str_Writer;
    if (*state).init == 0 {
        (*state).init = 1 as i32;
        luaL_buffinit(L, &mut (*state).B);
    }
    luaL_addlstring(&mut (*state).B, b as *const std::ffi::c_char, size);
    return 0;
}
unsafe extern "C-unwind" fn str_dump(mut L: *mut lua_State) -> i32 {
    let mut state: str_Writer = str_Writer {
        init: 0,
        B: luaL_Buffer {
            b: 0 as *mut std::ffi::c_char,
            size: 0,
            n: 0,
            L: 0 as *mut lua_State,
            init: C2RustUnnamed_15 { n: 0. },
        },
    };
    let mut strip: i32 = lua_toboolean(L, 2 as i32);
    luaL_checktype(L, 1 as i32, 6 as i32);
    lua_settop(L, 1 as i32);
    state.init = 0;
    if ((lua_dump(
        L,
        Some(
            writer
                as unsafe extern "C-unwind" fn(
                    *mut lua_State,
                    *const c_void,
                    size_t,
                    *mut c_void,
                ) -> i32,
        ),
        &mut state as *mut str_Writer as *mut c_void,
        strip,
    ) != 0) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        return luaL_error(L, c"unable to dump given function".as_ptr());
    }
    luaL_pushresult(&mut state.B);
    return 1 as i32;
}
unsafe extern "C-unwind" fn tonum(mut L: *mut lua_State, mut arg: i32) -> i32 {
    if lua_type(L, arg) == 3 as i32 {
        lua_pushvalue(L, arg);
        return 1 as i32;
    } else {
        let mut len: size_t = 0;
        let mut s: *const std::ffi::c_char = lua_tolstring(L, arg, &mut len);
        return (!s.is_null() && lua_stringtonumber(L, s) == len.wrapping_add(1 as i32 as size_t))
            as i32;
    };
}
unsafe extern "C-unwind" fn trymt(mut L: *mut lua_State, mut mtname: *const std::ffi::c_char) {
    lua_settop(L, 2 as i32);
    if ((lua_type(L, 2 as i32) == 4 as i32 || luaL_getmetafield(L, 2 as i32, mtname) == 0) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        luaL_error(
            L,
            c"attempt to %s a '%s' with a '%s'".as_ptr(),
            mtname.offset(2),
            lua_typename(L, lua_type(L, -(2 as i32))),
            lua_typename(L, lua_type(L, -(1 as i32))),
        );
    }
    lua_rotate(L, -(3 as i32), 1 as i32);
    lua_callk(L, 2 as i32, 1 as i32, 0 as lua_KContext, None);
}
unsafe extern "C-unwind" fn arith(
    mut L: *mut lua_State,
    mut op: i32,
    mut mtname: *const std::ffi::c_char,
) -> i32 {
    if tonum(L, 1 as i32) != 0 && tonum(L, 2 as i32) != 0 {
        lua_arith(L, op);
    } else {
        trymt(L, mtname);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn arith_add(mut L: *mut lua_State) -> i32 {
    return arith(L, 0, c"__add".as_ptr());
}
unsafe extern "C-unwind" fn arith_sub(mut L: *mut lua_State) -> i32 {
    return arith(L, 1 as i32, c"__sub".as_ptr());
}
unsafe extern "C-unwind" fn arith_mul(mut L: *mut lua_State) -> i32 {
    return arith(L, 2 as i32, c"__mul".as_ptr());
}
unsafe extern "C-unwind" fn arith_mod(mut L: *mut lua_State) -> i32 {
    return arith(L, 3 as i32, c"__mod".as_ptr());
}
unsafe extern "C-unwind" fn arith_pow(mut L: *mut lua_State) -> i32 {
    return arith(L, 4 as i32, c"__pow".as_ptr());
}
unsafe extern "C-unwind" fn arith_div(mut L: *mut lua_State) -> i32 {
    return arith(L, 5 as i32, c"__div".as_ptr());
}
unsafe extern "C-unwind" fn arith_idiv(mut L: *mut lua_State) -> i32 {
    return arith(L, 6 as i32, c"__idiv".as_ptr());
}
unsafe extern "C-unwind" fn arith_unm(mut L: *mut lua_State) -> i32 {
    return arith(L, 12 as i32, c"__unm".as_ptr());
}
static mut stringmetamethods: [luaL_Reg; 10] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"__add".as_ptr(),
                func: Some(arith_add as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__sub".as_ptr(),
                func: Some(arith_sub as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__mul".as_ptr(),
                func: Some(arith_mul as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__mod".as_ptr(),
                func: Some(arith_mod as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__pow".as_ptr(),
                func: Some(arith_pow as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__div".as_ptr(),
                func: Some(arith_div as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__idiv".as_ptr(),
                func: Some(arith_idiv as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__unm".as_ptr(),
                func: Some(arith_unm as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"__index".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
unsafe extern "C-unwind" fn check_capture(mut ms: *mut MatchState, mut l: i32) -> i32 {
    l -= '1' as i32;
    if ((l < 0
        || l >= (*ms).level as i32
        || (*ms).capture[l as usize].len == -(1 as i32) as ptrdiff_t) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        return luaL_error(
            (*ms).L,
            c"invalid capture index %%%d".as_ptr(),
            l + 1 as i32,
        );
    }
    return l;
}
unsafe extern "C-unwind" fn capture_to_close(mut ms: *mut MatchState) -> i32 {
    let mut level: i32 = (*ms).level as i32;
    level -= 1;
    level;
    while level >= 0 {
        if (*ms).capture[level as usize].len == -(1 as i32) as ptrdiff_t {
            return level;
        }
        level -= 1;
        level;
    }
    return luaL_error((*ms).L, c"invalid pattern capture".as_ptr());
}
unsafe extern "C-unwind" fn classend(
    mut ms: *mut MatchState,
    mut p: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let fresh166 = p;
    p = p.offset(1);
    match *fresh166 as i32 {
        37 => {
            if ((p == (*ms).p_end) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                luaL_error((*ms).L, c"malformed pattern (ends with '%%')".as_ptr());
            }
            return p.offset(1);
        }
        91 => {
            if *p as i32 == '^' as i32 {
                p = p.offset(1);
                p;
            }
            loop {
                if ((p == (*ms).p_end) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                    luaL_error((*ms).L, c"malformed pattern (missing ']')".as_ptr());
                }
                let fresh167 = p;
                p = p.offset(1);
                if *fresh167 as i32 == '%' as i32 && p < (*ms).p_end {
                    p = p.offset(1);
                    p;
                }
                if !(*p as i32 != ']' as i32) {
                    break;
                }
            }
            return p.offset(1);
        }
        _ => return p,
    };
}
unsafe extern "C-unwind" fn match_class(mut c: i32, mut cl: i32) -> i32 {
    let mut res: i32 = 0;
    match tolower(cl) {
        97 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISalpha as i32 as u16 as i32;
        }
        99 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _IScntrl as i32 as u16 as i32;
        }
        100 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISdigit as i32 as u16 as i32;
        }
        103 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISgraph as i32 as u16 as i32;
        }
        108 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISlower as i32 as u16 as i32;
        }
        112 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISpunct as i32 as u16 as i32;
        }
        115 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISspace as i32 as u16 as i32;
        }
        117 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISupper as i32 as u16 as i32;
        }
        119 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISalnum as i32 as u16 as i32;
        }
        120 => {
            res = *(*__ctype_b_loc()).offset(c as isize) as i32 & _ISxdigit as i32 as u16 as i32;
        }
        122 => {
            res = (c == 0) as i32;
        }
        _ => return (cl == c) as i32,
    }
    return if *(*__ctype_b_loc()).offset(cl as isize) as i32 & _ISlower as i32 as u16 as i32 != 0 {
        res
    } else {
        (res == 0) as i32
    };
}
unsafe extern "C-unwind" fn matchbracketclass(
    mut c: i32,
    mut p: *const std::ffi::c_char,
    mut ec: *const std::ffi::c_char,
) -> i32 {
    let mut sig: i32 = 1 as i32;
    if *p.offset(1) as i32 == '^' as i32 {
        sig = 0;
        p = p.offset(1);
        p;
    }
    loop {
        p = p.offset(1);
        if !(p < ec) {
            break;
        }
        if *p as i32 == '%' as i32 {
            p = p.offset(1);
            p;
            if match_class(c, *p as u8 as i32) != 0 {
                return sig;
            }
        } else if *p.offset(1) as i32 == '-' as i32 && p.offset(2) < ec {
            p = p.offset(2);
            if *p.offset(-(2)) as u8 as i32 <= c && c <= *p as u8 as i32 {
                return sig;
            }
        } else if *p as u8 as i32 == c {
            return sig;
        }
    }
    return (sig == 0) as i32;
}
unsafe extern "C-unwind" fn singlematch(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
    mut ep: *const std::ffi::c_char,
) -> i32 {
    if s >= (*ms).src_end {
        return 0;
    } else {
        let mut c: i32 = *s as u8 as i32;
        match *p as i32 {
            46 => return 1 as i32,
            37 => {
                return match_class(c, *p.offset(1) as u8 as i32);
            }
            91 => {
                return matchbracketclass(c, p, ep.offset(-(1)));
            }
            _ => {
                return (*p as u8 as i32 == c) as i32;
            }
        }
    };
}
unsafe extern "C-unwind" fn matchbalance(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    if ((p >= ((*ms).p_end).offset(-(1))) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(
            (*ms).L,
            c"malformed pattern (missing arguments to '%%b')".as_ptr(),
        );
    }
    if *s as i32 != *p as i32 {
        return 0 as *const std::ffi::c_char;
    } else {
        let mut b: i32 = *p as i32;
        let mut e: i32 = *p.offset(1) as i32;
        let mut cont: i32 = 1 as i32;
        loop {
            s = s.offset(1);
            if !(s < (*ms).src_end) {
                break;
            }
            if *s as i32 == e {
                cont -= 1;
                if cont == 0 {
                    return s.offset(1);
                }
            } else if *s as i32 == b {
                cont += 1;
                cont;
            }
        }
    }
    return 0 as *const std::ffi::c_char;
}
unsafe extern "C-unwind" fn max_expand(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
    mut ep: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut i: ptrdiff_t = 0 as ptrdiff_t;
    while singlematch(ms, s.offset(i as isize), p, ep) != 0 {
        i += 1;
        i;
    }
    while i >= 0 as ptrdiff_t {
        let mut res: *const std::ffi::c_char = match_0(ms, s.offset(i as isize), ep.offset(1));
        if !res.is_null() {
            return res;
        }
        i -= 1;
        i;
    }
    return 0 as *const std::ffi::c_char;
}
unsafe extern "C-unwind" fn min_expand(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
    mut ep: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    loop {
        let mut res: *const std::ffi::c_char = match_0(ms, s, ep.offset(1));
        if !res.is_null() {
            return res;
        } else if singlematch(ms, s, p, ep) != 0 {
            s = s.offset(1);
            s;
        } else {
            return 0 as *const std::ffi::c_char;
        }
    }
}
unsafe extern "C-unwind" fn start_capture(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
    mut what: i32,
) -> *const std::ffi::c_char {
    let mut res: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut level: i32 = (*ms).level as i32;
    if level >= 32 as i32 {
        luaL_error((*ms).L, c"too many captures".as_ptr());
    }
    (*ms).capture[level as usize].init = s;
    (*ms).capture[level as usize].len = what as ptrdiff_t;
    (*ms).level = (level + 1 as i32) as u8;
    res = match_0(ms, s, p);
    if res.is_null() {
        (*ms).level = ((*ms).level).wrapping_sub(1);
        (*ms).level;
    }
    return res;
}
unsafe extern "C-unwind" fn end_capture(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut l: i32 = capture_to_close(ms);
    let mut res: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    (*ms).capture[l as usize].len = s.offset_from((*ms).capture[l as usize].init);
    res = match_0(ms, s, p);
    if res.is_null() {
        (*ms).capture[l as usize].len = -(1 as i32) as ptrdiff_t;
    }
    return res;
}
unsafe extern "C-unwind" fn match_capture(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut l: i32,
) -> *const std::ffi::c_char {
    let mut len: size_t = 0;
    l = check_capture(ms, l);
    len = (*ms).capture[l as usize].len as size_t;
    if ((*ms).src_end).offset_from(s) as std::ffi::c_long as size_t >= len
        && memcmp(
            (*ms).capture[l as usize].init as *const c_void,
            s as *const c_void,
            len,
        ) == 0
    {
        return s.offset(len as isize);
    } else {
        return 0 as *const std::ffi::c_char;
    };
}
unsafe extern "C-unwind" fn match_0(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut p: *const std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut ep_0: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut current_block: u64;
    let fresh168 = (*ms).matchdepth;
    (*ms).matchdepth = (*ms).matchdepth - 1;
    if ((fresh168 == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error((*ms).L, c"pattern too complex".as_ptr());
    }
    loop {
        if !(p != (*ms).p_end) {
            current_block = 6476622998065200121;
            break;
        }
        match *p as i32 {
            40 => {
                if *p.offset(1) as i32 == ')' as i32 {
                    s = start_capture(ms, s, p.offset(2), -(2 as i32));
                } else {
                    s = start_capture(ms, s, p.offset(1), -(1 as i32));
                }
                current_block = 6476622998065200121;
                break;
            }
            41 => {
                s = end_capture(ms, s, p.offset(1));
                current_block = 6476622998065200121;
                break;
            }
            36 => {
                if !(p.offset(1) != (*ms).p_end) {
                    s = if s == (*ms).src_end {
                        s
                    } else {
                        0 as *const std::ffi::c_char
                    };
                    current_block = 6476622998065200121;
                    break;
                }
            }
            37 => match *p.offset(1) as i32 {
                98 => {
                    current_block = 17965632435239708295;
                    match current_block {
                        17965632435239708295 => {
                            s = matchbalance(ms, s, p.offset(2));
                            if s.is_null() {
                                current_block = 6476622998065200121;
                                break;
                            }
                            p = p.offset(4);
                            continue;
                        }
                        8236137900636309791 => {
                            let mut ep: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
                            let mut previous: std::ffi::c_char = 0;
                            p = p.offset(2);
                            if ((*p as i32 != '[' as i32) as i32 != 0) as i32 as std::ffi::c_long
                                != 0
                            {
                                luaL_error((*ms).L, c"missing '[' after '%%f' in pattern".as_ptr());
                            }
                            ep = classend(ms, p);
                            previous = (if s == (*ms).src_init {
                                '\0' as i32
                            } else {
                                *s.offset(-(1)) as i32
                            }) as std::ffi::c_char;
                            if matchbracketclass(previous as u8 as i32, p, ep.offset(-(1))) == 0
                                && matchbracketclass(*s as u8 as i32, p, ep.offset(-(1))) != 0
                            {
                                p = ep;
                                continue;
                            } else {
                                s = 0 as *const std::ffi::c_char;
                                current_block = 6476622998065200121;
                                break;
                            }
                        }
                        _ => {
                            s = match_capture(ms, s, *p.offset(1) as u8 as i32);
                            if s.is_null() {
                                current_block = 6476622998065200121;
                                break;
                            }
                            p = p.offset(2);
                            continue;
                        }
                    }
                }
                102 => {
                    current_block = 8236137900636309791;
                    match current_block {
                        17965632435239708295 => {
                            s = matchbalance(ms, s, p.offset(2));
                            if s.is_null() {
                                current_block = 6476622998065200121;
                                break;
                            }
                            p = p.offset(4);
                            continue;
                        }
                        8236137900636309791 => {
                            let mut ep: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
                            let mut previous: std::ffi::c_char = 0;
                            p = p.offset(2);
                            if ((*p as i32 != '[' as i32) as i32 != 0) as i32 as std::ffi::c_long
                                != 0
                            {
                                luaL_error((*ms).L, c"missing '[' after '%%f' in pattern".as_ptr());
                            }
                            ep = classend(ms, p);
                            previous = (if s == (*ms).src_init {
                                '\0' as i32
                            } else {
                                *s.offset(-(1)) as i32
                            }) as std::ffi::c_char;
                            if matchbracketclass(previous as u8 as i32, p, ep.offset(-(1))) == 0
                                && matchbracketclass(*s as u8 as i32, p, ep.offset(-(1))) != 0
                            {
                                p = ep;
                                continue;
                            } else {
                                s = 0 as *const std::ffi::c_char;
                                current_block = 6476622998065200121;
                                break;
                            }
                        }
                        _ => {
                            s = match_capture(ms, s, *p.offset(1) as u8 as i32);
                            if s.is_null() {
                                current_block = 6476622998065200121;
                                break;
                            }
                            p = p.offset(2);
                            continue;
                        }
                    }
                }
                48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {
                    current_block = 14576567515993809846;
                    match current_block {
                        17965632435239708295 => {
                            s = matchbalance(ms, s, p.offset(2));
                            if s.is_null() {
                                current_block = 6476622998065200121;
                                break;
                            }
                            p = p.offset(4);
                            continue;
                        }
                        8236137900636309791 => {
                            let mut ep: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
                            let mut previous: std::ffi::c_char = 0;
                            p = p.offset(2);
                            if ((*p as i32 != '[' as i32) as i32 != 0) as i32 as std::ffi::c_long
                                != 0
                            {
                                luaL_error((*ms).L, c"missing '[' after '%%f' in pattern".as_ptr());
                            }
                            ep = classend(ms, p);
                            previous = (if s == (*ms).src_init {
                                '\0' as i32
                            } else {
                                *s.offset(-(1)) as i32
                            }) as std::ffi::c_char;
                            if matchbracketclass(previous as u8 as i32, p, ep.offset(-(1))) == 0
                                && matchbracketclass(*s as u8 as i32, p, ep.offset(-(1))) != 0
                            {
                                p = ep;
                                continue;
                            } else {
                                s = 0 as *const std::ffi::c_char;
                                current_block = 6476622998065200121;
                                break;
                            }
                        }
                        _ => {
                            s = match_capture(ms, s, *p.offset(1) as u8 as i32);
                            if s.is_null() {
                                current_block = 6476622998065200121;
                                break;
                            }
                            p = p.offset(2);
                            continue;
                        }
                    }
                }
                _ => {}
            },
            _ => {}
        }
        ep_0 = classend(ms, p);
        if singlematch(ms, s, p, ep_0) == 0 {
            if *ep_0 == '*' as std::ffi::c_char
                || *ep_0 == '?' as std::ffi::c_char
                || *ep_0 == '-' as std::ffi::c_char
            {
                p = ep_0.offset(1);
            } else {
                s = 0 as *const std::ffi::c_char;
                current_block = 6476622998065200121;
                break;
            }
        } else {
            match *ep_0 {
                63 => {
                    let mut res: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
                    res = match_0(ms, s.offset(1), ep_0.offset(1));
                    if !res.is_null() {
                        s = res;
                        current_block = 6476622998065200121;
                        break;
                    } else {
                        p = ep_0.offset(1);
                    }
                }
                43 => {
                    s = s.offset(1);
                    s;
                    current_block = 121429310731562752;
                    break;
                }
                42 => {
                    current_block = 121429310731562752;
                    break;
                }
                45 => {
                    s = min_expand(ms, s, p, ep_0);
                    current_block = 6476622998065200121;
                    break;
                }
                _ => {
                    s = s.offset(1);
                    s;
                    p = ep_0;
                }
            }
        }
    }
    match current_block {
        121429310731562752 => {
            s = max_expand(ms, s, p, ep_0);
        }
        _ => {}
    }
    (*ms).matchdepth += 1;
    (*ms).matchdepth;
    return s;
}
unsafe extern "C-unwind" fn lmemfind(
    mut s1: *const std::ffi::c_char,
    mut l1: size_t,
    mut s2: *const std::ffi::c_char,
    mut l2: size_t,
) -> *const std::ffi::c_char {
    if l2 == 0 as size_t {
        return s1;
    } else if l2 > l1 {
        return 0 as *const std::ffi::c_char;
    } else {
        let mut init: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
        l2 = l2.wrapping_sub(1);
        l2;
        l1 = l1.wrapping_sub(l2);
        while l1 > 0 as size_t && {
            init = memchr(s1 as *const c_void, *s2 as i32, l1) as *const std::ffi::c_char;
            !init.is_null()
        } {
            init = init.offset(1);
            init;
            if memcmp(init as *const c_void, s2.offset(1) as *const c_void, l2) == 0 {
                return init.offset(-(1));
            } else {
                l1 = l1.wrapping_sub(init.offset_from(s1) as std::ffi::c_long as size_t);
                s1 = init;
            }
        }
        return 0 as *const std::ffi::c_char;
    };
}
unsafe extern "C-unwind" fn get_onecapture(
    mut ms: *mut MatchState,
    mut i: i32,
    mut s: *const std::ffi::c_char,
    mut e: *const std::ffi::c_char,
    mut cap: *mut *const std::ffi::c_char,
) -> size_t {
    if i >= (*ms).level as i32 {
        if ((i != 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            luaL_error(
                (*ms).L,
                c"invalid capture index %%%d".as_ptr(),
                i + 1 as i32,
            );
        }
        *cap = s;
        return e.offset_from(s) as std::ffi::c_long as size_t;
    } else {
        let mut capl: ptrdiff_t = (*ms).capture[i as usize].len;
        *cap = (*ms).capture[i as usize].init;
        if ((capl == -(1 as i32) as ptrdiff_t) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            luaL_error((*ms).L, c"unfinished capture".as_ptr());
        } else if capl == -(2 as i32) as ptrdiff_t {
            lua_pushinteger(
                (*ms).L,
                (((*ms).capture[i as usize].init).offset_from((*ms).src_init) + 1) as lua_Integer,
            );
        }
        return capl as size_t;
    };
}
unsafe extern "C-unwind" fn push_onecapture(
    mut ms: *mut MatchState,
    mut i: i32,
    mut s: *const std::ffi::c_char,
    mut e: *const std::ffi::c_char,
) {
    let mut cap: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut l: ptrdiff_t = get_onecapture(ms, i, s, e, &mut cap) as ptrdiff_t;
    if l != -(2 as i32) as ptrdiff_t {
        lua_pushlstring((*ms).L, cap, l as size_t);
    }
}
unsafe extern "C-unwind" fn push_captures(
    mut ms: *mut MatchState,
    mut s: *const std::ffi::c_char,
    mut e: *const std::ffi::c_char,
) -> i32 {
    let mut i: i32 = 0;
    let mut nlevels: i32 = if (*ms).level as i32 == 0 && !s.is_null() {
        1 as i32
    } else {
        (*ms).level as i32
    };
    luaL_checkstack((*ms).L, nlevels, c"too many captures".as_ptr());
    i = 0;
    while i < nlevels {
        push_onecapture(ms, i, s, e);
        i += 1;
        i;
    }
    return nlevels;
}
unsafe extern "C-unwind" fn nospecials(mut p: *const std::ffi::c_char, mut l: size_t) -> i32 {
    let mut upto: size_t = 0 as size_t;
    loop {
        if !(strpbrk(p.offset(upto as isize), c"^$*+?.([%-".as_ptr())).is_null() {
            return 0;
        }
        upto = (upto as usize).wrapping_add((strlen(p.offset(upto as isize))).wrapping_add(1))
            as size_t as size_t;
        if !(upto <= l) {
            break;
        }
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn prepstate(
    mut ms: *mut MatchState,
    mut L: *mut lua_State,
    mut s: *const std::ffi::c_char,
    mut ls: size_t,
    mut p: *const std::ffi::c_char,
    mut lp: size_t,
) {
    (*ms).L = L;
    (*ms).matchdepth = 200;
    (*ms).src_init = s;
    (*ms).src_end = s.offset(ls as isize);
    (*ms).p_end = p.offset(lp as isize);
}
unsafe extern "C-unwind" fn reprepstate(mut ms: *mut MatchState) {
    (*ms).level = 0 as u8;
}
unsafe extern "C-unwind" fn str_find_aux(mut L: *mut lua_State, mut find: i32) -> i32 {
    let mut ls: size_t = 0;
    let mut lp: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut ls);
    let mut p: *const std::ffi::c_char = luaL_checklstring(L, 2 as i32, &mut lp);
    let mut init: size_t = (posrelatI(luaL_optinteger(L, 3 as i32, 1 as i32 as lua_Integer), ls))
        .wrapping_sub(1 as i32 as size_t);
    if init > ls {
        lua_pushnil(L);
        return 1 as i32;
    }
    if find != 0 && (lua_toboolean(L, 4 as i32) != 0 || nospecials(p, lp) != 0) {
        let mut s2: *const std::ffi::c_char =
            lmemfind(s.offset(init as isize), ls.wrapping_sub(init), p, lp);
        if !s2.is_null() {
            lua_pushinteger(L, (s2.offset_from(s) + 1) as lua_Integer);
            lua_pushinteger(
                L,
                (s2.offset_from(s) as std::ffi::c_long as size_t).wrapping_add(lp) as lua_Integer,
            );
            return 2 as i32;
        }
    } else {
        let mut ms: MatchState = MatchState {
            src_init: 0 as *const std::ffi::c_char,
            src_end: 0 as *const std::ffi::c_char,
            p_end: 0 as *const std::ffi::c_char,
            L: 0 as *mut lua_State,
            matchdepth: 0,
            level: 0,
            capture: [C2RustUnnamed_18 {
                init: 0 as *const std::ffi::c_char,
                len: 0,
            }; 32],
        };
        let mut s1: *const std::ffi::c_char = s.offset(init as isize);
        let mut anchor: i32 = (*p as i32 == '^' as i32) as i32;
        if anchor != 0 {
            p = p.offset(1);
            p;
            lp = lp.wrapping_sub(1);
            lp;
        }
        prepstate(&mut ms, L, s, ls, p, lp);
        loop {
            let mut res: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
            reprepstate(&mut ms);
            res = match_0(&mut ms, s1, p);
            if !res.is_null() {
                if find != 0 {
                    lua_pushinteger(L, (s1.offset_from(s) + 1) as lua_Integer);
                    lua_pushinteger(L, res.offset_from(s) as std::ffi::c_long as lua_Integer);
                    return push_captures(
                        &mut ms,
                        0 as *const std::ffi::c_char,
                        0 as *const std::ffi::c_char,
                    ) + 2 as i32;
                } else {
                    return push_captures(&mut ms, s1, res);
                }
            }
            let fresh169 = s1;
            s1 = s1.offset(1);
            if !(fresh169 < ms.src_end && anchor == 0) {
                break;
            }
        }
    }
    lua_pushnil(L);
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_find(mut L: *mut lua_State) -> i32 {
    return str_find_aux(L, 1 as i32);
}
unsafe extern "C-unwind" fn str_match(mut L: *mut lua_State) -> i32 {
    return str_find_aux(L, 0);
}
unsafe extern "C-unwind" fn gmatch_aux(mut L: *mut lua_State) -> i32 {
    let mut gm: *mut GMatchState =
        lua_touserdata(L, -(1000000) - 1000 - 3 as i32) as *mut GMatchState;
    let mut src: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    (*gm).ms.L = L;
    src = (*gm).src;
    while src <= (*gm).ms.src_end {
        let mut e: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
        reprepstate(&mut (*gm).ms);
        e = match_0(&mut (*gm).ms, src, (*gm).p);
        if !e.is_null() && e != (*gm).lastmatch {
            (*gm).lastmatch = e;
            (*gm).src = (*gm).lastmatch;
            return push_captures(&mut (*gm).ms, src, e);
        }
        src = src.offset(1);
        src;
    }
    return 0;
}
unsafe extern "C-unwind" fn gmatch(mut L: *mut lua_State) -> i32 {
    let mut ls: size_t = 0;
    let mut lp: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut ls);
    let mut p: *const std::ffi::c_char = luaL_checklstring(L, 2 as i32, &mut lp);
    let mut init: size_t = (posrelatI(luaL_optinteger(L, 3 as i32, 1 as i32 as lua_Integer), ls))
        .wrapping_sub(1 as i32 as size_t);
    let mut gm: *mut GMatchState = 0 as *mut GMatchState;
    lua_settop(L, 2 as i32);
    gm =
        lua_newuserdatauv(L, ::core::mem::size_of::<GMatchState>() as usize, 0) as *mut GMatchState;
    if init > ls {
        init = ls.wrapping_add(1 as i32 as size_t);
    }
    prepstate(&mut (*gm).ms, L, s, ls, p, lp);
    (*gm).src = s.offset(init as isize);
    (*gm).p = p;
    (*gm).lastmatch = 0 as *const std::ffi::c_char;
    lua_pushcclosure(
        L,
        Some(gmatch_aux as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
        3 as i32,
    );
    return 1 as i32;
}
unsafe extern "C-unwind" fn add_s(
    mut ms: *mut MatchState,
    mut b: *mut luaL_Buffer,
    mut s: *const std::ffi::c_char,
    mut e: *const std::ffi::c_char,
) {
    let mut l: size_t = 0;
    let mut L: *mut lua_State = (*ms).L;
    let mut news: *const std::ffi::c_char = lua_tolstring(L, 3 as i32, &mut l);
    let mut p: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    loop {
        p = memchr(news as *const c_void, '%' as i32, l) as *mut std::ffi::c_char;
        if p.is_null() {
            break;
        }
        luaL_addlstring(b, news, p.offset_from(news) as std::ffi::c_long as size_t);
        p = p.offset(1);
        p;
        if *p as i32 == '%' as i32 {
            ((*b).n < (*b).size || !(luaL_prepbuffsize(b, 1 as i32 as size_t)).is_null()) as i32;
            let fresh170 = (*b).n;
            (*b).n = ((*b).n).wrapping_add(1);
            *((*b).b).offset(fresh170 as isize) = *p;
        } else if *p as i32 == '0' as i32 {
            luaL_addlstring(b, s, e.offset_from(s) as std::ffi::c_long as size_t);
        } else if *(*__ctype_b_loc()).offset(*p as u8 as i32 as isize) as i32
            & _ISdigit as i32 as u16 as i32
            != 0
        {
            let mut cap: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
            let mut resl: ptrdiff_t =
                get_onecapture(ms, *p as i32 - '1' as i32, s, e, &mut cap) as ptrdiff_t;
            if resl == -(2 as i32) as ptrdiff_t {
                luaL_addvalue(b);
            } else {
                luaL_addlstring(b, cap, resl as size_t);
            }
        } else {
            luaL_error(
                L,
                c"invalid use of '%c' in replacement string".as_ptr(),
                '%' as i32,
            );
        }
        l = l.wrapping_sub(p.offset(1).offset_from(news) as std::ffi::c_long as size_t);
        news = p.offset(1);
    }
    luaL_addlstring(b, news, l);
}
unsafe extern "C-unwind" fn add_value(
    mut ms: *mut MatchState,
    mut b: *mut luaL_Buffer,
    mut s: *const std::ffi::c_char,
    mut e: *const std::ffi::c_char,
    mut tr: i32,
) -> i32 {
    let mut L: *mut lua_State = (*ms).L;
    match tr {
        6 => {
            let mut n: i32 = 0;
            lua_pushvalue(L, 3 as i32);
            n = push_captures(ms, s, e);
            lua_callk(L, n, 1 as i32, 0 as lua_KContext, None);
        }
        5 => {
            push_onecapture(ms, 0, s, e);
            lua_gettable(L, 3 as i32);
        }
        _ => {
            add_s(ms, b, s, e);
            return 1 as i32;
        }
    }
    if lua_toboolean(L, -(1 as i32)) == 0 {
        lua_settop(L, -(1 as i32) - 1 as i32);
        luaL_addlstring(b, s, e.offset_from(s) as std::ffi::c_long as size_t);
        return 0;
    } else if ((lua_isstring(L, -(1 as i32)) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        return luaL_error(
            L,
            c"invalid replacement value (a %s)".as_ptr(),
            lua_typename(L, lua_type(L, -(1 as i32))),
        );
    } else {
        luaL_addvalue(b);
        return 1 as i32;
    };
}
unsafe extern "C-unwind" fn str_gsub(mut L: *mut lua_State) -> i32 {
    let mut srcl: size_t = 0;
    let mut lp: size_t = 0;
    let mut src: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut srcl);
    let mut p: *const std::ffi::c_char = luaL_checklstring(L, 2 as i32, &mut lp);
    let mut lastmatch: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut tr: i32 = lua_type(L, 3 as i32);
    let mut max_s: lua_Integer = luaL_optinteger(
        L,
        4 as i32,
        srcl.wrapping_add(1 as i32 as size_t) as lua_Integer,
    );
    let mut anchor: i32 = (*p as i32 == '^' as i32) as i32;
    let mut n: lua_Integer = 0 as lua_Integer;
    let mut changed: i32 = 0;
    let mut ms: MatchState = MatchState {
        src_init: 0 as *const std::ffi::c_char,
        src_end: 0 as *const std::ffi::c_char,
        p_end: 0 as *const std::ffi::c_char,
        L: 0 as *mut lua_State,
        matchdepth: 0,
        level: 0,
        capture: [C2RustUnnamed_18 {
            init: 0 as *const std::ffi::c_char,
            len: 0,
        }; 32],
    };
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    (((tr == 3 as i32 || tr == 4 as i32 || tr == 6 as i32 || tr == 5 as i32) as i32 != 0) as i32
        as std::ffi::c_long
        != 0
        || luaL_typeerror(L, 3 as i32, c"string/function/table".as_ptr()) != 0) as i32;
    luaL_buffinit(L, &mut b);
    if anchor != 0 {
        p = p.offset(1);
        p;
        lp = lp.wrapping_sub(1);
        lp;
    }
    prepstate(&mut ms, L, src, srcl, p, lp);
    while n < max_s {
        let mut e: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
        reprepstate(&mut ms);
        e = match_0(&mut ms, src, p);
        if !e.is_null() && e != lastmatch {
            n += 1;
            n;
            changed = add_value(&mut ms, &mut b, src, e, tr) | changed;
            lastmatch = e;
            src = lastmatch;
        } else {
            if !(src < ms.src_end) {
                break;
            }
            (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
            let fresh171 = src;
            src = src.offset(1);
            let fresh172 = b.n;
            b.n = (b.n).wrapping_add(1);
            *(b.b).offset(fresh172 as isize) = *fresh171;
        }
        if anchor != 0 {
            break;
        }
    }
    if changed == 0 {
        lua_pushvalue(L, 1 as i32);
    } else {
        luaL_addlstring(
            &mut b,
            src,
            (ms.src_end).offset_from(src) as std::ffi::c_long as size_t,
        );
        luaL_pushresult(&mut b);
    }
    lua_pushinteger(L, n);
    return 2 as i32;
}
unsafe extern "C-unwind" fn addquoted(
    mut b: *mut luaL_Buffer,
    mut s: *const std::ffi::c_char,
    mut len: size_t,
) {
    ((*b).n < (*b).size || !(luaL_prepbuffsize(b, 1 as i32 as size_t)).is_null()) as i32;
    let fresh173 = (*b).n;
    (*b).n = ((*b).n).wrapping_add(1);
    *((*b).b).offset(fresh173 as isize) = '"' as i32 as std::ffi::c_char;
    loop {
        let fresh174 = len;
        len = len.wrapping_sub(1);
        if !(fresh174 != 0) {
            break;
        }
        if *s as i32 == '"' as i32 || *s as i32 == '\\' as i32 || *s as i32 == '\n' as i32 {
            ((*b).n < (*b).size || !(luaL_prepbuffsize(b, 1 as i32 as size_t)).is_null()) as i32;
            let fresh175 = (*b).n;
            (*b).n = ((*b).n).wrapping_add(1);
            *((*b).b).offset(fresh175 as isize) = '\\' as i32 as std::ffi::c_char;
            ((*b).n < (*b).size || !(luaL_prepbuffsize(b, 1 as i32 as size_t)).is_null()) as i32;
            let fresh176 = (*b).n;
            (*b).n = ((*b).n).wrapping_add(1);
            *((*b).b).offset(fresh176 as isize) = *s;
        } else if *(*__ctype_b_loc()).offset(*s as u8 as i32 as isize) as i32
            & _IScntrl as i32 as u16 as i32
            != 0
        {
            let mut buff: [std::ffi::c_char; 10] = [0; 10];
            if *(*__ctype_b_loc()).offset(*s.offset(1) as u8 as i32 as isize) as i32
                & _ISdigit as i32 as u16 as i32
                == 0
            {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[std::ffi::c_char; 10]>() as usize,
                    c"\\%d".as_ptr(),
                    *s as u8 as i32,
                );
            } else {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[std::ffi::c_char; 10]>() as usize,
                    c"\\%03d".as_ptr(),
                    *s as u8 as i32,
                );
            }
            luaL_addstring(b, buff.as_mut_ptr());
        } else {
            ((*b).n < (*b).size || !(luaL_prepbuffsize(b, 1 as i32 as size_t)).is_null()) as i32;
            let fresh177 = (*b).n;
            (*b).n = ((*b).n).wrapping_add(1);
            *((*b).b).offset(fresh177 as isize) = *s;
        }
        s = s.offset(1);
        s;
    }
    ((*b).n < (*b).size || !(luaL_prepbuffsize(b, 1 as i32 as size_t)).is_null()) as i32;
    let fresh178 = (*b).n;
    (*b).n = ((*b).n).wrapping_add(1);
    *((*b).b).offset(fresh178 as isize) = '"' as i32 as std::ffi::c_char;
}
unsafe extern "C-unwind" fn quotefloat(
    mut L: *mut lua_State,
    mut buff: *mut std::ffi::c_char,
    mut n: lua_Number,
) -> i32 {
    let mut s: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    if n == ::core::f64::INFINITY {
        s = c"1e9999".as_ptr();
    } else if n == -::core::f64::INFINITY {
        s = c"-1e9999".as_ptr();
    } else if n != n {
        s = c"(0/0)".as_ptr();
    } else {
        let mut nb: i32 = snprintf(buff, 120 as usize, c"%a".as_ptr(), n);
        if (memchr(buff as *const c_void, '.' as i32, nb as usize)).is_null() {
            let mut point: std::ffi::c_char = *((*localeconv()).decimal_point).offset(0 as isize);
            let mut ppoint: *mut std::ffi::c_char =
                memchr(buff as *const c_void, point as i32, nb as usize) as *mut std::ffi::c_char;
            if !ppoint.is_null() {
                *ppoint = '.' as i32 as std::ffi::c_char;
            }
        }
        return nb;
    }
    return snprintf(buff, 120 as usize, c"%s".as_ptr(), s);
}
unsafe extern "C-unwind" fn addliteral(
    mut L: *mut lua_State,
    mut b: *mut luaL_Buffer,
    mut arg: i32,
) {
    match lua_type(L, arg) {
        4 => {
            let mut len: size_t = 0;
            let mut s: *const std::ffi::c_char = lua_tolstring(L, arg, &mut len);
            addquoted(b, s, len);
        }
        3 => {
            let mut buff: *mut std::ffi::c_char = luaL_prepbuffsize(b, 120 as size_t);
            let mut nb: i32 = 0;
            if lua_isinteger(L, arg) == 0 {
                nb = quotefloat(L, buff, lua_tonumberx(L, arg, 0 as *mut i32));
            } else {
                let mut n: lua_Integer = lua_tointegerx(L, arg, 0 as *mut i32);
                let mut format: *const std::ffi::c_char = if n
                    == -(9223372036854775807 as std::ffi::c_longlong) - 1 as std::ffi::c_longlong
                {
                    c"0x%llx".as_ptr()
                } else {
                    c"%lld".as_ptr()
                };
                nb = snprintf(buff, 120 as usize, format, n);
            }
            (*b).n = ((*b).n).wrapping_add(nb as size_t);
        }
        0 | 1 => {
            luaL_tolstring(L, arg, 0 as *mut size_t);
            luaL_addvalue(b);
        }
        _ => {
            luaL_argerror(L, arg, c"value has no literal form".as_ptr());
        }
    };
}
unsafe extern "C-unwind" fn get2digits(mut s: *const std::ffi::c_char) -> *const std::ffi::c_char {
    if *(*__ctype_b_loc()).offset(*s as u8 as i32 as isize) as i32 & _ISdigit as i32 as u16 as i32
        != 0
    {
        s = s.offset(1);
        s;
        if *(*__ctype_b_loc()).offset(*s as u8 as i32 as isize) as i32
            & _ISdigit as i32 as u16 as i32
            != 0
        {
            s = s.offset(1);
            s;
        }
    }
    return s;
}
unsafe extern "C-unwind" fn checkformat(
    mut L: *mut lua_State,
    mut form: *const std::ffi::c_char,
    mut flags: *const std::ffi::c_char,
    mut precision: i32,
) {
    let mut spec: *const std::ffi::c_char = form.offset(1);
    spec = spec.offset(strspn(spec, flags) as isize);
    if *spec as i32 != '0' as i32 {
        spec = get2digits(spec);
        if *spec as i32 == '.' as i32 && precision != 0 {
            spec = spec.offset(1);
            spec;
            spec = get2digits(spec);
        }
    }
    if *(*__ctype_b_loc()).offset(*spec as u8 as i32 as isize) as i32
        & _ISalpha as i32 as u16 as i32
        == 0
    {
        luaL_error(L, c"invalid conversion specification: '%s'".as_ptr(), form);
    }
}
unsafe extern "C-unwind" fn getformat(
    mut L: *mut lua_State,
    mut strfrmt: *const std::ffi::c_char,
    mut form: *mut std::ffi::c_char,
) -> *const std::ffi::c_char {
    let mut len: size_t = strspn(strfrmt, c"-+#0 123456789.".as_ptr());
    len = len.wrapping_add(1);
    len;
    if len >= (32 as i32 - 10) as size_t {
        luaL_error(L, c"invalid format (too long)".as_ptr());
    }
    let fresh179 = form;
    form = form.offset(1);
    *fresh179 = '%' as i32 as std::ffi::c_char;
    memcpy(
        form as *mut c_void,
        strfrmt as *const c_void,
        len.wrapping_mul(::core::mem::size_of::<std::ffi::c_char>() as usize),
    );
    *form.offset(len as isize) = '\0' as i32 as std::ffi::c_char;
    return strfrmt.offset(len as isize).offset(-(1));
}
unsafe extern "C-unwind" fn addlenmod(
    mut form: *mut std::ffi::c_char,
    mut lenmod: *const std::ffi::c_char,
) {
    let mut l: size_t = strlen(form);
    let mut lm: size_t = strlen(lenmod);
    let mut spec: std::ffi::c_char = *form.offset(l.wrapping_sub(1 as i32 as size_t) as isize);
    strcpy(form.offset(l as isize).offset(-(1)), lenmod);
    *form.offset(l.wrapping_add(lm).wrapping_sub(1 as i32 as size_t) as isize) = spec;
    *form.offset(l.wrapping_add(lm) as isize) = '\0' as i32 as std::ffi::c_char;
}
unsafe extern "C-unwind" fn str_format(mut L: *mut lua_State) -> i32 {
    let mut current_block: u64;
    let mut top: i32 = lua_gettop(L);
    let mut arg: i32 = 1 as i32;
    let mut sfl: size_t = 0;
    let mut strfrmt: *const std::ffi::c_char = luaL_checklstring(L, arg, &mut sfl);
    let mut strfrmt_end: *const std::ffi::c_char = strfrmt.offset(sfl as isize);
    let mut flags: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    luaL_buffinit(L, &mut b);
    while strfrmt < strfrmt_end {
        if *strfrmt as i32 != '%' as i32 {
            (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
            let fresh180 = strfrmt;
            strfrmt = strfrmt.offset(1);
            let fresh181 = b.n;
            b.n = (b.n).wrapping_add(1);
            *(b.b).offset(fresh181 as isize) = *fresh180;
        } else {
            strfrmt = strfrmt.offset(1);
            if *strfrmt as i32 == '%' as i32 {
                (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
                let fresh182 = strfrmt;
                strfrmt = strfrmt.offset(1);
                let fresh183 = b.n;
                b.n = (b.n).wrapping_add(1);
                *(b.b).offset(fresh183 as isize) = *fresh182;
            } else {
                let mut form: [std::ffi::c_char; 32] = [0; 32];
                let mut maxitem: i32 = 120;
                let mut buff: *mut std::ffi::c_char = luaL_prepbuffsize(&mut b, maxitem as size_t);
                let mut nb: i32 = 0;
                arg += 1;
                if arg > top {
                    return luaL_argerror(L, arg, c"no value".as_ptr());
                }
                strfrmt = getformat(L, strfrmt, form.as_mut_ptr());
                let fresh184 = strfrmt;
                strfrmt = strfrmt.offset(1);
                match *fresh184 as i32 {
                    99 => {
                        checkformat(L, form.as_mut_ptr(), c"-".as_ptr(), 0);
                        nb = snprintf(
                            buff,
                            maxitem as usize,
                            form.as_mut_ptr(),
                            luaL_checkinteger(L, arg) as i32,
                        );
                        current_block = 11793792312832361944;
                    }
                    100 | 105 => {
                        flags = c"-+0 ".as_ptr();
                        current_block = 5689001924483802034;
                    }
                    117 => {
                        flags = c"-0".as_ptr();
                        current_block = 5689001924483802034;
                    }
                    111 | 120 | 88 => {
                        flags = c"-#0".as_ptr();
                        current_block = 5689001924483802034;
                    }
                    97 | 65 => {
                        checkformat(L, form.as_mut_ptr(), c"-+#0 ".as_ptr(), 1 as i32);
                        addlenmod(form.as_mut_ptr(), c"".as_ptr());
                        nb = snprintf(
                            buff,
                            maxitem as usize,
                            form.as_mut_ptr(),
                            luaL_checknumber(L, arg),
                        );
                        current_block = 11793792312832361944;
                    }
                    102 => {
                        maxitem = 110 + 308 as i32;
                        buff = luaL_prepbuffsize(&mut b, maxitem as size_t);
                        current_block = 6669252993407410313;
                    }
                    101 | 69 | 103 | 71 => {
                        current_block = 6669252993407410313;
                    }
                    112 => {
                        let mut p: *const c_void = lua_topointer(L, arg);
                        checkformat(L, form.as_mut_ptr(), c"-".as_ptr(), 0);
                        if p.is_null() {
                            p = c"(null)".as_ptr() as *const c_void;
                            form[(strlen(form.as_mut_ptr())).wrapping_sub(1) as usize] =
                                's' as i32 as std::ffi::c_char;
                        }
                        nb = snprintf(buff, maxitem as usize, form.as_mut_ptr(), p);
                        current_block = 11793792312832361944;
                    }
                    113 => {
                        if form[2] as i32 != '\0' as i32 {
                            return luaL_error(
                                L,
                                c"specifier '%%q' cannot have modifiers".as_ptr(),
                            );
                        }
                        addliteral(L, &mut b, arg);
                        current_block = 11793792312832361944;
                    }
                    115 => {
                        let mut l: size_t = 0;
                        let mut s: *const std::ffi::c_char = luaL_tolstring(L, arg, &mut l);
                        if form[2] as i32 == '\0' as i32 {
                            luaL_addvalue(&mut b);
                        } else {
                            (((l == strlen(s)) as i32 != 0) as i32 as std::ffi::c_long != 0
                                || luaL_argerror(L, arg, c"string contains zeros".as_ptr()) != 0)
                                as i32;
                            checkformat(L, form.as_mut_ptr(), c"-".as_ptr(), 1 as i32);
                            if (strchr(form.as_mut_ptr(), '.' as i32)).is_null()
                                && l >= 100 as size_t
                            {
                                luaL_addvalue(&mut b);
                            } else {
                                nb = snprintf(buff, maxitem as usize, form.as_mut_ptr(), s);
                                lua_settop(L, -(1 as i32) - 1 as i32);
                            }
                        }
                        current_block = 11793792312832361944;
                    }
                    _ => {
                        return luaL_error(
                            L,
                            c"invalid conversion '%s' to 'format'".as_ptr(),
                            form.as_mut_ptr(),
                        );
                    }
                }
                match current_block {
                    5689001924483802034 => {
                        let mut n: lua_Integer = luaL_checkinteger(L, arg);
                        checkformat(L, form.as_mut_ptr(), flags, 1 as i32);
                        addlenmod(form.as_mut_ptr(), c"ll".as_ptr());
                        nb = snprintf(buff, maxitem as usize, form.as_mut_ptr(), n);
                    }
                    6669252993407410313 => {
                        let mut n_0: lua_Number = luaL_checknumber(L, arg);
                        checkformat(L, form.as_mut_ptr(), c"-+#0 ".as_ptr(), 1 as i32);
                        addlenmod(form.as_mut_ptr(), c"".as_ptr());
                        nb = snprintf(buff, maxitem as usize, form.as_mut_ptr(), n_0);
                    }
                    _ => {}
                }
                b.n = (b.n).wrapping_add(nb as size_t);
            }
        }
    }
    luaL_pushresult(&mut b);
    return 1 as i32;
}
static mut nativeendian: C2RustUnnamed_16 = C2RustUnnamed_16 { dummy: 1 as i32 };
unsafe extern "C-unwind" fn digit(mut c: i32) -> i32 {
    return ('0' as i32 <= c && c <= '9' as i32) as i32;
}
unsafe extern "C-unwind" fn getnum(mut fmt: *mut *const std::ffi::c_char, mut df: i32) -> i32 {
    if digit(**fmt as i32) == 0 {
        return df;
    } else {
        let mut a: i32 = 0;
        loop {
            let fresh185 = *fmt;
            *fmt = (*fmt).offset(1);
            a = a * 10 + (*fresh185 as i32 - '0' as i32);
            if !(digit(**fmt as i32) != 0
                && a <= ((if (::core::mem::size_of::<size_t>() as usize)
                    < ::core::mem::size_of::<i32>() as usize
                {
                    !(0 as size_t)
                } else {
                    2147483647 as i32 as size_t
                }) as i32
                    - 9 as i32)
                    / 10)
            {
                break;
            }
        }
        return a;
    };
}
unsafe extern "C-unwind" fn getnumlimit(
    mut h: *mut Header,
    mut fmt: *mut *const std::ffi::c_char,
    mut df: i32,
) -> i32 {
    let mut sz: i32 = getnum(fmt, df);
    if ((sz > 16 as i32 || sz <= 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        return luaL_error(
            (*h).L,
            c"integral size (%d) out of limits [1,%d]".as_ptr(),
            sz,
            16 as i32,
        );
    }
    return sz;
}
unsafe extern "C-unwind" fn initheader(mut L: *mut lua_State, mut h: *mut Header) {
    (*h).L = L;
    (*h).islittle = nativeendian.little as i32;
    (*h).maxalign = 1 as i32;
}
unsafe extern "C-unwind" fn getoption(
    mut h: *mut Header,
    mut fmt: *mut *const std::ffi::c_char,
    mut size: *mut i32,
) -> KOption {
    let fresh186 = *fmt;
    *fmt = (*fmt).offset(1);
    let mut opt: i32 = *fresh186 as i32;
    *size = 0;
    match opt {
        98 => {
            *size = ::core::mem::size_of::<std::ffi::c_char>() as usize as i32;
            return Kint;
        }
        66 => {
            *size = ::core::mem::size_of::<std::ffi::c_char>() as usize as i32;
            return Kuint;
        }
        104 => {
            *size = ::core::mem::size_of::<std::ffi::c_short>() as usize as i32;
            return Kint;
        }
        72 => {
            *size = ::core::mem::size_of::<std::ffi::c_short>() as usize as i32;
            return Kuint;
        }
        108 => {
            *size = ::core::mem::size_of::<std::ffi::c_long>() as usize as i32;
            return Kint;
        }
        76 => {
            *size = ::core::mem::size_of::<std::ffi::c_long>() as usize as i32;
            return Kuint;
        }
        106 => {
            *size = ::core::mem::size_of::<lua_Integer>() as usize as i32;
            return Kint;
        }
        74 => {
            *size = ::core::mem::size_of::<lua_Integer>() as usize as i32;
            return Kuint;
        }
        84 => {
            *size = ::core::mem::size_of::<size_t>() as usize as i32;
            return Kuint;
        }
        102 => {
            *size = ::core::mem::size_of::<std::ffi::c_float>() as usize as i32;
            return Kfloat;
        }
        110 => {
            *size = ::core::mem::size_of::<lua_Number>() as usize as i32;
            return Knumber;
        }
        100 => {
            *size = ::core::mem::size_of::<std::ffi::c_double>() as usize as i32;
            return Kdouble;
        }
        105 => {
            *size = getnumlimit(h, fmt, ::core::mem::size_of::<i32>() as usize as i32);
            return Kint;
        }
        73 => {
            *size = getnumlimit(h, fmt, ::core::mem::size_of::<i32>() as usize as i32);
            return Kuint;
        }
        115 => {
            *size = getnumlimit(h, fmt, ::core::mem::size_of::<size_t>() as usize as i32);
            return Kstring;
        }
        99 => {
            *size = getnum(fmt, -(1 as i32));
            if ((*size == -(1 as i32)) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                luaL_error((*h).L, c"missing size for format option 'c'".as_ptr());
            }
            return Kchar;
        }
        122 => return Kzstr,
        120 => {
            *size = 1 as i32;
            return Kpadding;
        }
        88 => return Kpaddalign,
        32 => {}
        60 => {
            (*h).islittle = 1 as i32;
        }
        62 => {
            (*h).islittle = 0;
        }
        61 => {
            (*h).islittle = nativeendian.little as i32;
        }
        33 => {
            let maxalign: i32 = 8 as usize as i32;
            (*h).maxalign = getnumlimit(h, fmt, maxalign);
        }
        _ => {
            luaL_error((*h).L, c"invalid format option '%c'".as_ptr(), opt);
        }
    }
    return Knop;
}
unsafe extern "C-unwind" fn getdetails(
    mut h: *mut Header,
    mut totalsize: size_t,
    mut fmt: *mut *const std::ffi::c_char,
    mut psize: *mut i32,
    mut ntoalign: *mut i32,
) -> KOption {
    let mut opt: KOption = getoption(h, fmt, psize);
    let mut align: i32 = *psize;
    if opt as u32 == Kpaddalign as i32 as u32 {
        if **fmt as i32 == '\0' as i32
            || getoption(h, fmt, &mut align) as u32 == Kchar as i32 as u32
            || align == 0
        {
            luaL_argerror(
                (*h).L,
                1 as i32,
                c"invalid next option for option 'X'".as_ptr(),
            );
        }
    }
    if align <= 1 as i32 || opt as u32 == Kchar as i32 as u32 {
        *ntoalign = 0;
    } else {
        if align > (*h).maxalign {
            align = (*h).maxalign;
        }
        if ((align & align - 1 as i32 != 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
            luaL_argerror(
                (*h).L,
                1 as i32,
                c"format asks for alignment not power of 2".as_ptr(),
            );
        }
        *ntoalign = align - (totalsize & (align - 1 as i32) as size_t) as i32 & align - 1 as i32;
    }
    return opt;
}
unsafe extern "C-unwind" fn packint(
    mut b: *mut luaL_Buffer,
    mut n: lua_Unsigned,
    mut islittle: i32,
    mut size: i32,
    mut neg: i32,
) {
    let mut buff: *mut std::ffi::c_char = luaL_prepbuffsize(b, size as size_t);
    let mut i: i32 = 0;
    *buff.offset((if islittle != 0 { 0 } else { size - 1 as i32 }) as isize) =
        (n & (((1 as i32) << 8 as i32) - 1 as i32) as lua_Unsigned) as std::ffi::c_char;
    i = 1 as i32;
    while i < size {
        n >>= 8 as i32;
        *buff.offset(
            (if islittle != 0 {
                i
            } else {
                size - 1 as i32 - i
            }) as isize,
        ) = (n & (((1 as i32) << 8 as i32) - 1 as i32) as lua_Unsigned) as std::ffi::c_char;
        i += 1;
        i;
    }
    if neg != 0 && size > ::core::mem::size_of::<lua_Integer>() as usize as i32 {
        i = ::core::mem::size_of::<lua_Integer>() as usize as i32;
        while i < size {
            *buff.offset(
                (if islittle != 0 {
                    i
                } else {
                    size - 1 as i32 - i
                }) as isize,
            ) = (((1 as i32) << 8 as i32) - 1 as i32) as std::ffi::c_char;
            i += 1;
            i;
        }
    }
    (*b).n = ((*b).n).wrapping_add(size as size_t);
}
unsafe extern "C-unwind" fn copywithendian(
    mut dest: *mut std::ffi::c_char,
    mut src: *const std::ffi::c_char,
    mut size: i32,
    mut islittle: i32,
) {
    if islittle == nativeendian.little as i32 {
        memcpy(dest as *mut c_void, src as *const c_void, size as usize);
    } else {
        dest = dest.offset((size - 1 as i32) as isize);
        loop {
            let fresh187 = size;
            size = size - 1;
            if !(fresh187 != 0) {
                break;
            }
            let fresh188 = src;
            src = src.offset(1);
            let fresh189 = dest;
            dest = dest.offset(-1);
            *fresh189 = *fresh188;
        }
    };
}
unsafe extern "C-unwind" fn str_pack(mut L: *mut lua_State) -> i32 {
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    let mut h: Header = Header {
        L: 0 as *mut lua_State,
        islittle: 0,
        maxalign: 0,
    };
    let mut fmt: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut arg: i32 = 1 as i32;
    let mut totalsize: size_t = 0 as size_t;
    initheader(L, &mut h);
    lua_pushnil(L);
    luaL_buffinit(L, &mut b);
    while *fmt as i32 != '\0' as i32 {
        let mut size: i32 = 0;
        let mut ntoalign: i32 = 0;
        let mut opt: KOption = getdetails(&mut h, totalsize, &mut fmt, &mut size, &mut ntoalign);
        totalsize = totalsize.wrapping_add((ntoalign + size) as size_t);
        loop {
            let fresh190 = ntoalign;
            ntoalign = ntoalign - 1;
            if !(fresh190 > 0) {
                break;
            }
            (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
            let fresh191 = b.n;
            b.n = (b.n).wrapping_add(1);
            *(b.b).offset(fresh191 as isize) = 0 as std::ffi::c_char;
        }
        arg += 1;
        arg;
        let mut current_block_33: u64;
        match opt as u32 {
            0 => {
                let mut n: lua_Integer = luaL_checkinteger(L, arg);
                if size < ::core::mem::size_of::<lua_Integer>() as usize as i32 {
                    let mut lim: lua_Integer =
                        (1 as i32 as lua_Integer) << size * 8 as i32 - 1 as i32;
                    (((-lim <= n && n < lim) as i32 != 0) as i32 as std::ffi::c_long != 0
                        || luaL_argerror(L, arg, c"integer overflow".as_ptr()) != 0)
                        as i32;
                }
                packint(
                    &mut b,
                    n as lua_Unsigned,
                    h.islittle,
                    size,
                    (n < 0 as lua_Integer) as i32,
                );
                current_block_33 = 3222590281903869779;
            }
            1 => {
                let mut n_0: lua_Integer = luaL_checkinteger(L, arg);
                if size < ::core::mem::size_of::<lua_Integer>() as usize as i32 {
                    ((((n_0 as lua_Unsigned) < (1 as i32 as lua_Unsigned) << size * 8 as i32)
                        as i32
                        != 0) as i32 as std::ffi::c_long
                        != 0
                        || luaL_argerror(L, arg, c"unsigned overflow".as_ptr()) != 0)
                        as i32;
                }
                packint(&mut b, n_0 as lua_Unsigned, h.islittle, size, 0);
                current_block_33 = 3222590281903869779;
            }
            2 => {
                let mut f: std::ffi::c_float = luaL_checknumber(L, arg) as std::ffi::c_float;
                let mut buff: *mut std::ffi::c_char =
                    luaL_prepbuffsize(&mut b, ::core::mem::size_of::<std::ffi::c_float>() as usize);
                copywithendian(
                    buff,
                    &mut f as *mut std::ffi::c_float as *mut std::ffi::c_char,
                    ::core::mem::size_of::<std::ffi::c_float>() as usize as i32,
                    h.islittle,
                );
                b.n = (b.n).wrapping_add(size as size_t);
                current_block_33 = 3222590281903869779;
            }
            3 => {
                let mut f_0: lua_Number = luaL_checknumber(L, arg);
                let mut buff_0: *mut std::ffi::c_char =
                    luaL_prepbuffsize(&mut b, ::core::mem::size_of::<lua_Number>() as usize);
                copywithendian(
                    buff_0,
                    &mut f_0 as *mut lua_Number as *mut std::ffi::c_char,
                    ::core::mem::size_of::<lua_Number>() as usize as i32,
                    h.islittle,
                );
                b.n = (b.n).wrapping_add(size as size_t);
                current_block_33 = 3222590281903869779;
            }
            4 => {
                let mut f_1: std::ffi::c_double = luaL_checknumber(L, arg);
                let mut buff_1: *mut std::ffi::c_char = luaL_prepbuffsize(
                    &mut b,
                    ::core::mem::size_of::<std::ffi::c_double>() as usize,
                );
                copywithendian(
                    buff_1,
                    &mut f_1 as *mut std::ffi::c_double as *mut std::ffi::c_char,
                    ::core::mem::size_of::<std::ffi::c_double>() as usize as i32,
                    h.islittle,
                );
                b.n = (b.n).wrapping_add(size as size_t);
                current_block_33 = 3222590281903869779;
            }
            5 => {
                let mut len: size_t = 0;
                let mut s: *const std::ffi::c_char = luaL_checklstring(L, arg, &mut len);
                (((len <= size as size_t) as i32 != 0) as i32 as std::ffi::c_long != 0
                    || luaL_argerror(L, arg, c"string longer than given size".as_ptr()) != 0)
                    as i32;
                luaL_addlstring(&mut b, s, len);
                loop {
                    let fresh192 = len;
                    len = len.wrapping_add(1);
                    if !(fresh192 < size as size_t) {
                        break;
                    }
                    (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null())
                        as i32;
                    let fresh193 = b.n;
                    b.n = (b.n).wrapping_add(1);
                    *(b.b).offset(fresh193 as isize) = 0 as std::ffi::c_char;
                }
                current_block_33 = 3222590281903869779;
            }
            6 => {
                let mut len_0: size_t = 0;
                let mut s_0: *const std::ffi::c_char = luaL_checklstring(L, arg, &mut len_0);
                (((size >= ::core::mem::size_of::<size_t>() as usize as i32
                    || len_0 < (1 as i32 as size_t) << size * 8 as i32) as i32
                    != 0) as i32 as std::ffi::c_long
                    != 0
                    || luaL_argerror(L, arg, c"string length does not fit in given size".as_ptr())
                        != 0) as i32;
                packint(&mut b, len_0 as lua_Unsigned, h.islittle, size, 0);
                luaL_addlstring(&mut b, s_0, len_0);
                totalsize = totalsize.wrapping_add(len_0);
                current_block_33 = 3222590281903869779;
            }
            7 => {
                let mut len_1: size_t = 0;
                let mut s_1: *const std::ffi::c_char = luaL_checklstring(L, arg, &mut len_1);
                (((strlen(s_1) == len_1) as i32 != 0) as i32 as std::ffi::c_long != 0
                    || luaL_argerror(L, arg, c"string contains zeros".as_ptr()) != 0)
                    as i32;
                luaL_addlstring(&mut b, s_1, len_1);
                (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
                let fresh194 = b.n;
                b.n = (b.n).wrapping_add(1);
                *(b.b).offset(fresh194 as isize) = '\0' as i32 as std::ffi::c_char;
                totalsize = totalsize.wrapping_add(len_1.wrapping_add(1 as i32 as size_t));
                current_block_33 = 3222590281903869779;
            }
            8 => {
                (b.n < b.size || !(luaL_prepbuffsize(&mut b, 1 as i32 as size_t)).is_null()) as i32;
                let fresh195 = b.n;
                b.n = (b.n).wrapping_add(1);
                *(b.b).offset(fresh195 as isize) = 0 as std::ffi::c_char;
                current_block_33 = 3092145676633685342;
            }
            9 | 10 => {
                current_block_33 = 3092145676633685342;
            }
            _ => {
                current_block_33 = 3222590281903869779;
            }
        }
        match current_block_33 {
            3092145676633685342 => {
                arg -= 1;
                arg;
            }
            _ => {}
        }
    }
    luaL_pushresult(&mut b);
    return 1 as i32;
}
unsafe extern "C-unwind" fn str_packsize(mut L: *mut lua_State) -> i32 {
    let mut h: Header = Header {
        L: 0 as *mut lua_State,
        islittle: 0,
        maxalign: 0,
    };
    let mut fmt: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut totalsize: size_t = 0 as size_t;
    initheader(L, &mut h);
    while *fmt as i32 != '\0' as i32 {
        let mut size: i32 = 0;
        let mut ntoalign: i32 = 0;
        let mut opt: KOption = getdetails(&mut h, totalsize, &mut fmt, &mut size, &mut ntoalign);
        (((opt as u32 != Kstring as i32 as u32 && opt as u32 != Kzstr as i32 as u32) as i32 != 0)
            as i32 as std::ffi::c_long
            != 0
            || luaL_argerror(L, 1 as i32, c"variable-length format".as_ptr()) != 0) as i32;
        size += ntoalign;
        (((totalsize
            <= (if (::core::mem::size_of::<size_t>() as usize)
                < ::core::mem::size_of::<i32>() as usize
            {
                !(0 as size_t)
            } else {
                2147483647 as i32 as size_t
            })
            .wrapping_sub(size as size_t)) as i32
            != 0) as i32 as std::ffi::c_long
            != 0
            || luaL_argerror(L, 1 as i32, c"format result too large".as_ptr()) != 0) as i32;
        totalsize = totalsize.wrapping_add(size as size_t);
    }
    lua_pushinteger(L, totalsize as lua_Integer);
    return 1 as i32;
}
unsafe extern "C-unwind" fn unpackint(
    mut L: *mut lua_State,
    mut str: *const std::ffi::c_char,
    mut islittle: i32,
    mut size: i32,
    mut issigned: i32,
) -> lua_Integer {
    let mut res: lua_Unsigned = 0 as lua_Unsigned;
    let mut i: i32 = 0;
    let mut limit: i32 = if size <= ::core::mem::size_of::<lua_Integer>() as usize as i32 {
        size
    } else {
        ::core::mem::size_of::<lua_Integer>() as usize as i32
    };
    i = limit - 1 as i32;
    while i >= 0 {
        res <<= 8 as i32;
        res |= *str.offset(
            (if islittle != 0 {
                i
            } else {
                size - 1 as i32 - i
            }) as isize,
        ) as u8 as lua_Unsigned;
        i -= 1;
        i;
    }
    if size < ::core::mem::size_of::<lua_Integer>() as usize as i32 {
        if issigned != 0 {
            let mut mask: lua_Unsigned = (1 as i32 as lua_Unsigned) << size * 8 as i32 - 1 as i32;
            res = (res ^ mask).wrapping_sub(mask);
        }
    } else if size > ::core::mem::size_of::<lua_Integer>() as usize as i32 {
        let mut mask_0: i32 = if issigned == 0 || res as lua_Integer >= 0 as lua_Integer {
            0
        } else {
            ((1 as i32) << 8 as i32) - 1 as i32
        };
        i = limit;
        while i < size {
            if ((*str.offset(
                (if islittle != 0 {
                    i
                } else {
                    size - 1 as i32 - i
                }) as isize,
            ) as u8 as i32
                != mask_0) as i32
                != 0) as i32 as std::ffi::c_long
                != 0
            {
                luaL_error(
                    L,
                    c"%d-byte integer does not fit into Lua Integer".as_ptr(),
                    size,
                );
            }
            i += 1;
            i;
        }
    }
    return res as lua_Integer;
}
unsafe extern "C-unwind" fn str_unpack(mut L: *mut lua_State) -> i32 {
    let mut h: Header = Header {
        L: 0 as *mut lua_State,
        islittle: 0,
        maxalign: 0,
    };
    let mut fmt: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    let mut ld: size_t = 0;
    let mut data: *const std::ffi::c_char = luaL_checklstring(L, 2 as i32, &mut ld);
    let mut pos: size_t = (posrelatI(luaL_optinteger(L, 3 as i32, 1 as i32 as lua_Integer), ld))
        .wrapping_sub(1 as i32 as size_t);
    let mut n: i32 = 0;
    (((pos <= ld) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 3 as i32, c"initial position out of string".as_ptr()) != 0) as i32;
    initheader(L, &mut h);
    while *fmt as i32 != '\0' as i32 {
        let mut size: i32 = 0;
        let mut ntoalign: i32 = 0;
        let mut opt: KOption = getdetails(&mut h, pos, &mut fmt, &mut size, &mut ntoalign);
        ((((ntoalign as size_t).wrapping_add(size as size_t) <= ld.wrapping_sub(pos)) as i32 != 0)
            as i32 as std::ffi::c_long
            != 0
            || luaL_argerror(L, 2 as i32, c"data string too short".as_ptr()) != 0) as i32;
        pos = pos.wrapping_add(ntoalign as size_t);
        luaL_checkstack(L, 2 as i32, c"too many results".as_ptr());
        n += 1;
        n;
        match opt as u32 {
            0 | 1 => {
                let mut res: lua_Integer = unpackint(
                    L,
                    data.offset(pos as isize),
                    h.islittle,
                    size,
                    (opt as u32 == Kint as i32 as u32) as i32,
                );
                lua_pushinteger(L, res);
            }
            2 => {
                let mut f: std::ffi::c_float = 0.;
                copywithendian(
                    &mut f as *mut std::ffi::c_float as *mut std::ffi::c_char,
                    data.offset(pos as isize),
                    ::core::mem::size_of::<std::ffi::c_float>() as usize as i32,
                    h.islittle,
                );
                lua_pushnumber(L, f as lua_Number);
            }
            3 => {
                let mut f_0: lua_Number = 0.;
                copywithendian(
                    &mut f_0 as *mut lua_Number as *mut std::ffi::c_char,
                    data.offset(pos as isize),
                    ::core::mem::size_of::<lua_Number>() as usize as i32,
                    h.islittle,
                );
                lua_pushnumber(L, f_0);
            }
            4 => {
                let mut f_1: std::ffi::c_double = 0.;
                copywithendian(
                    &mut f_1 as *mut std::ffi::c_double as *mut std::ffi::c_char,
                    data.offset(pos as isize),
                    ::core::mem::size_of::<std::ffi::c_double>() as usize as i32,
                    h.islittle,
                );
                lua_pushnumber(L, f_1);
            }
            5 => {
                lua_pushlstring(L, data.offset(pos as isize), size as size_t);
            }
            6 => {
                let mut len: size_t =
                    unpackint(L, data.offset(pos as isize), h.islittle, size, 0) as size_t;
                (((len <= ld.wrapping_sub(pos).wrapping_sub(size as size_t)) as i32 != 0) as i32
                    as std::ffi::c_long
                    != 0
                    || luaL_argerror(L, 2 as i32, c"data string too short".as_ptr()) != 0)
                    as i32;
                lua_pushlstring(L, data.offset(pos as isize).offset(size as isize), len);
                pos = pos.wrapping_add(len);
            }
            7 => {
                let mut len_0: size_t = strlen(data.offset(pos as isize));
                (((pos.wrapping_add(len_0) < ld) as i32 != 0) as i32 as std::ffi::c_long != 0
                    || luaL_argerror(L, 2 as i32, c"unfinished string for format 'z'".as_ptr())
                        != 0) as i32;
                lua_pushlstring(L, data.offset(pos as isize), len_0);
                pos = pos.wrapping_add(len_0.wrapping_add(1 as i32 as size_t));
            }
            9 | 8 | 10 => {
                n -= 1;
                n;
            }
            _ => {}
        }
        pos = pos.wrapping_add(size as size_t);
    }
    lua_pushinteger(L, pos.wrapping_add(1 as i32 as size_t) as lua_Integer);
    return n + 1 as i32;
}
static mut strlib: [luaL_Reg; 18] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"byte".as_ptr(),
                func: Some(str_byte as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"char".as_ptr(),
                func: Some(str_char as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"dump".as_ptr(),
                func: Some(str_dump as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"find".as_ptr(),
                func: Some(str_find as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"format".as_ptr(),
                func: Some(str_format as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"gmatch".as_ptr(),
                func: Some(gmatch as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"gsub".as_ptr(),
                func: Some(str_gsub as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"len".as_ptr(),
                func: Some(str_len as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"lower".as_ptr(),
                func: Some(str_lower as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"match".as_ptr(),
                func: Some(str_match as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"rep".as_ptr(),
                func: Some(str_rep as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"reverse".as_ptr(),
                func: Some(str_reverse as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"sub".as_ptr(),
                func: Some(str_sub as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"upper".as_ptr(),
                func: Some(str_upper as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"pack".as_ptr(),
                func: Some(str_pack as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"packsize".as_ptr(),
                func: Some(str_packsize as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"unpack".as_ptr(),
                func: Some(str_unpack as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
unsafe extern "C-unwind" fn createmetatable(mut L: *mut lua_State) {
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 10]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const stringmetamethods).cast(), 0);
    lua_pushstring(L, c"".as_ptr());
    lua_pushvalue(L, -(2 as i32));
    lua_setmetatable(L, -(2 as i32));
    lua_settop(L, -(1 as i32) - 1 as i32);
    lua_pushvalue(L, -(2 as i32));
    lua_setfield(L, -(2 as i32), c"__index".as_ptr());
    lua_settop(L, -(1 as i32) - 1 as i32);
}
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_string(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 18]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const strlib).cast(), 0);
    createmetatable(L);
    return 1 as i32;
}
unsafe extern "C-unwind" fn checkfield(
    mut L: *mut lua_State,
    mut key: *const std::ffi::c_char,
    mut n: i32,
) -> i32 {
    lua_pushstring(L, key);
    return (lua_rawget(L, -n) != 0) as i32;
}
unsafe extern "C-unwind" fn checktab(mut L: *mut lua_State, mut arg: i32, mut what: i32) {
    if lua_type(L, arg) != 5 as i32 {
        let mut n: i32 = 1 as i32;
        if lua_getmetatable(L, arg) != 0
            && (what & 1 as i32 == 0 || {
                n += 1;
                checkfield(L, c"__index".as_ptr(), n) != 0
            })
            && (what & 2 as i32 == 0 || {
                n += 1;
                checkfield(L, c"__newindex".as_ptr(), n) != 0
            })
            && (what & 4 as i32 == 0 || {
                n += 1;
                checkfield(L, c"__len".as_ptr(), n) != 0
            })
        {
            lua_settop(L, -n - 1 as i32);
        } else {
            luaL_checktype(L, arg, 5 as i32);
        }
    }
}
unsafe extern "C-unwind" fn tinsert(mut L: *mut lua_State) -> i32 {
    let mut pos: lua_Integer = 0;
    checktab(L, 1 as i32, 1 as i32 | 2 as i32 | 4 as i32);
    let mut e: lua_Integer = luaL_len(L, 1 as i32);
    e = (e as lua_Unsigned).wrapping_add(1 as i32 as lua_Unsigned) as lua_Integer;
    match lua_gettop(L) {
        2 => {
            pos = e;
        }
        3 => {
            let mut i: lua_Integer = 0;
            pos = luaL_checkinteger(L, 2 as i32);
            ((((pos as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned) < e as lua_Unsigned)
                as i32
                != 0) as i32 as std::ffi::c_long
                != 0
                || luaL_argerror(L, 2 as i32, c"position out of bounds".as_ptr()) != 0)
                as i32;
            i = e;
            while i > pos {
                lua_geti(L, 1 as i32, i - 1 as i32 as lua_Integer);
                lua_seti(L, 1 as i32, i);
                i -= 1;
                i;
            }
        }
        _ => {
            return luaL_error(L, c"wrong number of arguments to 'insert'".as_ptr());
        }
    }
    lua_seti(L, 1 as i32, pos);
    return 0;
}
unsafe extern "C-unwind" fn tremove(mut L: *mut lua_State) -> i32 {
    checktab(L, 1 as i32, 1 as i32 | 2 as i32 | 4 as i32);
    let mut size: lua_Integer = luaL_len(L, 1 as i32);
    let mut pos: lua_Integer = luaL_optinteger(L, 2 as i32, size);
    if pos != size {
        ((((pos as lua_Unsigned).wrapping_sub(1 as u32 as lua_Unsigned) <= size as lua_Unsigned)
            as i32
            != 0) as i32 as std::ffi::c_long
            != 0
            || luaL_argerror(L, 2 as i32, c"position out of bounds".as_ptr()) != 0) as i32;
    }
    lua_geti(L, 1 as i32, pos);
    while pos < size {
        lua_geti(L, 1 as i32, pos + 1 as i32 as lua_Integer);
        lua_seti(L, 1 as i32, pos);
        pos += 1;
        pos;
    }
    lua_pushnil(L);
    lua_seti(L, 1 as i32, pos);
    return 1 as i32;
}
unsafe extern "C-unwind" fn tmove(mut L: *mut lua_State) -> i32 {
    let mut f: lua_Integer = luaL_checkinteger(L, 2 as i32);
    let mut e: lua_Integer = luaL_checkinteger(L, 3 as i32);
    let mut t: lua_Integer = luaL_checkinteger(L, 4 as i32);
    let mut tt: i32 = if !(lua_type(L, 5 as i32) <= 0) {
        5 as i32
    } else {
        1 as i32
    };
    checktab(L, 1 as i32, 1 as i32);
    checktab(L, tt, 2 as i32);
    if e >= f {
        let mut n: lua_Integer = 0;
        let mut i: lua_Integer = 0;
        (((f > 0 as lua_Integer || e < 9223372036854775807 as std::ffi::c_longlong + f) as i32 != 0)
            as i32 as std::ffi::c_long
            != 0
            || luaL_argerror(L, 3 as i32, c"too many elements to move".as_ptr()) != 0)
            as i32;
        n = e - f + 1 as i32 as lua_Integer;
        (((t <= 9223372036854775807 as std::ffi::c_longlong - n + 1 as i32 as std::ffi::c_longlong)
            as i32
            != 0) as i32 as std::ffi::c_long
            != 0
            || luaL_argerror(L, 4 as i32, c"destination wrap around".as_ptr()) != 0) as i32;
        if t > e || t <= f || tt != 1 as i32 && lua_compare(L, 1 as i32, tt, 0) == 0 {
            i = 0 as lua_Integer;
            while i < n {
                lua_geti(L, 1 as i32, f + i);
                lua_seti(L, tt, t + i);
                i += 1;
                i;
            }
        } else {
            i = n - 1 as i32 as lua_Integer;
            while i >= 0 as lua_Integer {
                lua_geti(L, 1 as i32, f + i);
                lua_seti(L, tt, t + i);
                i -= 1;
                i;
            }
        }
    }
    lua_pushvalue(L, tt);
    return 1 as i32;
}
unsafe extern "C-unwind" fn addfield(
    mut L: *mut lua_State,
    mut b: *mut luaL_Buffer,
    mut i: lua_Integer,
) {
    lua_geti(L, 1 as i32, i);
    if ((lua_isstring(L, -(1 as i32)) == 0) as i32 != 0) as i32 as std::ffi::c_long != 0 {
        luaL_error(
            L,
            c"invalid value (%s) at index %I in table for 'concat'".as_ptr(),
            lua_typename(L, lua_type(L, -(1 as i32))),
            i,
        );
    }
    luaL_addvalue(b);
}
unsafe extern "C-unwind" fn tconcat(mut L: *mut lua_State) -> i32 {
    let mut b: luaL_Buffer = luaL_Buffer {
        b: 0 as *mut std::ffi::c_char,
        size: 0,
        n: 0,
        L: 0 as *mut lua_State,
        init: C2RustUnnamed_15 { n: 0. },
    };
    checktab(L, 1 as i32, 1 as i32 | 4 as i32);
    let mut last: lua_Integer = luaL_len(L, 1 as i32);
    let mut lsep: size_t = 0;
    let mut sep: *const std::ffi::c_char = luaL_optlstring(L, 2 as i32, c"".as_ptr(), &mut lsep);
    let mut i: lua_Integer = luaL_optinteger(L, 3 as i32, 1 as i32 as lua_Integer);
    last = luaL_optinteger(L, 4 as i32, last);
    luaL_buffinit(L, &mut b);
    while i < last {
        addfield(L, &mut b, i);
        luaL_addlstring(&mut b, sep, lsep);
        i += 1;
        i;
    }
    if i == last {
        addfield(L, &mut b, i);
    }
    luaL_pushresult(&mut b);
    return 1 as i32;
}
unsafe extern "C-unwind" fn tpack(mut L: *mut lua_State) -> i32 {
    let mut i: i32 = 0;
    let mut n: i32 = lua_gettop(L);
    lua_createtable(L, n, 1 as i32);
    lua_rotate(L, 1 as i32, 1 as i32);
    i = n;
    while i >= 1 as i32 {
        lua_seti(L, 1 as i32, i as lua_Integer);
        i -= 1;
        i;
    }
    lua_pushinteger(L, n as lua_Integer);
    lua_setfield(L, 1 as i32, c"n".as_ptr());
    return 1 as i32;
}
unsafe extern "C-unwind" fn tunpack(mut L: *mut lua_State) -> i32 {
    let mut n: lua_Unsigned = 0;
    let mut i: lua_Integer = luaL_optinteger(L, 2 as i32, 1 as i32 as lua_Integer);
    let mut e: lua_Integer = if lua_type(L, 3 as i32) <= 0 {
        luaL_len(L, 1 as i32)
    } else {
        luaL_checkinteger(L, 3 as i32)
    };
    if i > e {
        return 0;
    }
    n = (e as lua_Unsigned).wrapping_sub(i as lua_Unsigned);
    if ((n >= 2147483647 as lua_Unsigned || {
        n = n.wrapping_add(1);
        lua_checkstack(L, n as i32) == 0
    }) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
    {
        return luaL_error(L, c"too many results to unpack".as_ptr());
    }
    while i < e {
        lua_geti(L, 1 as i32, i);
        i += 1;
        i;
    }
    lua_geti(L, 1 as i32, e);
    return n as i32;
}
unsafe extern "C-unwind" fn l_randomizePivot() -> u32 {
    let mut c: clock_t = clock();
    let mut t: time_t = time(0 as *mut time_t);
    let mut buff: [u32; 4] = [0; 4];
    let mut i: u32 = 0;
    let mut rnd: u32 = 0 as u32;
    memcpy(
        buff.as_mut_ptr() as *mut c_void,
        &mut c as *mut clock_t as *const c_void,
        (::core::mem::size_of::<clock_t>() as usize)
            .wrapping_div(::core::mem::size_of::<u32>() as usize)
            .wrapping_mul(::core::mem::size_of::<u32>() as usize),
    );
    memcpy(
        buff.as_mut_ptr().offset(
            (::core::mem::size_of::<clock_t>() as usize)
                .wrapping_div(::core::mem::size_of::<u32>() as usize) as isize,
        ) as *mut c_void,
        &mut t as *mut time_t as *const c_void,
        (::core::mem::size_of::<time_t>() as usize)
            .wrapping_div(::core::mem::size_of::<u32>() as usize)
            .wrapping_mul(::core::mem::size_of::<u32>() as usize),
    );
    i = 0 as u32;
    while (i as usize)
        < (::core::mem::size_of::<[u32; 4]>() as usize)
            .wrapping_div(::core::mem::size_of::<u32>() as usize)
    {
        rnd = rnd.wrapping_add(buff[i as usize]);
        i = i.wrapping_add(1);
        i;
    }
    return rnd;
}
unsafe extern "C-unwind" fn set2(mut L: *mut lua_State, mut i: IdxT, mut j: IdxT) {
    lua_seti(L, 1 as i32, i as lua_Integer);
    lua_seti(L, 1 as i32, j as lua_Integer);
}
unsafe extern "C-unwind" fn sort_comp(mut L: *mut lua_State, mut a: i32, mut b: i32) -> i32 {
    if lua_type(L, 2 as i32) == 0 {
        return lua_compare(L, a, b, 1 as i32);
    } else {
        let mut res: i32 = 0;
        lua_pushvalue(L, 2 as i32);
        lua_pushvalue(L, a - 1 as i32);
        lua_pushvalue(L, b - 2 as i32);
        lua_callk(L, 2 as i32, 1 as i32, 0 as lua_KContext, None);
        res = lua_toboolean(L, -(1 as i32));
        lua_settop(L, -(1 as i32) - 1 as i32);
        return res;
    };
}
unsafe extern "C-unwind" fn partition(mut L: *mut lua_State, mut lo: IdxT, mut up: IdxT) -> IdxT {
    let mut i: IdxT = lo;
    let mut j: IdxT = up.wrapping_sub(1 as i32 as IdxT);
    loop {
        loop {
            i = i.wrapping_add(1);
            lua_geti(L, 1 as i32, i as lua_Integer);
            if !(sort_comp(L, -(1 as i32), -(2 as i32)) != 0) {
                break;
            }
            if ((i == up.wrapping_sub(1 as i32 as IdxT)) as i32 != 0) as i32 as std::ffi::c_long
                != 0
            {
                luaL_error(L, c"invalid order function for sorting".as_ptr());
            }
            lua_settop(L, -(1 as i32) - 1 as i32);
        }
        loop {
            j = j.wrapping_sub(1);
            lua_geti(L, 1 as i32, j as lua_Integer);
            if !(sort_comp(L, -(3 as i32), -(1 as i32)) != 0) {
                break;
            }
            if ((j < i) as i32 != 0) as i32 as std::ffi::c_long != 0 {
                luaL_error(L, c"invalid order function for sorting".as_ptr());
            }
            lua_settop(L, -(1 as i32) - 1 as i32);
        }
        if j < i {
            lua_settop(L, -(1 as i32) - 1 as i32);
            set2(L, up.wrapping_sub(1 as i32 as IdxT), i);
            return i;
        }
        set2(L, i, j);
    }
}
unsafe extern "C-unwind" fn choosePivot(mut lo: IdxT, mut up: IdxT, mut rnd: u32) -> IdxT {
    let mut r4: IdxT = up.wrapping_sub(lo) / 4 as i32 as IdxT;
    let mut p: IdxT = rnd
        .wrapping_rem(r4 * 2 as i32 as IdxT)
        .wrapping_add(lo.wrapping_add(r4));
    return p;
}
unsafe extern "C-unwind" fn auxsort(
    mut L: *mut lua_State,
    mut lo: IdxT,
    mut up: IdxT,
    mut rnd: u32,
) {
    while lo < up {
        let mut p: IdxT = 0;
        let mut n: IdxT = 0;
        lua_geti(L, 1 as i32, lo as lua_Integer);
        lua_geti(L, 1 as i32, up as lua_Integer);
        if sort_comp(L, -(1 as i32), -(2 as i32)) != 0 {
            set2(L, lo, up);
        } else {
            lua_settop(L, -(2 as i32) - 1 as i32);
        }
        if up.wrapping_sub(lo) == 1 as i32 as IdxT {
            return;
        }
        if up.wrapping_sub(lo) < 100 as u32 || rnd == 0 as u32 {
            p = lo.wrapping_add(up) / 2 as i32 as IdxT;
        } else {
            p = choosePivot(lo, up, rnd);
        }
        lua_geti(L, 1 as i32, p as lua_Integer);
        lua_geti(L, 1 as i32, lo as lua_Integer);
        if sort_comp(L, -(2 as i32), -(1 as i32)) != 0 {
            set2(L, p, lo);
        } else {
            lua_settop(L, -(1 as i32) - 1 as i32);
            lua_geti(L, 1 as i32, up as lua_Integer);
            if sort_comp(L, -(1 as i32), -(2 as i32)) != 0 {
                set2(L, p, up);
            } else {
                lua_settop(L, -(2 as i32) - 1 as i32);
            }
        }
        if up.wrapping_sub(lo) == 2 as i32 as IdxT {
            return;
        }
        lua_geti(L, 1 as i32, p as lua_Integer);
        lua_pushvalue(L, -(1 as i32));
        lua_geti(
            L,
            1 as i32,
            up.wrapping_sub(1 as i32 as IdxT) as lua_Integer,
        );
        set2(L, p, up.wrapping_sub(1 as i32 as IdxT));
        p = partition(L, lo, up);
        if p.wrapping_sub(lo) < up.wrapping_sub(p) {
            auxsort(L, lo, p.wrapping_sub(1 as i32 as IdxT), rnd);
            n = p.wrapping_sub(lo);
            lo = p.wrapping_add(1 as i32 as IdxT);
        } else {
            auxsort(L, p.wrapping_add(1 as i32 as IdxT), up, rnd);
            n = up.wrapping_sub(p);
            up = p.wrapping_sub(1 as i32 as IdxT);
        }
        if up.wrapping_sub(lo) / 128 as i32 as IdxT > n {
            rnd = l_randomizePivot();
        }
    }
}
unsafe extern "C-unwind" fn sort(mut L: *mut lua_State) -> i32 {
    checktab(L, 1 as i32, 1 as i32 | 2 as i32 | 4 as i32);
    let mut n: lua_Integer = luaL_len(L, 1 as i32);
    if n > 1 as i32 as lua_Integer {
        (((n < 2147483647 as i32 as lua_Integer) as i32 != 0) as i32 as std::ffi::c_long != 0
            || luaL_argerror(L, 1 as i32, c"array too big".as_ptr()) != 0) as i32;
        if !(lua_type(L, 2 as i32) <= 0) {
            luaL_checktype(L, 2 as i32, 6 as i32);
        }
        lua_settop(L, 2 as i32);
        auxsort(L, 1 as i32 as IdxT, n as IdxT, 0 as u32);
    }
    return 0;
}
static mut tab_funcs: [luaL_Reg; 8] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"concat".as_ptr(),
                func: Some(tconcat as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"insert".as_ptr(),
                func: Some(tinsert as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"pack".as_ptr(),
                func: Some(tpack as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"unpack".as_ptr(),
                func: Some(tunpack as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"remove".as_ptr(),
                func: Some(tremove as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"move".as_ptr(),
                func: Some(tmove as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"sort".as_ptr(),
                func: Some(sort as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_table(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 8]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const tab_funcs).cast(), 0);
    return 1 as i32;
}
unsafe extern "C-unwind" fn u_posrelat(mut pos: lua_Integer, mut len: size_t) -> lua_Integer {
    if pos >= 0 as lua_Integer {
        return pos;
    } else if (0 as u32 as size_t).wrapping_sub(pos as size_t) > len {
        return 0 as lua_Integer;
    } else {
        return len as lua_Integer + pos + 1 as i32 as lua_Integer;
    };
}
unsafe extern "C-unwind" fn utf8_decode(
    mut s: *const std::ffi::c_char,
    mut val: *mut utfint,
    mut strict: i32,
) -> *const std::ffi::c_char {
    static mut limits: [utfint; 6] = [
        !(0 as utfint),
        0x80 as utfint,
        0x800 as utfint,
        0x10000 as u32,
        0x200000 as u32,
        0x4000000 as u32,
    ];
    let mut c: u32 = *s.offset(0 as isize) as u8 as u32;
    let mut res: utfint = 0 as utfint;
    if c < 0x80 as u32 {
        res = c;
    } else {
        let mut count: i32 = 0;
        while c & 0x40 as u32 != 0 {
            count += 1;
            let mut cc: u32 = *s.offset(count as isize) as u8 as u32;
            if !(cc & 0xc0 as u32 == 0x80 as u32) {
                return 0 as *const std::ffi::c_char;
            }
            res = res << 6 as i32 | cc & 0x3f as i32 as u32;
            c <<= 1 as i32;
        }
        res |= (c & 0x7f as i32 as u32) << count * 5 as i32;
        if count > 5 as i32 || res > 0x7fffffff as u32 || res < limits[count as usize] {
            return 0 as *const std::ffi::c_char;
        }
        s = s.offset(count as isize);
    }
    if strict != 0 {
        if res > 0x10ffff as u32 || 0xd800 as u32 <= res && res <= 0xdfff as u32 {
            return 0 as *const std::ffi::c_char;
        }
    }
    if !val.is_null() {
        *val = res;
    }
    return s.offset(1);
}
unsafe extern "C-unwind" fn utflen(mut L: *mut lua_State) -> i32 {
    let mut n: lua_Integer = 0 as lua_Integer;
    let mut len: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut len);
    let mut posi: lua_Integer =
        u_posrelat(luaL_optinteger(L, 2 as i32, 1 as i32 as lua_Integer), len);
    let mut posj: lua_Integer = u_posrelat(
        luaL_optinteger(L, 3 as i32, -(1 as i32) as lua_Integer),
        len,
    );
    let mut lax: i32 = lua_toboolean(L, 4 as i32);
    (((1 as i32 as lua_Integer <= posi && {
        posi -= 1;
        posi <= len as lua_Integer
    }) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
        || luaL_argerror(L, 2 as i32, c"initial position out of bounds".as_ptr()) != 0) as i32;
    posj -= 1;
    (((posj < len as lua_Integer) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 3 as i32, c"final position out of bounds".as_ptr()) != 0) as i32;
    while posi <= posj {
        let mut s1: *const std::ffi::c_char =
            utf8_decode(s.offset(posi as isize), 0 as *mut utfint, (lax == 0) as i32);
        if s1.is_null() {
            lua_pushnil(L);
            lua_pushinteger(L, posi + 1 as i32 as lua_Integer);
            return 2 as i32;
        }
        posi = s1.offset_from(s) as std::ffi::c_long as lua_Integer;
        n += 1;
        n;
    }
    lua_pushinteger(L, n);
    return 1 as i32;
}
unsafe extern "C-unwind" fn codepoint(mut L: *mut lua_State) -> i32 {
    let mut len: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut len);
    let mut posi: lua_Integer =
        u_posrelat(luaL_optinteger(L, 2 as i32, 1 as i32 as lua_Integer), len);
    let mut pose: lua_Integer = u_posrelat(luaL_optinteger(L, 3 as i32, posi), len);
    let mut lax: i32 = lua_toboolean(L, 4 as i32);
    let mut n: i32 = 0;
    let mut se: *const std::ffi::c_char = 0 as *const std::ffi::c_char;
    (((posi >= 1 as i32 as lua_Integer) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 2 as i32, c"out of bounds".as_ptr()) != 0) as i32;
    (((pose <= len as lua_Integer) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 3 as i32, c"out of bounds".as_ptr()) != 0) as i32;
    if posi > pose {
        return 0;
    }
    if pose - posi >= 2147483647 as i32 as lua_Integer {
        return luaL_error(L, c"string slice too long".as_ptr());
    }
    n = (pose - posi) as i32 + 1 as i32;
    luaL_checkstack(L, n, c"string slice too long".as_ptr());
    n = 0;
    se = s.offset(pose as isize);
    s = s.offset((posi - 1 as i32 as lua_Integer) as isize);
    while s < se {
        let mut code: utfint = 0;
        s = utf8_decode(s, &mut code, (lax == 0) as i32);
        if s.is_null() {
            return luaL_error(L, c"invalid UTF-8 code".as_ptr());
        }
        lua_pushinteger(L, code as lua_Integer);
        n += 1;
        n;
    }
    return n;
}
unsafe extern "C-unwind" fn pushutfchar(mut L: *mut lua_State, mut arg: i32) {
    let mut code: lua_Unsigned = luaL_checkinteger(L, arg) as lua_Unsigned;
    (((code <= 0x7fffffff as u32 as lua_Unsigned) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, arg, c"value out of range".as_ptr()) != 0) as i32;
    lua_pushfstring(L, c"%U".as_ptr(), code as std::ffi::c_long);
}
unsafe extern "C-unwind" fn utfchar(mut L: *mut lua_State) -> i32 {
    let mut n: i32 = lua_gettop(L);
    if n == 1 as i32 {
        pushutfchar(L, 1 as i32);
    } else {
        let mut i: i32 = 0;
        let mut b: luaL_Buffer = luaL_Buffer {
            b: 0 as *mut std::ffi::c_char,
            size: 0,
            n: 0,
            L: 0 as *mut lua_State,
            init: C2RustUnnamed_15 { n: 0. },
        };
        luaL_buffinit(L, &mut b);
        i = 1 as i32;
        while i <= n {
            pushutfchar(L, i);
            luaL_addvalue(&mut b);
            i += 1;
            i;
        }
        luaL_pushresult(&mut b);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn byteoffset(mut L: *mut lua_State) -> i32 {
    let mut len: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut len);
    let mut n: lua_Integer = luaL_checkinteger(L, 2 as i32);
    let mut posi: lua_Integer = (if n >= 0 as lua_Integer {
        1 as i32 as size_t
    } else {
        len.wrapping_add(1 as i32 as size_t)
    }) as lua_Integer;
    posi = u_posrelat(luaL_optinteger(L, 3 as i32, posi), len);
    (((1 as i32 as lua_Integer <= posi && {
        posi -= 1;
        posi <= len as lua_Integer
    }) as i32
        != 0) as i32 as std::ffi::c_long
        != 0
        || luaL_argerror(L, 3 as i32, c"position out of bounds".as_ptr()) != 0) as i32;
    if n == 0 as lua_Integer {
        while posi > 0 as lua_Integer && *s.offset(posi as isize) as i32 & 0xc0 == 0x80 {
            posi -= 1;
            posi;
        }
    } else {
        if *s.offset(posi as isize) as i32 & 0xc0 == 0x80 {
            return luaL_error(L, c"initial position is a continuation byte".as_ptr());
        }
        if n < 0 as lua_Integer {
            while n < 0 as lua_Integer && posi > 0 as lua_Integer {
                loop {
                    posi -= 1;
                    posi;
                    if !(posi > 0 as lua_Integer && *s.offset(posi as isize) as i32 & 0xc0 == 0x80)
                    {
                        break;
                    }
                }
                n += 1;
                n;
            }
        } else {
            n -= 1;
            n;
            while n > 0 as lua_Integer && posi < len as lua_Integer {
                loop {
                    posi += 1;
                    posi;
                    if !(*s.offset(posi as isize) as i32 & 0xc0 == 0x80) {
                        break;
                    }
                }
                n -= 1;
                n;
            }
        }
    }
    if n == 0 as lua_Integer {
        lua_pushinteger(L, posi + 1 as i32 as lua_Integer);
    } else {
        lua_pushnil(L);
    }
    return 1 as i32;
}
unsafe extern "C-unwind" fn iter_aux(mut L: *mut lua_State, mut strict: i32) -> i32 {
    let mut len: size_t = 0;
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, &mut len);
    let mut n: lua_Unsigned = lua_tointegerx(L, 2 as i32, 0 as *mut i32) as lua_Unsigned;
    if n < len as lua_Unsigned {
        while *s.offset(n as isize) as i32 & 0xc0 == 0x80 {
            n = n.wrapping_add(1);
            n;
        }
    }
    if n >= len as lua_Unsigned {
        return 0;
    } else {
        let mut code: utfint = 0;
        let mut next: *const std::ffi::c_char =
            utf8_decode(s.offset(n as isize), &mut code, strict);
        if next.is_null() || *next as i32 & 0xc0 == 0x80 {
            return luaL_error(L, c"invalid UTF-8 code".as_ptr());
        }
        lua_pushinteger(L, n.wrapping_add(1 as i32 as lua_Unsigned) as lua_Integer);
        lua_pushinteger(L, code as lua_Integer);
        return 2 as i32;
    };
}
unsafe extern "C-unwind" fn iter_auxstrict(mut L: *mut lua_State) -> i32 {
    return iter_aux(L, 1 as i32);
}
unsafe extern "C-unwind" fn iter_auxlax(mut L: *mut lua_State) -> i32 {
    return iter_aux(L, 0);
}
unsafe extern "C-unwind" fn iter_codes(mut L: *mut lua_State) -> i32 {
    let mut lax: i32 = lua_toboolean(L, 2 as i32);
    let mut s: *const std::ffi::c_char = luaL_checklstring(L, 1 as i32, 0 as *mut size_t);
    ((!(*s as i32 & 0xc0 == 0x80) as i32 != 0) as i32 as std::ffi::c_long != 0
        || luaL_argerror(L, 1 as i32, c"invalid UTF-8 code".as_ptr()) != 0) as i32;
    lua_pushcclosure(
        L,
        if lax != 0 {
            Some(iter_auxlax as unsafe extern "C-unwind" fn(*mut lua_State) -> i32)
        } else {
            Some(iter_auxstrict as unsafe extern "C-unwind" fn(*mut lua_State) -> i32)
        },
        0,
    );
    lua_pushvalue(L, 1 as i32);
    lua_pushinteger(L, 0 as lua_Integer);
    return 3 as i32;
}
static mut funcs: [luaL_Reg; 7] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"offset".as_ptr(),
                func: Some(byteoffset as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"codepoint".as_ptr(),
                func: Some(codepoint as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"char".as_ptr(),
                func: Some(utfchar as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"len".as_ptr(),
                func: Some(utflen as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"codes".as_ptr(),
                func: Some(iter_codes as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"charpattern".as_ptr(),
                func: None,
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaopen_utf8(mut L: *mut lua_State) -> i32 {
    luaL_checkversion_(
        L,
        504 as i32 as lua_Number,
        (::core::mem::size_of::<lua_Integer>() as usize)
            .wrapping_mul(16)
            .wrapping_add(::core::mem::size_of::<lua_Number>() as usize),
    );
    lua_createtable(
        L,
        0,
        (::core::mem::size_of::<[luaL_Reg; 7]>() as usize)
            .wrapping_div(::core::mem::size_of::<luaL_Reg>() as usize)
            .wrapping_sub(1) as i32,
    );
    luaL_setfuncs(L, (&raw const funcs).cast(), 0);
    lua_pushlstring(
        L,
        b"[\0-\x7F\xC2-\xFD][\x80-\xBF]*\0" as *const u8 as *const std::ffi::c_char,
        (::core::mem::size_of::<[std::ffi::c_char; 15]>() as usize)
            .wrapping_div(::core::mem::size_of::<std::ffi::c_char>() as usize)
            .wrapping_sub(1),
    );
    lua_setfield(L, -(2 as i32), c"charpattern".as_ptr());
    return 1 as i32;
}
static mut loadedlibs: [luaL_Reg; 11] = unsafe {
    [
        {
            let mut init = luaL_Reg {
                name: c"_G".as_ptr(),
                func: Some(luaopen_base as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"package".as_ptr(),
                func: Some(luaopen_package as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"coroutine".as_ptr(),
                func: Some(luaopen_coroutine as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"table".as_ptr(),
                func: Some(luaopen_table as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"io".as_ptr(),
                func: Some(luaopen_io as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"os".as_ptr(),
                func: Some(luaopen_os as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"string".as_ptr(),
                func: Some(luaopen_string as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"math".as_ptr(),
                func: Some(luaopen_math as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"utf8".as_ptr(),
                func: Some(luaopen_utf8 as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: c"debug".as_ptr(),
                func: Some(luaopen_debug as unsafe extern "C-unwind" fn(*mut lua_State) -> i32),
            };
            init
        },
        {
            let mut init = luaL_Reg {
                name: 0 as *const std::ffi::c_char,
                func: None,
            };
            init
        },
    ]
};
#[unsafe(no_mangle)]
pub unsafe extern "C-unwind" fn luaL_openlibs(mut L: *mut lua_State) {
    let mut lib: *const luaL_Reg = 0 as *const luaL_Reg;
    lib = (&raw const loadedlibs).cast();
    while ((*lib).func).is_some() {
        luaL_requiref(L, (*lib).name, (*lib).func, 1 as i32);
        lua_settop(L, -(1 as i32) - 1 as i32);
        lib = lib.offset(1);
        lib;
    }
}
